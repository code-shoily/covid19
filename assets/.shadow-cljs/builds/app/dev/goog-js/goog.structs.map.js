["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/structs/map.js"],"~:js","goog.provide(\"goog.structs.Map\");\ngoog.require(\"goog.iter.Iterator\");\ngoog.require(\"goog.iter.StopIteration\");\ngoog.structs.Map = function(opt_map, var_args) {\n  this.map_ = {};\n  this.keys_ = [];\n  this.count_ = 0;\n  this.version_ = 0;\n  var argLength = arguments.length;\n  if (argLength > 1) {\n    if (argLength % 2) {\n      throw new Error(\"Uneven number of arguments\");\n    }\n    for (var i = 0; i < argLength; i += 2) {\n      this.set(arguments[i], arguments[i + 1]);\n    }\n  } else {\n    if (opt_map) {\n      this.addAll(opt_map);\n    }\n  }\n};\ngoog.structs.Map.prototype.getCount = function() {\n  return this.count_;\n};\ngoog.structs.Map.prototype.getValues = function() {\n  this.cleanupKeysArray_();\n  var rv = [];\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    rv.push(this.map_[key]);\n  }\n  return rv;\n};\ngoog.structs.Map.prototype.getKeys = function() {\n  this.cleanupKeysArray_();\n  return this.keys_.concat();\n};\ngoog.structs.Map.prototype.containsKey = function(key) {\n  return goog.structs.Map.hasKey_(this.map_, key);\n};\ngoog.structs.Map.prototype.containsValue = function(val) {\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {\n      return true;\n    }\n  }\n  return false;\n};\ngoog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {\n  if (this === otherMap) {\n    return true;\n  }\n  if (this.count_ != otherMap.getCount()) {\n    return false;\n  }\n  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;\n  this.cleanupKeysArray_();\n  for (var key, i = 0; key = this.keys_[i]; i++) {\n    if (!equalityFn(this.get(key), otherMap.get(key))) {\n      return false;\n    }\n  }\n  return true;\n};\ngoog.structs.Map.defaultEquals = function(a, b) {\n  return a === b;\n};\ngoog.structs.Map.prototype.isEmpty = function() {\n  return this.count_ == 0;\n};\ngoog.structs.Map.prototype.clear = function() {\n  this.map_ = {};\n  this.keys_.length = 0;\n  this.count_ = 0;\n  this.version_ = 0;\n};\ngoog.structs.Map.prototype.remove = function(key) {\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\n    delete this.map_[key];\n    this.count_--;\n    this.version_++;\n    if (this.keys_.length > 2 * this.count_) {\n      this.cleanupKeysArray_();\n    }\n    return true;\n  }\n  return false;\n};\ngoog.structs.Map.prototype.cleanupKeysArray_ = function() {\n  if (this.count_ != this.keys_.length) {\n    var srcIndex = 0;\n    var destIndex = 0;\n    while (srcIndex < this.keys_.length) {\n      var key = this.keys_[srcIndex];\n      if (goog.structs.Map.hasKey_(this.map_, key)) {\n        this.keys_[destIndex++] = key;\n      }\n      srcIndex++;\n    }\n    this.keys_.length = destIndex;\n  }\n  if (this.count_ != this.keys_.length) {\n    var seen = {};\n    var srcIndex = 0;\n    var destIndex = 0;\n    while (srcIndex < this.keys_.length) {\n      var key = this.keys_[srcIndex];\n      if (!goog.structs.Map.hasKey_(seen, key)) {\n        this.keys_[destIndex++] = key;\n        seen[key] = 1;\n      }\n      srcIndex++;\n    }\n    this.keys_.length = destIndex;\n  }\n};\ngoog.structs.Map.prototype.get = function(key, opt_val) {\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\n    return this.map_[key];\n  }\n  return opt_val;\n};\ngoog.structs.Map.prototype.set = function(key, value) {\n  if (!goog.structs.Map.hasKey_(this.map_, key)) {\n    this.count_++;\n    this.keys_.push(key);\n    this.version_++;\n  }\n  this.map_[key] = value;\n};\ngoog.structs.Map.prototype.addAll = function(map) {\n  if (map instanceof goog.structs.Map) {\n    var keys = map.getKeys();\n    for (var i = 0; i < keys.length; i++) {\n      this.set(keys[i], map.get(keys[i]));\n    }\n  } else {\n    for (var key in map) {\n      this.set(key, map[key]);\n    }\n  }\n};\ngoog.structs.Map.prototype.forEach = function(f, opt_obj) {\n  var keys = this.getKeys();\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = this.get(key);\n    f.call(opt_obj, value, key, this);\n  }\n};\ngoog.structs.Map.prototype.clone = function() {\n  return new goog.structs.Map(this);\n};\ngoog.structs.Map.prototype.transpose = function() {\n  var transposed = new goog.structs.Map;\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    var value = this.map_[key];\n    transposed.set(value, key);\n  }\n  return transposed;\n};\ngoog.structs.Map.prototype.toObject = function() {\n  this.cleanupKeysArray_();\n  var obj = {};\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    obj[key] = this.map_[key];\n  }\n  return obj;\n};\ngoog.structs.Map.prototype.getKeyIterator = function() {\n  return this.__iterator__(true);\n};\ngoog.structs.Map.prototype.getValueIterator = function() {\n  return this.__iterator__(false);\n};\ngoog.structs.Map.prototype.__iterator__ = function(opt_keys) {\n  this.cleanupKeysArray_();\n  var i = 0;\n  var version = this.version_;\n  var selfObj = this;\n  var newIter = new goog.iter.Iterator;\n  newIter.next = function() {\n    if (version != selfObj.version_) {\n      throw new Error(\"The map has changed since the iterator was created\");\n    }\n    if (i >= selfObj.keys_.length) {\n      throw goog.iter.StopIteration;\n    }\n    var key = selfObj.keys_[i++];\n    return opt_keys ? key : selfObj.map_[key];\n  };\n  return newIter;\n};\ngoog.structs.Map.hasKey_ = function(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Datastructure: Hash Map.\n *\n *\n * This file contains an implementation of a Map structure. It implements a lot\n * of the methods used in goog.structs so those functions work on hashes. This\n * is best suited for complex key types. For simple keys such as numbers and\n * strings consider using the lighter-weight utilities in goog.object.\n */\n\n\ngoog.provide('goog.structs.Map');\n\ngoog.require('goog.iter.Iterator');\ngoog.require('goog.iter.StopIteration');\n\n\n\n/**\n * Class for Hash Map datastructure.\n * @param {*=} opt_map Map or Object to initialize the map with.\n * @param {...*} var_args If 2 or more arguments are present then they\n *     will be used as key-value pairs.\n * @constructor\n * @template K, V\n * @deprecated This type is misleading: use ES6 Map instead.\n */\ngoog.structs.Map = function(opt_map, var_args) {\n  'use strict';\n  /**\n   * Underlying JS object used to implement the map.\n   * @private {!Object}\n   */\n  this.map_ = {};\n\n  /**\n   * An array of keys. This is necessary for two reasons:\n   *   1. Iterating the keys using for (var key in this.map_) allocates an\n   *      object for every key in IE which is really bad for IE6 GC perf.\n   *   2. Without a side data structure, we would need to escape all the keys\n   *      as that would be the only way we could tell during iteration if the\n   *      key was an internal key or a property of the object.\n   *\n   * This array can contain deleted keys so it's necessary to check the map\n   * as well to see if the key is still in the map (this doesn't require a\n   * memory allocation in IE).\n   * @private {!Array<string>}\n   */\n  this.keys_ = [];\n\n  /**\n   * The number of key value pairs in the map.\n   * @private {number}\n   */\n  this.count_ = 0;\n\n  /**\n   * Version used to detect changes while iterating.\n   * @private {number}\n   */\n  this.version_ = 0;\n\n  var argLength = arguments.length;\n\n  if (argLength > 1) {\n    if (argLength % 2) {\n      throw new Error('Uneven number of arguments');\n    }\n    for (var i = 0; i < argLength; i += 2) {\n      this.set(arguments[i], arguments[i + 1]);\n    }\n  } else if (opt_map) {\n    this.addAll(/** @type {!Object} */ (opt_map));\n  }\n};\n\n\n/**\n * @return {number} The number of key-value pairs in the map.\n */\ngoog.structs.Map.prototype.getCount = function() {\n  'use strict';\n  return this.count_;\n};\n\n\n/**\n * Returns the values of the map.\n * @return {!Array<V>} The values in the map.\n */\ngoog.structs.Map.prototype.getValues = function() {\n  'use strict';\n  this.cleanupKeysArray_();\n\n  var rv = [];\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    rv.push(this.map_[key]);\n  }\n  return rv;\n};\n\n\n/**\n * Returns the keys of the map.\n * @return {!Array<string>} Array of string values.\n */\ngoog.structs.Map.prototype.getKeys = function() {\n  'use strict';\n  this.cleanupKeysArray_();\n  return /** @type {!Array<string>} */ (this.keys_.concat());\n};\n\n\n/**\n * Whether the map contains the given key.\n * @param {*} key The key to check for.\n * @return {boolean} Whether the map contains the key.\n */\ngoog.structs.Map.prototype.containsKey = function(key) {\n  'use strict';\n  return goog.structs.Map.hasKey_(this.map_, key);\n};\n\n\n/**\n * Whether the map contains the given value. This is O(n).\n * @param {V} val The value to check for.\n * @return {boolean} Whether the map contains the value.\n */\ngoog.structs.Map.prototype.containsValue = function(val) {\n  'use strict';\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Whether this map is equal to the argument map.\n * @param {goog.structs.Map} otherMap The map against which to test equality.\n * @param {function(V, V): boolean=} opt_equalityFn Optional equality function\n *     to test equality of values. If not specified, this will test whether\n *     the values contained in each map are identical objects.\n * @return {boolean} Whether the maps are equal.\n */\ngoog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {\n  'use strict';\n  if (this === otherMap) {\n    return true;\n  }\n\n  if (this.count_ != otherMap.getCount()) {\n    return false;\n  }\n\n  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;\n\n  this.cleanupKeysArray_();\n  for (var key, i = 0; key = this.keys_[i]; i++) {\n    if (!equalityFn(this.get(key), otherMap.get(key))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n\n/**\n * Default equality test for values.\n * @param {*} a The first value.\n * @param {*} b The second value.\n * @return {boolean} Whether a and b reference the same object.\n */\ngoog.structs.Map.defaultEquals = function(a, b) {\n  'use strict';\n  return a === b;\n};\n\n\n/**\n * @return {boolean} Whether the map is empty.\n */\ngoog.structs.Map.prototype.isEmpty = function() {\n  'use strict';\n  return this.count_ == 0;\n};\n\n\n/**\n * Removes all key-value pairs from the map.\n */\ngoog.structs.Map.prototype.clear = function() {\n  'use strict';\n  this.map_ = {};\n  this.keys_.length = 0;\n  this.count_ = 0;\n  this.version_ = 0;\n};\n\n\n/**\n * Removes a key-value pair based on the key. This is O(logN) amortized due to\n * updating the keys array whenever the count becomes half the size of the keys\n * in the keys array.\n * @param {*} key  The key to remove.\n * @return {boolean} Whether object was removed.\n */\ngoog.structs.Map.prototype.remove = function(key) {\n  'use strict';\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\n    delete this.map_[key];\n    this.count_--;\n    this.version_++;\n\n    // clean up the keys array if the threshold is hit\n    if (this.keys_.length > 2 * this.count_) {\n      this.cleanupKeysArray_();\n    }\n\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Cleans up the temp keys array by removing entries that are no longer in the\n * map.\n * @private\n */\ngoog.structs.Map.prototype.cleanupKeysArray_ = function() {\n  'use strict';\n  if (this.count_ != this.keys_.length) {\n    // First remove keys that are no longer in the map.\n    var srcIndex = 0;\n    var destIndex = 0;\n    while (srcIndex < this.keys_.length) {\n      var key = this.keys_[srcIndex];\n      if (goog.structs.Map.hasKey_(this.map_, key)) {\n        this.keys_[destIndex++] = key;\n      }\n      srcIndex++;\n    }\n    this.keys_.length = destIndex;\n  }\n\n  if (this.count_ != this.keys_.length) {\n    // If the count still isn't correct, that means we have duplicates. This can\n    // happen when the same key is added and removed multiple times. Now we have\n    // to allocate one extra Object to remove the duplicates. This could have\n    // been done in the first pass, but in the common case, we can avoid\n    // allocating an extra object by only doing this when necessary.\n    var seen = {};\n    var srcIndex = 0;\n    var destIndex = 0;\n    while (srcIndex < this.keys_.length) {\n      var key = this.keys_[srcIndex];\n      if (!(goog.structs.Map.hasKey_(seen, key))) {\n        this.keys_[destIndex++] = key;\n        seen[key] = 1;\n      }\n      srcIndex++;\n    }\n    this.keys_.length = destIndex;\n  }\n};\n\n\n/**\n * Returns the value for the given key.  If the key is not found and the default\n * value is not given this will return `undefined`.\n * @param {*} key The key to get the value for.\n * @param {DEFAULT=} opt_val The value to return if no item is found for the\n *     given key, defaults to undefined.\n * @return {V|DEFAULT} The value for the given key.\n * @template DEFAULT\n */\ngoog.structs.Map.prototype.get = function(key, opt_val) {\n  'use strict';\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\n    return this.map_[key];\n  }\n  return opt_val;\n};\n\n\n/**\n * Adds a key-value pair to the map.\n * @param {*} key The key.\n * @param {V} value The value to add.\n * @return {*} Some subclasses return a value.\n */\ngoog.structs.Map.prototype.set = function(key, value) {\n  'use strict';\n  if (!(goog.structs.Map.hasKey_(this.map_, key))) {\n    this.count_++;\n    // TODO(johnlenz): This class lies, it claims to return an array of string\n    // keys, but instead returns the original object used.\n    this.keys_.push(/** @type {?} */ (key));\n    // Only change the version if we add a new key.\n    this.version_++;\n  }\n  this.map_[key] = value;\n};\n\n\n/**\n * Adds multiple key-value pairs from another goog.structs.Map or Object.\n * @param {?Object} map Object containing the data to add.\n */\ngoog.structs.Map.prototype.addAll = function(map) {\n  'use strict';\n  if (map instanceof goog.structs.Map) {\n    var keys = map.getKeys();\n    for (var i = 0; i < keys.length; i++) {\n      this.set(keys[i], map.get(keys[i]));\n    }\n  } else {\n    for (var key in map) {\n      this.set(key, map[key]);\n    }\n  }\n};\n\n\n/**\n * Calls the given function on each entry in the map.\n * @param {function(this:T, V, K, goog.structs.Map<K,V>)} f\n * @param {T=} opt_obj The value of \"this\" inside f.\n * @template T\n */\ngoog.structs.Map.prototype.forEach = function(f, opt_obj) {\n  'use strict';\n  var keys = this.getKeys();\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = this.get(key);\n    f.call(opt_obj, value, key, this);\n  }\n};\n\n\n/**\n * Clones a map and returns a new map.\n * @return {!goog.structs.Map} A new map with the same key-value pairs.\n */\ngoog.structs.Map.prototype.clone = function() {\n  'use strict';\n  return new goog.structs.Map(this);\n};\n\n\n/**\n * Returns a new map in which all the keys and values are interchanged\n * (keys become values and values become keys). If multiple keys map to the\n * same value, the chosen transposed value is implementation-dependent.\n *\n * It acts very similarly to {goog.object.transpose(Object)}.\n *\n * @return {!goog.structs.Map} The transposed map.\n */\ngoog.structs.Map.prototype.transpose = function() {\n  'use strict';\n  var transposed = new goog.structs.Map();\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    var value = this.map_[key];\n    transposed.set(value, key);\n  }\n\n  return transposed;\n};\n\n\n/**\n * @return {!Object} Object representation of the map.\n */\ngoog.structs.Map.prototype.toObject = function() {\n  'use strict';\n  this.cleanupKeysArray_();\n  var obj = {};\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    obj[key] = this.map_[key];\n  }\n  return obj;\n};\n\n\n/**\n * Returns an iterator that iterates over the keys in the map.  Removal of keys\n * while iterating might have undesired side effects.\n * @return {!goog.iter.Iterator} An iterator over the keys in the map.\n */\ngoog.structs.Map.prototype.getKeyIterator = function() {\n  'use strict';\n  return this.__iterator__(true);\n};\n\n\n/**\n * Returns an iterator that iterates over the values in the map.  Removal of\n * keys while iterating might have undesired side effects.\n * @return {!goog.iter.Iterator} An iterator over the values in the map.\n */\ngoog.structs.Map.prototype.getValueIterator = function() {\n  'use strict';\n  return this.__iterator__(false);\n};\n\n\n/**\n * Returns an iterator that iterates over the values or the keys in the map.\n * This throws an exception if the map was mutated since the iterator was\n * created.\n * @param {boolean=} opt_keys True to iterate over the keys. False to iterate\n *     over the values.  The default value is false.\n * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.\n */\ngoog.structs.Map.prototype.__iterator__ = function(opt_keys) {\n  'use strict';\n  // Clean up keys to minimize the risk of iterating over dead keys.\n  this.cleanupKeysArray_();\n\n  var i = 0;\n  var version = this.version_;\n  var selfObj = this;\n\n  var newIter = new goog.iter.Iterator;\n  newIter.next = function() {\n    'use strict';\n    if (version != selfObj.version_) {\n      throw new Error('The map has changed since the iterator was created');\n    }\n    if (i >= selfObj.keys_.length) {\n      throw goog.iter.StopIteration;\n    }\n    var key = selfObj.keys_[i++];\n    return opt_keys ? key : selfObj.map_[key];\n  };\n  return newIter;\n};\n\n\n/**\n * Safe way to test for hasOwnProperty.  It even allows testing for\n * 'hasOwnProperty'.\n * @param {!Object} obj The object to test for presence of the given key.\n * @param {*} key The key to check for.\n * @return {boolean} Whether the object has the key.\n * @private\n */\ngoog.structs.Map.hasKey_ = function(obj, key) {\n  'use strict';\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n","~:compiled-at",1623605884902,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.structs.map.js\",\n\"lineCount\":201,\n\"mappings\":\"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\",\n\"sources\":[\"goog/structs/map.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n/**\\n * @fileoverview Datastructure: Hash Map.\\n *\\n *\\n * This file contains an implementation of a Map structure. It implements a lot\\n * of the methods used in goog.structs so those functions work on hashes. This\\n * is best suited for complex key types. For simple keys such as numbers and\\n * strings consider using the lighter-weight utilities in goog.object.\\n */\\n\\n\\ngoog.provide('goog.structs.Map');\\n\\ngoog.require('goog.iter.Iterator');\\ngoog.require('goog.iter.StopIteration');\\n\\n\\n\\n/**\\n * Class for Hash Map datastructure.\\n * @param {*=} opt_map Map or Object to initialize the map with.\\n * @param {...*} var_args If 2 or more arguments are present then they\\n *     will be used as key-value pairs.\\n * @constructor\\n * @template K, V\\n * @deprecated This type is misleading: use ES6 Map instead.\\n */\\ngoog.structs.Map = function(opt_map, var_args) {\\n  'use strict';\\n  /**\\n   * Underlying JS object used to implement the map.\\n   * @private {!Object}\\n   */\\n  this.map_ = {};\\n\\n  /**\\n   * An array of keys. This is necessary for two reasons:\\n   *   1. Iterating the keys using for (var key in this.map_) allocates an\\n   *      object for every key in IE which is really bad for IE6 GC perf.\\n   *   2. Without a side data structure, we would need to escape all the keys\\n   *      as that would be the only way we could tell during iteration if the\\n   *      key was an internal key or a property of the object.\\n   *\\n   * This array can contain deleted keys so it's necessary to check the map\\n   * as well to see if the key is still in the map (this doesn't require a\\n   * memory allocation in IE).\\n   * @private {!Array<string>}\\n   */\\n  this.keys_ = [];\\n\\n  /**\\n   * The number of key value pairs in the map.\\n   * @private {number}\\n   */\\n  this.count_ = 0;\\n\\n  /**\\n   * Version used to detect changes while iterating.\\n   * @private {number}\\n   */\\n  this.version_ = 0;\\n\\n  var argLength = arguments.length;\\n\\n  if (argLength > 1) {\\n    if (argLength % 2) {\\n      throw new Error('Uneven number of arguments');\\n    }\\n    for (var i = 0; i < argLength; i += 2) {\\n      this.set(arguments[i], arguments[i + 1]);\\n    }\\n  } else if (opt_map) {\\n    this.addAll(/** @type {!Object} */ (opt_map));\\n  }\\n};\\n\\n\\n/**\\n * @return {number} The number of key-value pairs in the map.\\n */\\ngoog.structs.Map.prototype.getCount = function() {\\n  'use strict';\\n  return this.count_;\\n};\\n\\n\\n/**\\n * Returns the values of the map.\\n * @return {!Array<V>} The values in the map.\\n */\\ngoog.structs.Map.prototype.getValues = function() {\\n  'use strict';\\n  this.cleanupKeysArray_();\\n\\n  var rv = [];\\n  for (var i = 0; i < this.keys_.length; i++) {\\n    var key = this.keys_[i];\\n    rv.push(this.map_[key]);\\n  }\\n  return rv;\\n};\\n\\n\\n/**\\n * Returns the keys of the map.\\n * @return {!Array<string>} Array of string values.\\n */\\ngoog.structs.Map.prototype.getKeys = function() {\\n  'use strict';\\n  this.cleanupKeysArray_();\\n  return /** @type {!Array<string>} */ (this.keys_.concat());\\n};\\n\\n\\n/**\\n * Whether the map contains the given key.\\n * @param {*} key The key to check for.\\n * @return {boolean} Whether the map contains the key.\\n */\\ngoog.structs.Map.prototype.containsKey = function(key) {\\n  'use strict';\\n  return goog.structs.Map.hasKey_(this.map_, key);\\n};\\n\\n\\n/**\\n * Whether the map contains the given value. This is O(n).\\n * @param {V} val The value to check for.\\n * @return {boolean} Whether the map contains the value.\\n */\\ngoog.structs.Map.prototype.containsValue = function(val) {\\n  'use strict';\\n  for (var i = 0; i < this.keys_.length; i++) {\\n    var key = this.keys_[i];\\n    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * Whether this map is equal to the argument map.\\n * @param {goog.structs.Map} otherMap The map against which to test equality.\\n * @param {function(V, V): boolean=} opt_equalityFn Optional equality function\\n *     to test equality of values. If not specified, this will test whether\\n *     the values contained in each map are identical objects.\\n * @return {boolean} Whether the maps are equal.\\n */\\ngoog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {\\n  'use strict';\\n  if (this === otherMap) {\\n    return true;\\n  }\\n\\n  if (this.count_ != otherMap.getCount()) {\\n    return false;\\n  }\\n\\n  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;\\n\\n  this.cleanupKeysArray_();\\n  for (var key, i = 0; key = this.keys_[i]; i++) {\\n    if (!equalityFn(this.get(key), otherMap.get(key))) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\n\\n/**\\n * Default equality test for values.\\n * @param {*} a The first value.\\n * @param {*} b The second value.\\n * @return {boolean} Whether a and b reference the same object.\\n */\\ngoog.structs.Map.defaultEquals = function(a, b) {\\n  'use strict';\\n  return a === b;\\n};\\n\\n\\n/**\\n * @return {boolean} Whether the map is empty.\\n */\\ngoog.structs.Map.prototype.isEmpty = function() {\\n  'use strict';\\n  return this.count_ == 0;\\n};\\n\\n\\n/**\\n * Removes all key-value pairs from the map.\\n */\\ngoog.structs.Map.prototype.clear = function() {\\n  'use strict';\\n  this.map_ = {};\\n  this.keys_.length = 0;\\n  this.count_ = 0;\\n  this.version_ = 0;\\n};\\n\\n\\n/**\\n * Removes a key-value pair based on the key. This is O(logN) amortized due to\\n * updating the keys array whenever the count becomes half the size of the keys\\n * in the keys array.\\n * @param {*} key  The key to remove.\\n * @return {boolean} Whether object was removed.\\n */\\ngoog.structs.Map.prototype.remove = function(key) {\\n  'use strict';\\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\\n    delete this.map_[key];\\n    this.count_--;\\n    this.version_++;\\n\\n    // clean up the keys array if the threshold is hit\\n    if (this.keys_.length > 2 * this.count_) {\\n      this.cleanupKeysArray_();\\n    }\\n\\n    return true;\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * Cleans up the temp keys array by removing entries that are no longer in the\\n * map.\\n * @private\\n */\\ngoog.structs.Map.prototype.cleanupKeysArray_ = function() {\\n  'use strict';\\n  if (this.count_ != this.keys_.length) {\\n    // First remove keys that are no longer in the map.\\n    var srcIndex = 0;\\n    var destIndex = 0;\\n    while (srcIndex < this.keys_.length) {\\n      var key = this.keys_[srcIndex];\\n      if (goog.structs.Map.hasKey_(this.map_, key)) {\\n        this.keys_[destIndex++] = key;\\n      }\\n      srcIndex++;\\n    }\\n    this.keys_.length = destIndex;\\n  }\\n\\n  if (this.count_ != this.keys_.length) {\\n    // If the count still isn't correct, that means we have duplicates. This can\\n    // happen when the same key is added and removed multiple times. Now we have\\n    // to allocate one extra Object to remove the duplicates. This could have\\n    // been done in the first pass, but in the common case, we can avoid\\n    // allocating an extra object by only doing this when necessary.\\n    var seen = {};\\n    var srcIndex = 0;\\n    var destIndex = 0;\\n    while (srcIndex < this.keys_.length) {\\n      var key = this.keys_[srcIndex];\\n      if (!(goog.structs.Map.hasKey_(seen, key))) {\\n        this.keys_[destIndex++] = key;\\n        seen[key] = 1;\\n      }\\n      srcIndex++;\\n    }\\n    this.keys_.length = destIndex;\\n  }\\n};\\n\\n\\n/**\\n * Returns the value for the given key.  If the key is not found and the default\\n * value is not given this will return `undefined`.\\n * @param {*} key The key to get the value for.\\n * @param {DEFAULT=} opt_val The value to return if no item is found for the\\n *     given key, defaults to undefined.\\n * @return {V|DEFAULT} The value for the given key.\\n * @template DEFAULT\\n */\\ngoog.structs.Map.prototype.get = function(key, opt_val) {\\n  'use strict';\\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\\n    return this.map_[key];\\n  }\\n  return opt_val;\\n};\\n\\n\\n/**\\n * Adds a key-value pair to the map.\\n * @param {*} key The key.\\n * @param {V} value The value to add.\\n * @return {*} Some subclasses return a value.\\n */\\ngoog.structs.Map.prototype.set = function(key, value) {\\n  'use strict';\\n  if (!(goog.structs.Map.hasKey_(this.map_, key))) {\\n    this.count_++;\\n    // TODO(johnlenz): This class lies, it claims to return an array of string\\n    // keys, but instead returns the original object used.\\n    this.keys_.push(/** @type {?} */ (key));\\n    // Only change the version if we add a new key.\\n    this.version_++;\\n  }\\n  this.map_[key] = value;\\n};\\n\\n\\n/**\\n * Adds multiple key-value pairs from another goog.structs.Map or Object.\\n * @param {?Object} map Object containing the data to add.\\n */\\ngoog.structs.Map.prototype.addAll = function(map) {\\n  'use strict';\\n  if (map instanceof goog.structs.Map) {\\n    var keys = map.getKeys();\\n    for (var i = 0; i < keys.length; i++) {\\n      this.set(keys[i], map.get(keys[i]));\\n    }\\n  } else {\\n    for (var key in map) {\\n      this.set(key, map[key]);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Calls the given function on each entry in the map.\\n * @param {function(this:T, V, K, goog.structs.Map<K,V>)} f\\n * @param {T=} opt_obj The value of \\\"this\\\" inside f.\\n * @template T\\n */\\ngoog.structs.Map.prototype.forEach = function(f, opt_obj) {\\n  'use strict';\\n  var keys = this.getKeys();\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var value = this.get(key);\\n    f.call(opt_obj, value, key, this);\\n  }\\n};\\n\\n\\n/**\\n * Clones a map and returns a new map.\\n * @return {!goog.structs.Map} A new map with the same key-value pairs.\\n */\\ngoog.structs.Map.prototype.clone = function() {\\n  'use strict';\\n  return new goog.structs.Map(this);\\n};\\n\\n\\n/**\\n * Returns a new map in which all the keys and values are interchanged\\n * (keys become values and values become keys). If multiple keys map to the\\n * same value, the chosen transposed value is implementation-dependent.\\n *\\n * It acts very similarly to {goog.object.transpose(Object)}.\\n *\\n * @return {!goog.structs.Map} The transposed map.\\n */\\ngoog.structs.Map.prototype.transpose = function() {\\n  'use strict';\\n  var transposed = new goog.structs.Map();\\n  for (var i = 0; i < this.keys_.length; i++) {\\n    var key = this.keys_[i];\\n    var value = this.map_[key];\\n    transposed.set(value, key);\\n  }\\n\\n  return transposed;\\n};\\n\\n\\n/**\\n * @return {!Object} Object representation of the map.\\n */\\ngoog.structs.Map.prototype.toObject = function() {\\n  'use strict';\\n  this.cleanupKeysArray_();\\n  var obj = {};\\n  for (var i = 0; i < this.keys_.length; i++) {\\n    var key = this.keys_[i];\\n    obj[key] = this.map_[key];\\n  }\\n  return obj;\\n};\\n\\n\\n/**\\n * Returns an iterator that iterates over the keys in the map.  Removal of keys\\n * while iterating might have undesired side effects.\\n * @return {!goog.iter.Iterator} An iterator over the keys in the map.\\n */\\ngoog.structs.Map.prototype.getKeyIterator = function() {\\n  'use strict';\\n  return this.__iterator__(true);\\n};\\n\\n\\n/**\\n * Returns an iterator that iterates over the values in the map.  Removal of\\n * keys while iterating might have undesired side effects.\\n * @return {!goog.iter.Iterator} An iterator over the values in the map.\\n */\\ngoog.structs.Map.prototype.getValueIterator = function() {\\n  'use strict';\\n  return this.__iterator__(false);\\n};\\n\\n\\n/**\\n * Returns an iterator that iterates over the values or the keys in the map.\\n * This throws an exception if the map was mutated since the iterator was\\n * created.\\n * @param {boolean=} opt_keys True to iterate over the keys. False to iterate\\n *     over the values.  The default value is false.\\n * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.\\n */\\ngoog.structs.Map.prototype.__iterator__ = function(opt_keys) {\\n  'use strict';\\n  // Clean up keys to minimize the risk of iterating over dead keys.\\n  this.cleanupKeysArray_();\\n\\n  var i = 0;\\n  var version = this.version_;\\n  var selfObj = this;\\n\\n  var newIter = new goog.iter.Iterator;\\n  newIter.next = function() {\\n    'use strict';\\n    if (version != selfObj.version_) {\\n      throw new Error('The map has changed since the iterator was created');\\n    }\\n    if (i >= selfObj.keys_.length) {\\n      throw goog.iter.StopIteration;\\n    }\\n    var key = selfObj.keys_[i++];\\n    return opt_keys ? key : selfObj.map_[key];\\n  };\\n  return newIter;\\n};\\n\\n\\n/**\\n * Safe way to test for hasOwnProperty.  It even allows testing for\\n * 'hasOwnProperty'.\\n * @param {!Object} obj The object to test for presence of the given key.\\n * @param {*} key The key to check for.\\n * @return {boolean} Whether the object has the key.\\n * @private\\n */\\ngoog.structs.Map.hasKey_ = function(obj, key) {\\n  'use strict';\\n  return Object.prototype.hasOwnProperty.call(obj, key);\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"structs\",\"Map\",\"goog.structs.Map\",\"opt_map\",\"var_args\",\"map_\",\"keys_\",\"count_\",\"version_\",\"argLength\",\"arguments\",\"length\",\"Error\",\"i\",\"set\",\"addAll\",\"prototype\",\"getCount\",\"goog.structs.Map.prototype.getCount\",\"getValues\",\"goog.structs.Map.prototype.getValues\",\"cleanupKeysArray_\",\"rv\",\"key\",\"push\",\"getKeys\",\"goog.structs.Map.prototype.getKeys\",\"concat\",\"containsKey\",\"goog.structs.Map.prototype.containsKey\",\"hasKey_\",\"containsValue\",\"goog.structs.Map.prototype.containsValue\",\"val\",\"equals\",\"goog.structs.Map.prototype.equals\",\"otherMap\",\"opt_equalityFn\",\"equalityFn\",\"defaultEquals\",\"get\",\"goog.structs.Map.defaultEquals\",\"a\",\"b\",\"isEmpty\",\"goog.structs.Map.prototype.isEmpty\",\"clear\",\"goog.structs.Map.prototype.clear\",\"remove\",\"goog.structs.Map.prototype.remove\",\"goog.structs.Map.prototype.cleanupKeysArray_\",\"srcIndex\",\"destIndex\",\"seen\",\"goog.structs.Map.prototype.get\",\"opt_val\",\"goog.structs.Map.prototype.set\",\"value\",\"goog.structs.Map.prototype.addAll\",\"map\",\"keys\",\"forEach\",\"goog.structs.Map.prototype.forEach\",\"f\",\"opt_obj\",\"call\",\"clone\",\"goog.structs.Map.prototype.clone\",\"transpose\",\"goog.structs.Map.prototype.transpose\",\"transposed\",\"toObject\",\"goog.structs.Map.prototype.toObject\",\"obj\",\"getKeyIterator\",\"goog.structs.Map.prototype.getKeyIterator\",\"__iterator__\",\"getValueIterator\",\"goog.structs.Map.prototype.getValueIterator\",\"goog.structs.Map.prototype.__iterator__\",\"opt_keys\",\"version\",\"selfObj\",\"newIter\",\"iter\",\"Iterator\",\"next\",\"newIter.next\",\"StopIteration\",\"goog.structs.Map.hasKey_\",\"Object\",\"hasOwnProperty\"]\n}\n"]