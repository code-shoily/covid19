["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/uri/utils.js"],"~:js","goog.provide(\"goog.uri.utils\");\ngoog.provide(\"goog.uri.utils.ComponentIndex\");\ngoog.provide(\"goog.uri.utils.QueryArray\");\ngoog.provide(\"goog.uri.utils.QueryValue\");\ngoog.provide(\"goog.uri.utils.StandardQueryParam\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.string\");\ngoog.uri.utils.CharCode_ = {AMPERSAND:38, EQUAL:61, HASH:35, QUESTION:63};\ngoog.uri.utils.buildFromEncodedParts = function(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n  var out = \"\";\n  if (opt_scheme) {\n    out += opt_scheme + \":\";\n  }\n  if (opt_domain) {\n    out += \"//\";\n    if (opt_userInfo) {\n      out += opt_userInfo + \"@\";\n    }\n    out += opt_domain;\n    if (opt_port) {\n      out += \":\" + opt_port;\n    }\n  }\n  if (opt_path) {\n    out += opt_path;\n  }\n  if (opt_queryData) {\n    out += \"?\" + opt_queryData;\n  }\n  if (opt_fragment) {\n    out += \"#\" + opt_fragment;\n  }\n  return out;\n};\ngoog.uri.utils.splitRe_ = new RegExp(\"^\" + \"(?:\" + \"([^:/?#.]+)\" + \":)?\" + \"(?://\" + \"(?:([^\\\\\\\\/?#]*)@)?\" + \"([^\\\\\\\\/?#]*?)\" + \"(?::([0-9]+))?\" + \"(?\\x3d[\\\\\\\\/?#]|$)\" + \")?\" + \"([^?#]+)?\" + \"(?:\\\\?([^#]*))?\" + \"(?:#([\\\\s\\\\S]*))?\" + \"$\");\ngoog.uri.utils.ComponentIndex = {SCHEME:1, USER_INFO:2, DOMAIN:3, PORT:4, PATH:5, QUERY_DATA:6, FRAGMENT:7};\ngoog.uri.utils.urlPackageSupportLoggingHandler_ = null;\ngoog.uri.utils.setUrlPackageSupportLoggingHandler = function(handler) {\n  goog.uri.utils.urlPackageSupportLoggingHandler_ = handler;\n};\ngoog.uri.utils.split = function(uri) {\n  var result = uri.match(goog.uri.utils.splitRe_);\n  if (goog.uri.utils.urlPackageSupportLoggingHandler_ && [\"http\", \"https\", \"ws\", \"wss\", \"ftp\"].indexOf(result[goog.uri.utils.ComponentIndex.SCHEME]) >= 0) {\n    goog.uri.utils.urlPackageSupportLoggingHandler_(uri);\n  }\n  return result;\n};\ngoog.uri.utils.decodeIfPossible_ = function(uri, opt_preserveReserved) {\n  if (!uri) {\n    return uri;\n  }\n  return opt_preserveReserved ? decodeURI(uri) : decodeURIComponent(uri);\n};\ngoog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {\n  return goog.uri.utils.split(uri)[componentIndex] || null;\n};\ngoog.uri.utils.getScheme = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(goog.uri.utils.ComponentIndex.SCHEME, uri);\n};\ngoog.uri.utils.getEffectiveScheme = function(uri) {\n  var scheme = goog.uri.utils.getScheme(uri);\n  if (!scheme && goog.global.self && goog.global.self.location) {\n    var protocol = goog.global.self.location.protocol;\n    scheme = protocol.substr(0, protocol.length - 1);\n  }\n  return scheme ? scheme.toLowerCase() : \"\";\n};\ngoog.uri.utils.getUserInfoEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(goog.uri.utils.ComponentIndex.USER_INFO, uri);\n};\ngoog.uri.utils.getUserInfo = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getUserInfoEncoded(uri));\n};\ngoog.uri.utils.getDomainEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(goog.uri.utils.ComponentIndex.DOMAIN, uri);\n};\ngoog.uri.utils.getDomain = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getDomainEncoded(uri), true);\n};\ngoog.uri.utils.getPort = function(uri) {\n  return Number(goog.uri.utils.getComponentByIndex_(goog.uri.utils.ComponentIndex.PORT, uri)) || null;\n};\ngoog.uri.utils.getPathEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(goog.uri.utils.ComponentIndex.PATH, uri);\n};\ngoog.uri.utils.getPath = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getPathEncoded(uri), true);\n};\ngoog.uri.utils.getQueryData = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(goog.uri.utils.ComponentIndex.QUERY_DATA, uri);\n};\ngoog.uri.utils.getFragmentEncoded = function(uri) {\n  var hashIndex = uri.indexOf(\"#\");\n  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);\n};\ngoog.uri.utils.setFragmentEncoded = function(uri, fragment) {\n  return goog.uri.utils.removeFragment(uri) + (fragment ? \"#\" + fragment : \"\");\n};\ngoog.uri.utils.getFragment = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(goog.uri.utils.getFragmentEncoded(uri));\n};\ngoog.uri.utils.getHost = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(pieces[goog.uri.utils.ComponentIndex.SCHEME], pieces[goog.uri.utils.ComponentIndex.USER_INFO], pieces[goog.uri.utils.ComponentIndex.DOMAIN], pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\ngoog.uri.utils.getOrigin = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(pieces[goog.uri.utils.ComponentIndex.SCHEME], null, pieces[goog.uri.utils.ComponentIndex.DOMAIN], pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\ngoog.uri.utils.getPathAndAfter = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(null, null, null, null, pieces[goog.uri.utils.ComponentIndex.PATH], pieces[goog.uri.utils.ComponentIndex.QUERY_DATA], pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\ngoog.uri.utils.removeFragment = function(uri) {\n  var hashIndex = uri.indexOf(\"#\");\n  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);\n};\ngoog.uri.utils.haveSameDomain = function(uri1, uri2) {\n  var pieces1 = goog.uri.utils.split(uri1);\n  var pieces2 = goog.uri.utils.split(uri2);\n  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] == pieces2[goog.uri.utils.ComponentIndex.DOMAIN] && pieces1[goog.uri.utils.ComponentIndex.SCHEME] == pieces2[goog.uri.utils.ComponentIndex.SCHEME] && pieces1[goog.uri.utils.ComponentIndex.PORT] == pieces2[goog.uri.utils.ComponentIndex.PORT];\n};\ngoog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {\n  goog.asserts.assert(uri.indexOf(\"#\") < 0 && uri.indexOf(\"?\") < 0, \"goog.uri.utils: Fragment or query identifiers are not supported: [%s]\", uri);\n};\ngoog.uri.utils.QueryValue;\ngoog.uri.utils.QueryArray;\ngoog.uri.utils.parseQueryData = function(encodedQuery, callback) {\n  if (!encodedQuery) {\n    return;\n  }\n  var pairs = encodedQuery.split(\"\\x26\");\n  for (var i = 0; i < pairs.length; i++) {\n    var indexOfEquals = pairs[i].indexOf(\"\\x3d\");\n    var name = null;\n    var value = null;\n    if (indexOfEquals >= 0) {\n      name = pairs[i].substring(0, indexOfEquals);\n      value = pairs[i].substring(indexOfEquals + 1);\n    } else {\n      name = pairs[i];\n    }\n    callback(name, value ? goog.string.urlDecode(value) : \"\");\n  }\n};\ngoog.uri.utils.splitQueryData_ = function(uri) {\n  var hashIndex = uri.indexOf(\"#\");\n  if (hashIndex < 0) {\n    hashIndex = uri.length;\n  }\n  var questionIndex = uri.indexOf(\"?\");\n  var queryData;\n  if (questionIndex < 0 || questionIndex > hashIndex) {\n    questionIndex = hashIndex;\n    queryData = \"\";\n  } else {\n    queryData = uri.substring(questionIndex + 1, hashIndex);\n  }\n  return [uri.substr(0, questionIndex), queryData, uri.substr(hashIndex)];\n};\ngoog.uri.utils.joinQueryData_ = function(parts) {\n  return parts[0] + (parts[1] ? \"?\" + parts[1] : \"\") + parts[2];\n};\ngoog.uri.utils.appendQueryData_ = function(queryData, newData) {\n  if (!newData) {\n    return queryData;\n  }\n  return queryData ? queryData + \"\\x26\" + newData : newData;\n};\ngoog.uri.utils.appendQueryDataToUri_ = function(uri, queryData) {\n  if (!queryData) {\n    return uri;\n  }\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  parts[1] = goog.uri.utils.appendQueryData_(parts[1], queryData);\n  return goog.uri.utils.joinQueryData_(parts);\n};\ngoog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {\n  goog.asserts.assertString(key);\n  if (Array.isArray(value)) {\n    goog.asserts.assertArray(value);\n    for (var j = 0; j < value.length; j++) {\n      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);\n    }\n  } else {\n    if (value != null) {\n      pairs.push(key + (value === \"\" ? \"\" : \"\\x3d\" + goog.string.urlEncode(value)));\n    }\n  }\n};\ngoog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {\n  goog.asserts.assert(Math.max(keysAndValues.length - (opt_startIndex || 0), 0) % 2 == 0, \"goog.uri.utils: Key/value lists must be even in length.\");\n  var params = [];\n  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {\n    var key = keysAndValues[i];\n    goog.uri.utils.appendKeyValuePairs_(key, keysAndValues[i + 1], params);\n  }\n  return params.join(\"\\x26\");\n};\ngoog.uri.utils.buildQueryDataFromMap = function(map) {\n  var params = [];\n  for (var key in map) {\n    goog.uri.utils.appendKeyValuePairs_(key, map[key], params);\n  }\n  return params.join(\"\\x26\");\n};\ngoog.uri.utils.appendParams = function(uri, var_args) {\n  var queryData = arguments.length == 2 ? goog.uri.utils.buildQueryData(arguments[1], 0) : goog.uri.utils.buildQueryData(arguments, 1);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\ngoog.uri.utils.appendParamsFromMap = function(uri, map) {\n  var queryData = goog.uri.utils.buildQueryDataFromMap(map);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\ngoog.uri.utils.appendParam = function(uri, key, opt_value) {\n  var value = opt_value != null ? \"\\x3d\" + goog.string.urlEncode(opt_value) : \"\";\n  return goog.uri.utils.appendQueryDataToUri_(uri, key + value);\n};\ngoog.uri.utils.findParam_ = function(uri, startIndex, keyEncoded, hashOrEndIndex) {\n  var index = startIndex;\n  var keyLength = keyEncoded.length;\n  while ((index = uri.indexOf(keyEncoded, index)) >= 0 && index < hashOrEndIndex) {\n    var precedingChar = uri.charCodeAt(index - 1);\n    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND || precedingChar == goog.uri.utils.CharCode_.QUESTION) {\n      var followingChar = uri.charCodeAt(index + keyLength);\n      if (!followingChar || followingChar == goog.uri.utils.CharCode_.EQUAL || followingChar == goog.uri.utils.CharCode_.AMPERSAND || followingChar == goog.uri.utils.CharCode_.HASH) {\n        return index;\n      }\n    }\n    index += keyLength + 1;\n  }\n  return -1;\n};\ngoog.uri.utils.hashOrEndRe_ = /#|$/;\ngoog.uri.utils.hasParam = function(uri, keyEncoded) {\n  return goog.uri.utils.findParam_(uri, 0, keyEncoded, uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;\n};\ngoog.uri.utils.getParamValue = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var foundIndex = goog.uri.utils.findParam_(uri, 0, keyEncoded, hashOrEndIndex);\n  if (foundIndex < 0) {\n    return null;\n  } else {\n    var endPosition = uri.indexOf(\"\\x26\", foundIndex);\n    if (endPosition < 0 || endPosition > hashOrEndIndex) {\n      endPosition = hashOrEndIndex;\n    }\n    foundIndex += keyEncoded.length + 1;\n    return goog.string.urlDecode(uri.substr(foundIndex, endPosition - foundIndex));\n  }\n};\ngoog.uri.utils.getParamValues = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var result = [];\n  while ((foundIndex = goog.uri.utils.findParam_(uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    position = uri.indexOf(\"\\x26\", foundIndex);\n    if (position < 0 || position > hashOrEndIndex) {\n      position = hashOrEndIndex;\n    }\n    foundIndex += keyEncoded.length + 1;\n    result.push(goog.string.urlDecode(uri.substr(foundIndex, position - foundIndex)));\n  }\n  return result;\n};\ngoog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;\ngoog.uri.utils.removeParam = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var buffer = [];\n  while ((foundIndex = goog.uri.utils.findParam_(uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    buffer.push(uri.substring(position, foundIndex));\n    position = Math.min(uri.indexOf(\"\\x26\", foundIndex) + 1 || hashOrEndIndex, hashOrEndIndex);\n  }\n  buffer.push(uri.substr(position));\n  return buffer.join(\"\").replace(goog.uri.utils.trailingQueryPunctuationRe_, \"$1\");\n};\ngoog.uri.utils.setParam = function(uri, keyEncoded, value) {\n  return goog.uri.utils.appendParam(goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);\n};\ngoog.uri.utils.setParamsFromMap = function(uri, params) {\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  var queryData = parts[1];\n  var buffer = [];\n  if (queryData) {\n    queryData.split(\"\\x26\").forEach(function(pair) {\n      var indexOfEquals = pair.indexOf(\"\\x3d\");\n      var name = indexOfEquals >= 0 ? pair.substr(0, indexOfEquals) : pair;\n      if (!params.hasOwnProperty(name)) {\n        buffer.push(pair);\n      }\n    });\n  }\n  parts[1] = goog.uri.utils.appendQueryData_(buffer.join(\"\\x26\"), goog.uri.utils.buildQueryDataFromMap(params));\n  return goog.uri.utils.joinQueryData_(parts);\n};\ngoog.uri.utils.appendPath = function(baseUri, path) {\n  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);\n  if (goog.string.endsWith(baseUri, \"/\")) {\n    baseUri = baseUri.substr(0, baseUri.length - 1);\n  }\n  if (goog.string.startsWith(path, \"/\")) {\n    path = path.substr(1);\n  }\n  return \"\" + baseUri + \"/\" + path;\n};\ngoog.uri.utils.setPath = function(uri, path) {\n  if (!goog.string.startsWith(path, \"/\")) {\n    path = \"/\" + path;\n  }\n  var parts = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(parts[goog.uri.utils.ComponentIndex.SCHEME], parts[goog.uri.utils.ComponentIndex.USER_INFO], parts[goog.uri.utils.ComponentIndex.DOMAIN], parts[goog.uri.utils.ComponentIndex.PORT], path, parts[goog.uri.utils.ComponentIndex.QUERY_DATA], parts[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\ngoog.uri.utils.StandardQueryParam = {RANDOM:\"zx\"};\ngoog.uri.utils.makeUnique = function(uri) {\n  return goog.uri.utils.setParam(uri, goog.uri.utils.StandardQueryParam.RANDOM, goog.string.getRandomString());\n};\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Simple utilities for dealing with URI strings.\n *\n * This package is deprecated in favour of the Closure URL package (goog.url)\n * when manipulating URIs for use by a browser. This package uses regular\n * expressions to parse a potential URI which can fall out of sync with how a\n * browser will actually interpret the URI. See\n * `goog.uri.utils.setUrlPackageSupportLoggingHandler` for one way to identify\n * URIs that should instead be parsed using the URL package.\n *\n * This is intended to be a lightweight alternative to constructing goog.Uri\n * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless\n * of how much of its functionality you use, this is designed to be a set of\n * mostly-independent utilities so that the compiler includes only what is\n * necessary for the task.  Estimated savings of porting is 5k pre-gzip and\n * 1.5k post-gzip.  To ensure the savings remain, future developers should\n * avoid adding new functionality to existing functions, but instead create\n * new ones and factor out shared code.\n *\n * Many of these utilities have limited functionality, tailored to common\n * cases.  The query parameter utilities assume that the parameter keys are\n * already encoded, since most keys are compile-time alphanumeric strings.  The\n * query parameter mutation utilities also do not tolerate fragment identifiers.\n *\n * By design, these functions can be slower than goog.Uri equivalents.\n * Repeated calls to some of functions may be quadratic in behavior for IE,\n * although the effect is somewhat limited given the 2kb limit.\n *\n * One advantage of the limited functionality here is that this approach is\n * less sensitive to differences in URI encodings than goog.Uri, since these\n * functions operate on strings directly, rather than decoding them and\n * then re-encoding.\n *\n * Uses features of RFC 3986 for parsing/formatting URIs:\n *   http://www.ietf.org/rfc/rfc3986.txt\n */\n\ngoog.provide('goog.uri.utils');\ngoog.provide('goog.uri.utils.ComponentIndex');\ngoog.provide('goog.uri.utils.QueryArray');\ngoog.provide('goog.uri.utils.QueryValue');\ngoog.provide('goog.uri.utils.StandardQueryParam');\n\ngoog.require('goog.asserts');\ngoog.require('goog.string');\n\n\n/**\n * Character codes inlined to avoid object allocations due to charCode.\n * @enum {number}\n * @private\n */\ngoog.uri.utils.CharCode_ = {\n  AMPERSAND: 38,\n  EQUAL: 61,\n  HASH: 35,\n  QUESTION: 63\n};\n\n\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param {?string=} opt_scheme The scheme such as 'http'.\n * @param {?string=} opt_userInfo The user name before the '@'.\n * @param {?string=} opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param {(string|number|null)=} opt_port The port number.\n * @param {?string=} opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param {?string=} opt_queryData The URI-encoded query data.\n * @param {?string=} opt_fragment The URI-encoded fragment identifier.\n * @return {string} The fully combined URI.\n */\ngoog.uri.utils.buildFromEncodedParts = function(\n    opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData,\n    opt_fragment) {\n  'use strict';\n  var out = '';\n\n  if (opt_scheme) {\n    out += opt_scheme + ':';\n  }\n\n  if (opt_domain) {\n    out += '//';\n\n    if (opt_userInfo) {\n      out += opt_userInfo + '@';\n    }\n\n    out += opt_domain;\n\n    if (opt_port) {\n      out += ':' + opt_port;\n    }\n  }\n\n  if (opt_path) {\n    out += opt_path;\n  }\n\n  if (opt_queryData) {\n    out += '?' + opt_queryData;\n  }\n\n  if (opt_fragment) {\n    out += '#' + opt_fragment;\n  }\n\n  return out;\n};\n\n\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n *\n * TODO(user): separate out the authority terminating characters once this\n * file is moved to ES6.\n * @type {!RegExp}\n * @private\n */\ngoog.uri.utils.splitRe_ = new RegExp(\n    '^' +  // Anchor against the entire string.\n    '(?:' +\n    '([^:/?#.]+)' +  // scheme - ignore special characters\n                     // used by other URL parts such as :,\n                     // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^\\\\\\\\/?#]*)@)?' +  // userInfo\n    '([^\\\\\\\\/?#]*?)' +       // domain\n    '(?::([0-9]+))?' +       // port\n    '(?=[\\\\\\\\/?#]|$)' +      // authority-terminating character.\n    ')?' +\n    '([^?#]+)?' +          // path\n    '(?:\\\\?([^#]*))?' +    // query\n    '(?:#([\\\\s\\\\S]*))?' +  // fragment. Can't use '.*' with 's' flag as Firefox\n                           // doesn't support the flag, and can't use an\n                           // \"everything set\" ([^]) as IE10 doesn't match any\n                           // characters with it.\n    '$');\n\n\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\ngoog.uri.utils.ComponentIndex = {\n  SCHEME: 1,\n  USER_INFO: 2,\n  DOMAIN: 3,\n  PORT: 4,\n  PATH: 5,\n  QUERY_DATA: 6,\n  FRAGMENT: 7\n};\n\n/**\n * @type {?function(string)}\n * @private\n */\ngoog.uri.utils.urlPackageSupportLoggingHandler_ = null;\n\n/**\n * @param {?function(string)} handler The handler function to call when a URI\n *     with a protocol that is better supported by the Closure URL package is\n *     detected.\n */\ngoog.uri.utils.setUrlPackageSupportLoggingHandler = function(handler) {\n  'use strict';\n  goog.uri.utils.urlPackageSupportLoggingHandler_ = handler;\n};\n\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.ComponentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {string} uri The URI string to examine.\n * @return {!Array<string|undefined>} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\ngoog.uri.utils.split = function(uri) {\n  'use strict';\n  // See @return comment -- never null.\n  var result = /** @type {!Array<string|undefined>} */ (\n      uri.match(goog.uri.utils.splitRe_));\n  if (goog.uri.utils.urlPackageSupportLoggingHandler_ &&\n      ['http', 'https', 'ws', 'wss',\n       'ftp'].indexOf(result[goog.uri.utils.ComponentIndex.SCHEME]) >= 0) {\n    goog.uri.utils.urlPackageSupportLoggingHandler_(uri);\n  }\n  return result;\n};\n\n\n/**\n * @param {?string} uri A possibly null string.\n * @param {boolean=} opt_preserveReserved If true, percent-encoding of RFC-3986\n *     reserved characters will not be removed.\n * @return {?string} The string URI-decoded, or null if uri is null.\n * @private\n */\ngoog.uri.utils.decodeIfPossible_ = function(uri, opt_preserveReserved) {\n  'use strict';\n  if (!uri) {\n    return uri;\n  }\n\n  return opt_preserveReserved ? decodeURI(uri) : decodeURIComponent(uri);\n};\n\n\n/**\n * Gets a URI component by index.\n *\n * It is preferred to use the getPathEncoded() variety of functions ahead,\n * since they are more readable.\n *\n * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.\n * @param {string} uri The URI to examine.\n * @return {?string} The still-encoded component, or null if the component\n *     is not present.\n * @private\n */\ngoog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {\n  'use strict';\n  // Convert undefined, null, and empty string into null.\n  return goog.uri.utils.split(uri)[componentIndex] || null;\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The protocol or scheme, or null if none.  Does not\n *     include trailing colons or slashes.\n */\ngoog.uri.utils.getScheme = function(uri) {\n  'use strict';\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.SCHEME, uri);\n};\n\n\n/**\n * Gets the effective scheme for the URL.  If the URL is relative then the\n * scheme is derived from the page's location.\n * @param {string} uri The URI to examine.\n * @return {string} The protocol or scheme, always lower case.\n */\ngoog.uri.utils.getEffectiveScheme = function(uri) {\n  'use strict';\n  var scheme = goog.uri.utils.getScheme(uri);\n  if (!scheme && goog.global.self && goog.global.self.location) {\n    var protocol = goog.global.self.location.protocol;\n    scheme = protocol.substr(0, protocol.length - 1);\n  }\n  // NOTE: When called from a web worker in Firefox 3.5, location may be null.\n  // All other browsers with web workers support self.location from the worker.\n  return scheme ? scheme.toLowerCase() : '';\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The user name still encoded, or null if none.\n */\ngoog.uri.utils.getUserInfoEncoded = function(uri) {\n  'use strict';\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.USER_INFO, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded user info, or null if none.\n */\ngoog.uri.utils.getUserInfo = function(uri) {\n  'use strict';\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getUserInfoEncoded(uri));\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The domain name still encoded, or null if none.\n */\ngoog.uri.utils.getDomainEncoded = function(uri) {\n  'use strict';\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.DOMAIN, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded domain, or null if none.\n */\ngoog.uri.utils.getDomain = function(uri) {\n  'use strict';\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getDomainEncoded(uri), true /* opt_preserveReserved */);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?number} The port number, or null if none.\n */\ngoog.uri.utils.getPort = function(uri) {\n  'use strict';\n  // Coerce to a number.  If the result of getComponentByIndex_ is null or\n  // non-numeric, the number coersion yields NaN.  This will then return\n  // null for all non-numeric cases (though also zero, which isn't a relevant\n  // port number).\n  return Number(\n             goog.uri.utils.getComponentByIndex_(\n                 goog.uri.utils.ComponentIndex.PORT, uri)) ||\n      null;\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The path still encoded, or null if none. Includes the\n *     leading slash, if any.\n */\ngoog.uri.utils.getPathEncoded = function(uri) {\n  'use strict';\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.PATH, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded path, or null if none.  Includes the leading\n *     slash, if any.\n */\ngoog.uri.utils.getPath = function(uri) {\n  'use strict';\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getPathEncoded(uri), true /* opt_preserveReserved */);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The query data still encoded, or null if none.  Does not\n *     include the question mark itself.\n */\ngoog.uri.utils.getQueryData = function(uri) {\n  'use strict';\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The fragment identifier, or null if none.  Does not\n *     include the hash mark itself.\n */\ngoog.uri.utils.getFragmentEncoded = function(uri) {\n  'use strict';\n  // The hash mark may not appear in any other part of the URL.\n  var hashIndex = uri.indexOf('#');\n  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @param {?string} fragment The encoded fragment identifier, or null if none.\n *     Does not include the hash mark itself.\n * @return {string} The URI with the fragment set.\n */\ngoog.uri.utils.setFragmentEncoded = function(uri, fragment) {\n  'use strict';\n  return goog.uri.utils.removeFragment(uri) + (fragment ? '#' + fragment : '');\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded fragment identifier, or null if none.  Does\n *     not include the hash mark.\n */\ngoog.uri.utils.getFragment = function(uri) {\n  'use strict';\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getFragmentEncoded(uri));\n};\n\n\n/**\n * Extracts everything up to the port of the URI.\n * @param {string} uri The URI string.\n * @return {string} Everything up to and including the port.\n */\ngoog.uri.utils.getHost = function(uri) {\n  'use strict';\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      pieces[goog.uri.utils.ComponentIndex.SCHEME],\n      pieces[goog.uri.utils.ComponentIndex.USER_INFO],\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\n\n\n/**\n * Returns the origin for a given URL.\n * @param {string} uri The URI string.\n * @return {string} Everything up to and including the port.\n */\ngoog.uri.utils.getOrigin = function(uri) {\n  'use strict';\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      pieces[goog.uri.utils.ComponentIndex.SCHEME], null /* opt_userInfo */,\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\n\n\n/**\n * Extracts the path of the URL and everything after.\n * @param {string} uri The URI string.\n * @return {string} The URI, starting at the path and including the query\n *     parameters and fragment identifier.\n */\ngoog.uri.utils.getPathAndAfter = function(uri) {\n  'use strict';\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      null, null, null, null, pieces[goog.uri.utils.ComponentIndex.PATH],\n      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],\n      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\n\n\n/**\n * Gets the URI with the fragment identifier removed.\n * @param {string} uri The URI to examine.\n * @return {string} Everything preceding the hash mark.\n */\ngoog.uri.utils.removeFragment = function(uri) {\n  'use strict';\n  // The hash mark may not appear in any other part of the URL.\n  var hashIndex = uri.indexOf('#');\n  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);\n};\n\n\n/**\n * Ensures that two URI's have the exact same domain, scheme, and port.\n *\n * Unlike the version in goog.Uri, this checks protocol, and therefore is\n * suitable for checking against the browser's same-origin policy.\n *\n * @param {string} uri1 The first URI.\n * @param {string} uri2 The second URI.\n * @return {boolean} Whether they have the same scheme, domain and port.\n */\ngoog.uri.utils.haveSameDomain = function(uri1, uri2) {\n  'use strict';\n  var pieces1 = goog.uri.utils.split(uri1);\n  var pieces2 = goog.uri.utils.split(uri2);\n  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==\n      pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&\n      pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==\n      pieces2[goog.uri.utils.ComponentIndex.SCHEME] &&\n      pieces1[goog.uri.utils.ComponentIndex.PORT] ==\n      pieces2[goog.uri.utils.ComponentIndex.PORT];\n};\n\n\n/**\n * Asserts that there are no fragment or query identifiers, only in uncompiled\n * mode.\n * @param {string} uri The URI to examine.\n * @private\n */\ngoog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {\n  'use strict';\n  goog.asserts.assert(\n      uri.indexOf('#') < 0 && uri.indexOf('?') < 0,\n      'goog.uri.utils: Fragment or query identifiers are not supported: [%s]',\n      uri);\n};\n\n\n/**\n * Supported query parameter values by the parameter serializing utilities.\n *\n * If a value is null or undefined, the key-value pair is skipped, as an easy\n * way to omit parameters conditionally.  Non-array parameters are converted\n * to a string and URI encoded.  Array values are expanded into multiple\n * &key=value pairs, with each element stringized and URI-encoded.\n *\n * @typedef {*}\n */\ngoog.uri.utils.QueryValue;\n\n\n/**\n * An array representing a set of query parameters with alternating keys\n * and values.\n *\n * Keys are assumed to be URI encoded already and live at even indices.  See\n * goog.uri.utils.QueryValue for details on how parameter values are encoded.\n *\n * Example:\n * <pre>\n * var data = [\n *   // Simple param: ?name=BobBarker\n *   'name', 'BobBarker',\n *   // Conditional param -- may be omitted entirely.\n *   'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,\n *   // Multi-valued param: &house=LosAngeles&house=NewYork&house=null\n *   'house', ['LosAngeles', 'NewYork', null]\n * ];\n * </pre>\n *\n * @typedef {!Array<string|goog.uri.utils.QueryValue>}\n */\ngoog.uri.utils.QueryArray;\n\n\n/**\n * Parses encoded query parameters and calls callback function for every\n * parameter found in the string.\n *\n * Missing value of parameter (e.g. “…&key&…”) is treated as if the value was an\n * empty string.  Keys may be empty strings (e.g. “…&=value&…”) which also means\n * that “…&=&…” and “…&&…” will result in an empty key and value.\n *\n * @param {string} encodedQuery Encoded query string excluding question mark at\n *     the beginning.\n * @param {function(string, string)} callback Function called for every\n *     parameter found in query string.  The first argument (name) will not be\n *     urldecoded (so the function is consistent with buildQueryData), but the\n *     second will.  If the parameter has no value (i.e. “=” was not present)\n *     the second argument (value) will be an empty string.\n */\ngoog.uri.utils.parseQueryData = function(encodedQuery, callback) {\n  'use strict';\n  if (!encodedQuery) {\n    return;\n  }\n  var pairs = encodedQuery.split('&');\n  for (var i = 0; i < pairs.length; i++) {\n    var indexOfEquals = pairs[i].indexOf('=');\n    var name = null;\n    var value = null;\n    if (indexOfEquals >= 0) {\n      name = pairs[i].substring(0, indexOfEquals);\n      value = pairs[i].substring(indexOfEquals + 1);\n    } else {\n      name = pairs[i];\n    }\n    callback(name, value ? goog.string.urlDecode(value) : '');\n  }\n};\n\n\n/**\n * Split the URI into 3 parts where the [1] is the queryData without a leading\n * '?'. For example, the URI http://foo.com/bar?a=b#abc returns\n * ['http://foo.com/bar','a=b','#abc'].\n * @param {string} uri The URI to parse.\n * @return {!Array<string>} An array representation of uri of length 3 where the\n *     middle value is the queryData without a leading '?'.\n * @private\n */\ngoog.uri.utils.splitQueryData_ = function(uri) {\n  'use strict';\n  // Find the query data and hash.\n  var hashIndex = uri.indexOf('#');\n  if (hashIndex < 0) {\n    hashIndex = uri.length;\n  }\n  var questionIndex = uri.indexOf('?');\n  var queryData;\n  if (questionIndex < 0 || questionIndex > hashIndex) {\n    questionIndex = hashIndex;\n    queryData = '';\n  } else {\n    queryData = uri.substring(questionIndex + 1, hashIndex);\n  }\n  return [uri.substr(0, questionIndex), queryData, uri.substr(hashIndex)];\n};\n\n\n/**\n * Join an array created by splitQueryData_ back into a URI.\n * @param {!Array<string>} parts A URI in the form generated by splitQueryData_.\n * @return {string} The joined URI.\n * @private\n */\ngoog.uri.utils.joinQueryData_ = function(parts) {\n  'use strict';\n  return parts[0] + (parts[1] ? '?' + parts[1] : '') + parts[2];\n};\n\n\n/**\n * @param {string} queryData\n * @param {string} newData\n * @return {string}\n * @private\n */\ngoog.uri.utils.appendQueryData_ = function(queryData, newData) {\n  'use strict';\n  if (!newData) {\n    return queryData;\n  }\n  return queryData ? queryData + '&' + newData : newData;\n};\n\n\n/**\n * @param {string} uri\n * @param {string} queryData\n * @return {string}\n * @private\n */\ngoog.uri.utils.appendQueryDataToUri_ = function(uri, queryData) {\n  'use strict';\n  if (!queryData) {\n    return uri;\n  }\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  parts[1] = goog.uri.utils.appendQueryData_(parts[1], queryData);\n  return goog.uri.utils.joinQueryData_(parts);\n};\n\n\n/**\n * Appends key=value pairs to an array, supporting multi-valued objects.\n * @param {*} key The key prefix.\n * @param {goog.uri.utils.QueryValue} value The value to serialize.\n * @param {!Array<string>} pairs The array to which the 'key=value' strings\n *     should be appended.\n * @private\n */\ngoog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {\n  'use strict';\n  goog.asserts.assertString(key);\n  if (Array.isArray(value)) {\n    // Convince the compiler it's an array.\n    goog.asserts.assertArray(value);\n    for (var j = 0; j < value.length; j++) {\n      // Convert to string explicitly, to short circuit the null and array\n      // logic in this function -- this ensures that null and undefined get\n      // written as literal 'null' and 'undefined', and arrays don't get\n      // expanded out but instead encoded in the default way.\n      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);\n    }\n  } else if (value != null) {\n    // Skip a top-level null or undefined entirely.\n    pairs.push(\n        key +\n        // Check for empty string. Zero gets encoded into the url as literal\n        // strings.  For empty string, skip the equal sign, to be consistent\n        // with UriBuilder.java.\n        (value === '' ? '' : '=' + goog.string.urlEncode(value)));\n  }\n};\n\n\n/**\n * Builds a query data string from a sequence of alternating keys and values.\n * Currently generates \"&key&\" for empty args.\n *\n * @param {!IArrayLike<string|goog.uri.utils.QueryValue>} keysAndValues\n *     Alternating keys and values. See the QueryArray typedef.\n * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\n */\ngoog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {\n  'use strict';\n  goog.asserts.assert(\n      Math.max(keysAndValues.length - (opt_startIndex || 0), 0) % 2 == 0,\n      'goog.uri.utils: Key/value lists must be even in length.');\n\n  var params = [];\n  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {\n    var key = /** @type {string} */ (keysAndValues[i]);\n    goog.uri.utils.appendKeyValuePairs_(key, keysAndValues[i + 1], params);\n  }\n  return params.join('&');\n};\n\n\n/**\n * Builds a query data string from a map.\n * Currently generates \"&key&\" for empty args.\n *\n * @param {!Object<string, goog.uri.utils.QueryValue>} map An object where keys\n *     are URI-encoded parameter keys, and the values are arbitrary types\n *     or arrays. Keys with a null value are dropped.\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\n */\ngoog.uri.utils.buildQueryDataFromMap = function(map) {\n  'use strict';\n  var params = [];\n  for (var key in map) {\n    goog.uri.utils.appendKeyValuePairs_(key, map[key], params);\n  }\n  return params.join('&');\n};\n\n\n/**\n * Appends URI parameters to an existing URI.\n *\n * The variable arguments may contain alternating keys and values.  Keys are\n * assumed to be already URI encoded.  The values should not be URI-encoded,\n * and will instead be encoded by this function.\n * <pre>\n * appendParams('http://www.foo.com?existing=true',\n *     'key1', 'value1',\n *     'key2', 'value?willBeEncoded',\n *     'key3', ['valueA', 'valueB', 'valueC'],\n *     'key4', null);\n * result: 'http://www.foo.com?existing=true&' +\n *     'key1=value1&' +\n *     'key2=value%3FwillBeEncoded&' +\n *     'key3=valueA&key3=valueB&key3=valueC'\n * </pre>\n *\n * A single call to this function will not exhibit quadratic behavior in IE,\n * whereas multiple repeated calls may, although the effect is limited by\n * fact that URL's generally can't exceed 2kb.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {...(goog.uri.utils.QueryArray|goog.uri.utils.QueryValue)}\n * var_args\n *     An array or argument list conforming to goog.uri.utils.QueryArray.\n * @return {string} The URI with all query parameters added.\n */\ngoog.uri.utils.appendParams = function(uri, var_args) {\n  'use strict';\n  var queryData = arguments.length == 2 ?\n      goog.uri.utils.buildQueryData(arguments[1], 0) :\n      goog.uri.utils.buildQueryData(arguments, 1);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\n\n\n/**\n * Appends query parameters from a map.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object<goog.uri.utils.QueryValue>} map An object where keys are\n *     URI-encoded parameter keys, and the values are arbitrary types or arrays.\n *     Keys with a null value are dropped.\n * @return {string} The new parameters.\n */\ngoog.uri.utils.appendParamsFromMap = function(uri, map) {\n  'use strict';\n  var queryData = goog.uri.utils.buildQueryDataFromMap(map);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\n\n\n/**\n * Appends a single URI parameter.\n *\n * Repeated calls to this can exhibit quadratic behavior in IE6 due to the\n * way string append works, though it should be limited given the 2kb limit.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {string} key The key, which must already be URI encoded.\n * @param {*=} opt_value The value, which will be stringized and encoded\n *     (assumed not already to be encoded).  If omitted, undefined, or null, the\n *     key will be added as a valueless parameter.\n * @return {string} The URI with the query parameter added.\n */\ngoog.uri.utils.appendParam = function(uri, key, opt_value) {\n  'use strict';\n  var value = (opt_value != null) ? '=' + goog.string.urlEncode(opt_value) : '';\n  return goog.uri.utils.appendQueryDataToUri_(uri, key + value);\n};\n\n\n/**\n * Finds the next instance of a query parameter with the specified name.\n *\n * Does not instantiate any objects.\n *\n * @param {string} uri The URI to search.  May contain a fragment identifier\n *     if opt_hashIndex is specified.\n * @param {number} startIndex The index to begin searching for the key at.  A\n *     match may be found even if this is one character after the ampersand.\n * @param {string} keyEncoded The URI-encoded key.\n * @param {number} hashOrEndIndex Index to stop looking at.  If a hash\n *     mark is present, it should be its index, otherwise it should be the\n *     length of the string.\n * @return {number} The position of the first character in the key's name,\n *     immediately after either a question mark or a dot.\n * @private\n */\ngoog.uri.utils.findParam_ = function(\n    uri, startIndex, keyEncoded, hashOrEndIndex) {\n  'use strict';\n  var index = startIndex;\n  var keyLength = keyEncoded.length;\n\n  // Search for the key itself and post-filter for surronuding punctuation,\n  // rather than expensively building a regexp.\n  while ((index = uri.indexOf(keyEncoded, index)) >= 0 &&\n         index < hashOrEndIndex) {\n    var precedingChar = uri.charCodeAt(index - 1);\n    // Ensure that the preceding character is '&' or '?'.\n    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||\n        precedingChar == goog.uri.utils.CharCode_.QUESTION) {\n      // Ensure the following character is '&', '=', '#', or NaN\n      // (end of string).\n      var followingChar = uri.charCodeAt(index + keyLength);\n      if (!followingChar || followingChar == goog.uri.utils.CharCode_.EQUAL ||\n          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||\n          followingChar == goog.uri.utils.CharCode_.HASH) {\n        return index;\n      }\n    }\n    index += keyLength + 1;\n  }\n\n  return -1;\n};\n\n\n/**\n * Regular expression for finding a hash mark or end of string.\n * @type {RegExp}\n * @private\n */\ngoog.uri.utils.hashOrEndRe_ = /#|$/;\n\n\n/**\n * Determines if the URI contains a specific key.\n *\n * Performs no object instantiations.\n *\n * @param {string} uri The URI to process.  May contain a fragment\n *     identifier.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {boolean} Whether the key is present.\n */\ngoog.uri.utils.hasParam = function(uri, keyEncoded) {\n  'use strict';\n  return goog.uri.utils.findParam_(\n             uri, 0, keyEncoded, uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;\n};\n\n\n/**\n * Gets the first value of a query parameter.\n * @param {string} uri The URI to process.  May contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {?string} The first value of the parameter (URI-decoded), or null\n *     if the parameter is not found.\n */\ngoog.uri.utils.getParamValue = function(uri, keyEncoded) {\n  'use strict';\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var foundIndex =\n      goog.uri.utils.findParam_(uri, 0, keyEncoded, hashOrEndIndex);\n\n  if (foundIndex < 0) {\n    return null;\n  } else {\n    var endPosition = uri.indexOf('&', foundIndex);\n    if (endPosition < 0 || endPosition > hashOrEndIndex) {\n      endPosition = hashOrEndIndex;\n    }\n    // Progress forth to the end of the \"key=\" or \"key&\" substring.\n    foundIndex += keyEncoded.length + 1;\n    // Use substr, because it (unlike substring) will return empty string\n    // if foundIndex > endPosition.\n    return goog.string.urlDecode(\n        uri.substr(foundIndex, endPosition - foundIndex));\n  }\n};\n\n\n/**\n * Gets all values of a query parameter.\n * @param {string} uri The URI to process.  May contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {!Array<string>} All URI-decoded values with the given key.\n *     If the key is not found, this will have length 0, but never be null.\n */\ngoog.uri.utils.getParamValues = function(uri, keyEncoded) {\n  'use strict';\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var result = [];\n\n  while ((foundIndex = goog.uri.utils.findParam_(\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    // Find where this parameter ends, either the '&' or the end of the\n    // query parameters.\n    position = uri.indexOf('&', foundIndex);\n    if (position < 0 || position > hashOrEndIndex) {\n      position = hashOrEndIndex;\n    }\n\n    // Progress forth to the end of the \"key=\" or \"key&\" substring.\n    foundIndex += keyEncoded.length + 1;\n    // Use substr, because it (unlike substring) will return empty string\n    // if foundIndex > position.\n    result.push(\n        goog.string.urlDecode(uri.substr(foundIndex, position - foundIndex)));\n  }\n\n  return result;\n};\n\n\n/**\n * Regexp to find trailing question marks and ampersands.\n * @type {RegExp}\n * @private\n */\ngoog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;\n\n\n/**\n * Removes all instances of a query parameter.\n * @param {string} uri The URI to process.  Must not contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.\n * @return {string} The URI with all instances of the parameter removed.\n */\ngoog.uri.utils.removeParam = function(uri, keyEncoded) {\n  'use strict';\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var buffer = [];\n\n  // Look for a query parameter.\n  while ((foundIndex = goog.uri.utils.findParam_(\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    // Get the portion of the query string up to, but not including, the ?\n    // or & starting the parameter.\n    buffer.push(uri.substring(position, foundIndex));\n    // Progress to immediately after the '&'.  If not found, go to the end.\n    // Avoid including the hash mark.\n    position = Math.min(\n        (uri.indexOf('&', foundIndex) + 1) || hashOrEndIndex, hashOrEndIndex);\n  }\n\n  // Append everything that is remaining.\n  buffer.push(uri.substr(position));\n\n  // Join the buffer, and remove trailing punctuation that remains.\n  return buffer.join('').replace(\n      goog.uri.utils.trailingQueryPunctuationRe_, '$1');\n};\n\n\n/**\n * Replaces all existing definitions of a parameter with a single definition.\n *\n * Repeated calls to this can exhibit quadratic behavior due to the need to\n * find existing instances and reconstruct the string, though it should be\n * limited given the 2kb limit.  Consider using appendParams or setParamsFromMap\n * to update multiple parameters in bulk.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {string} keyEncoded The key, which must already be URI encoded.\n * @param {*} value The value, which will be stringized and encoded (assumed\n *     not already to be encoded).\n * @return {string} The URI with the query parameter added.\n */\ngoog.uri.utils.setParam = function(uri, keyEncoded, value) {\n  'use strict';\n  return goog.uri.utils.appendParam(\n      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);\n};\n\n\n/**\n * Effeciently set or remove multiple query parameters in a URI. Order of\n * unchanged parameters will not be modified, all updated parameters will be\n * appended to the end of the query. Params with values of null or undefined are\n * removed.\n *\n * @param {string} uri The URI to process.\n * @param {!Object<string, goog.uri.utils.QueryValue>} params A list of\n *     parameters to update. If null or undefined, the param will be removed.\n * @return {string} An updated URI where the query data has been updated with\n *     the params.\n */\ngoog.uri.utils.setParamsFromMap = function(uri, params) {\n  'use strict';\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  var queryData = parts[1];\n  var buffer = [];\n  if (queryData) {\n    queryData.split('&').forEach(function(pair) {\n      'use strict';\n      var indexOfEquals = pair.indexOf('=');\n      var name = indexOfEquals >= 0 ? pair.substr(0, indexOfEquals) : pair;\n      if (!params.hasOwnProperty(name)) {\n        buffer.push(pair);\n      }\n    });\n  }\n  parts[1] = goog.uri.utils.appendQueryData_(\n      buffer.join('&'), goog.uri.utils.buildQueryDataFromMap(params));\n  return goog.uri.utils.joinQueryData_(parts);\n};\n\n\n/**\n * Generates a URI path using a given URI and a path with checks to\n * prevent consecutive \"//\". The baseUri passed in must not contain\n * query or fragment identifiers. The path to append may not contain query or\n * fragment identifiers.\n *\n * @param {string} baseUri URI to use as the base.\n * @param {string} path Path to append.\n * @return {string} Updated URI.\n */\ngoog.uri.utils.appendPath = function(baseUri, path) {\n  'use strict';\n  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);\n\n  // Remove any trailing '/'\n  if (goog.string.endsWith(baseUri, '/')) {\n    baseUri = baseUri.substr(0, baseUri.length - 1);\n  }\n  // Remove any leading '/'\n  if (goog.string.startsWith(path, '/')) {\n    path = path.substr(1);\n  }\n  return '' + baseUri + '/' + path;\n};\n\n\n/**\n * Replaces the path.\n * @param {string} uri URI to use as the base.\n * @param {string} path New path.\n * @return {string} Updated URI.\n */\ngoog.uri.utils.setPath = function(uri, path) {\n  'use strict';\n  // Add any missing '/'.\n  if (!goog.string.startsWith(path, '/')) {\n    path = '/' + path;\n  }\n  var parts = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      parts[goog.uri.utils.ComponentIndex.SCHEME],\n      parts[goog.uri.utils.ComponentIndex.USER_INFO],\n      parts[goog.uri.utils.ComponentIndex.DOMAIN],\n      parts[goog.uri.utils.ComponentIndex.PORT], path,\n      parts[goog.uri.utils.ComponentIndex.QUERY_DATA],\n      parts[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\n\n\n/**\n * Standard supported query parameters.\n * @enum {string}\n */\ngoog.uri.utils.StandardQueryParam = {\n\n  /** Unused parameter for unique-ifying. */\n  RANDOM: 'zx'\n};\n\n\n/**\n * Sets the zx parameter of a URI to a random value.\n * @param {string} uri Any URI.\n * @return {string} That URI with the \"zx\" parameter added or replaced to\n *     contain a random string.\n */\ngoog.uri.utils.makeUnique = function(uri) {\n  'use strict';\n  return goog.uri.utils.setParam(\n      uri, goog.uri.utils.StandardQueryParam.RANDOM,\n      goog.string.getRandomString());\n};\n","~:compiled-at",1623605884907,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.uri.utils.js\",\n\"lineCount\":320,\n\"mappings\":\"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\",\n\"sources\":[\"goog/uri/utils.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n/**\\n * @fileoverview Simple utilities for dealing with URI strings.\\n *\\n * This package is deprecated in favour of the Closure URL package (goog.url)\\n * when manipulating URIs for use by a browser. This package uses regular\\n * expressions to parse a potential URI which can fall out of sync with how a\\n * browser will actually interpret the URI. See\\n * `goog.uri.utils.setUrlPackageSupportLoggingHandler` for one way to identify\\n * URIs that should instead be parsed using the URL package.\\n *\\n * This is intended to be a lightweight alternative to constructing goog.Uri\\n * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless\\n * of how much of its functionality you use, this is designed to be a set of\\n * mostly-independent utilities so that the compiler includes only what is\\n * necessary for the task.  Estimated savings of porting is 5k pre-gzip and\\n * 1.5k post-gzip.  To ensure the savings remain, future developers should\\n * avoid adding new functionality to existing functions, but instead create\\n * new ones and factor out shared code.\\n *\\n * Many of these utilities have limited functionality, tailored to common\\n * cases.  The query parameter utilities assume that the parameter keys are\\n * already encoded, since most keys are compile-time alphanumeric strings.  The\\n * query parameter mutation utilities also do not tolerate fragment identifiers.\\n *\\n * By design, these functions can be slower than goog.Uri equivalents.\\n * Repeated calls to some of functions may be quadratic in behavior for IE,\\n * although the effect is somewhat limited given the 2kb limit.\\n *\\n * One advantage of the limited functionality here is that this approach is\\n * less sensitive to differences in URI encodings than goog.Uri, since these\\n * functions operate on strings directly, rather than decoding them and\\n * then re-encoding.\\n *\\n * Uses features of RFC 3986 for parsing/formatting URIs:\\n *   http://www.ietf.org/rfc/rfc3986.txt\\n */\\n\\ngoog.provide('goog.uri.utils');\\ngoog.provide('goog.uri.utils.ComponentIndex');\\ngoog.provide('goog.uri.utils.QueryArray');\\ngoog.provide('goog.uri.utils.QueryValue');\\ngoog.provide('goog.uri.utils.StandardQueryParam');\\n\\ngoog.require('goog.asserts');\\ngoog.require('goog.string');\\n\\n\\n/**\\n * Character codes inlined to avoid object allocations due to charCode.\\n * @enum {number}\\n * @private\\n */\\ngoog.uri.utils.CharCode_ = {\\n  AMPERSAND: 38,\\n  EQUAL: 61,\\n  HASH: 35,\\n  QUESTION: 63\\n};\\n\\n\\n/**\\n * Builds a URI string from already-encoded parts.\\n *\\n * No encoding is performed.  Any component may be omitted as either null or\\n * undefined.\\n *\\n * @param {?string=} opt_scheme The scheme such as 'http'.\\n * @param {?string=} opt_userInfo The user name before the '@'.\\n * @param {?string=} opt_domain The domain such as 'www.google.com', already\\n *     URI-encoded.\\n * @param {(string|number|null)=} opt_port The port number.\\n * @param {?string=} opt_path The path, already URI-encoded.  If it is not\\n *     empty, it must begin with a slash.\\n * @param {?string=} opt_queryData The URI-encoded query data.\\n * @param {?string=} opt_fragment The URI-encoded fragment identifier.\\n * @return {string} The fully combined URI.\\n */\\ngoog.uri.utils.buildFromEncodedParts = function(\\n    opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData,\\n    opt_fragment) {\\n  'use strict';\\n  var out = '';\\n\\n  if (opt_scheme) {\\n    out += opt_scheme + ':';\\n  }\\n\\n  if (opt_domain) {\\n    out += '//';\\n\\n    if (opt_userInfo) {\\n      out += opt_userInfo + '@';\\n    }\\n\\n    out += opt_domain;\\n\\n    if (opt_port) {\\n      out += ':' + opt_port;\\n    }\\n  }\\n\\n  if (opt_path) {\\n    out += opt_path;\\n  }\\n\\n  if (opt_queryData) {\\n    out += '?' + opt_queryData;\\n  }\\n\\n  if (opt_fragment) {\\n    out += '#' + opt_fragment;\\n  }\\n\\n  return out;\\n};\\n\\n\\n/**\\n * A regular expression for breaking a URI into its component parts.\\n *\\n * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B\\n * As the \\\"first-match-wins\\\" algorithm is identical to the \\\"greedy\\\"\\n * disambiguation method used by POSIX regular expressions, it is natural and\\n * commonplace to use a regular expression for parsing the potential five\\n * components of a URI reference.\\n *\\n * The following line is the regular expression for breaking-down a\\n * well-formed URI reference into its components.\\n *\\n * <pre>\\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\\n *  12            3  4          5       6  7        8 9\\n * </pre>\\n *\\n * The numbers in the second line above are only to assist readability; they\\n * indicate the reference points for each subexpression (i.e., each paired\\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\\n * For example, matching the above expression to\\n * <pre>\\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\\n * </pre>\\n * results in the following subexpression matches:\\n * <pre>\\n *    $1 = http:\\n *    $2 = http\\n *    $3 = //www.ics.uci.edu\\n *    $4 = www.ics.uci.edu\\n *    $5 = /pub/ietf/uri/\\n *    $6 = <undefined>\\n *    $7 = <undefined>\\n *    $8 = #Related\\n *    $9 = Related\\n * </pre>\\n * where <undefined> indicates that the component is not present, as is the\\n * case for the query component in the above example. Therefore, we can\\n * determine the value of the five components as\\n * <pre>\\n *    scheme    = $2\\n *    authority = $4\\n *    path      = $5\\n *    query     = $7\\n *    fragment  = $9\\n * </pre>\\n *\\n * The regular expression has been modified slightly to expose the\\n * userInfo, domain, and port separately from the authority.\\n * The modified version yields\\n * <pre>\\n *    $1 = http              scheme\\n *    $2 = <undefined>       userInfo -\\\\\\n *    $3 = www.ics.uci.edu   domain     | authority\\n *    $4 = <undefined>       port     -/\\n *    $5 = /pub/ietf/uri/    path\\n *    $6 = <undefined>       query without ?\\n *    $7 = Related           fragment without #\\n * </pre>\\n *\\n * TODO(user): separate out the authority terminating characters once this\\n * file is moved to ES6.\\n * @type {!RegExp}\\n * @private\\n */\\ngoog.uri.utils.splitRe_ = new RegExp(\\n    '^' +  // Anchor against the entire string.\\n    '(?:' +\\n    '([^:/?#.]+)' +  // scheme - ignore special characters\\n                     // used by other URL parts such as :,\\n                     // ?, /, #, and .\\n    ':)?' +\\n    '(?://' +\\n    '(?:([^\\\\\\\\\\\\\\\\/?#]*)@)?' +  // userInfo\\n    '([^\\\\\\\\\\\\\\\\/?#]*?)' +       // domain\\n    '(?::([0-9]+))?' +       // port\\n    '(?=[\\\\\\\\\\\\\\\\/?#]|$)' +      // authority-terminating character.\\n    ')?' +\\n    '([^?#]+)?' +          // path\\n    '(?:\\\\\\\\?([^#]*))?' +    // query\\n    '(?:#([\\\\\\\\s\\\\\\\\S]*))?' +  // fragment. Can't use '.*' with 's' flag as Firefox\\n                           // doesn't support the flag, and can't use an\\n                           // \\\"everything set\\\" ([^]) as IE10 doesn't match any\\n                           // characters with it.\\n    '$');\\n\\n\\n/**\\n * The index of each URI component in the return value of goog.uri.utils.split.\\n * @enum {number}\\n */\\ngoog.uri.utils.ComponentIndex = {\\n  SCHEME: 1,\\n  USER_INFO: 2,\\n  DOMAIN: 3,\\n  PORT: 4,\\n  PATH: 5,\\n  QUERY_DATA: 6,\\n  FRAGMENT: 7\\n};\\n\\n/**\\n * @type {?function(string)}\\n * @private\\n */\\ngoog.uri.utils.urlPackageSupportLoggingHandler_ = null;\\n\\n/**\\n * @param {?function(string)} handler The handler function to call when a URI\\n *     with a protocol that is better supported by the Closure URL package is\\n *     detected.\\n */\\ngoog.uri.utils.setUrlPackageSupportLoggingHandler = function(handler) {\\n  'use strict';\\n  goog.uri.utils.urlPackageSupportLoggingHandler_ = handler;\\n};\\n\\n/**\\n * Splits a URI into its component parts.\\n *\\n * Each component can be accessed via the component indices; for example:\\n * <pre>\\n * goog.uri.utils.split(someStr)[goog.uri.utils.ComponentIndex.QUERY_DATA];\\n * </pre>\\n *\\n * @param {string} uri The URI string to examine.\\n * @return {!Array<string|undefined>} Each component still URI-encoded.\\n *     Each component that is present will contain the encoded value, whereas\\n *     components that are not present will be undefined or empty, depending\\n *     on the browser's regular expression implementation.  Never null, since\\n *     arbitrary strings may still look like path names.\\n */\\ngoog.uri.utils.split = function(uri) {\\n  'use strict';\\n  // See @return comment -- never null.\\n  var result = /** @type {!Array<string|undefined>} */ (\\n      uri.match(goog.uri.utils.splitRe_));\\n  if (goog.uri.utils.urlPackageSupportLoggingHandler_ &&\\n      ['http', 'https', 'ws', 'wss',\\n       'ftp'].indexOf(result[goog.uri.utils.ComponentIndex.SCHEME]) >= 0) {\\n    goog.uri.utils.urlPackageSupportLoggingHandler_(uri);\\n  }\\n  return result;\\n};\\n\\n\\n/**\\n * @param {?string} uri A possibly null string.\\n * @param {boolean=} opt_preserveReserved If true, percent-encoding of RFC-3986\\n *     reserved characters will not be removed.\\n * @return {?string} The string URI-decoded, or null if uri is null.\\n * @private\\n */\\ngoog.uri.utils.decodeIfPossible_ = function(uri, opt_preserveReserved) {\\n  'use strict';\\n  if (!uri) {\\n    return uri;\\n  }\\n\\n  return opt_preserveReserved ? decodeURI(uri) : decodeURIComponent(uri);\\n};\\n\\n\\n/**\\n * Gets a URI component by index.\\n *\\n * It is preferred to use the getPathEncoded() variety of functions ahead,\\n * since they are more readable.\\n *\\n * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.\\n * @param {string} uri The URI to examine.\\n * @return {?string} The still-encoded component, or null if the component\\n *     is not present.\\n * @private\\n */\\ngoog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {\\n  'use strict';\\n  // Convert undefined, null, and empty string into null.\\n  return goog.uri.utils.split(uri)[componentIndex] || null;\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The protocol or scheme, or null if none.  Does not\\n *     include trailing colons or slashes.\\n */\\ngoog.uri.utils.getScheme = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.getComponentByIndex_(\\n      goog.uri.utils.ComponentIndex.SCHEME, uri);\\n};\\n\\n\\n/**\\n * Gets the effective scheme for the URL.  If the URL is relative then the\\n * scheme is derived from the page's location.\\n * @param {string} uri The URI to examine.\\n * @return {string} The protocol or scheme, always lower case.\\n */\\ngoog.uri.utils.getEffectiveScheme = function(uri) {\\n  'use strict';\\n  var scheme = goog.uri.utils.getScheme(uri);\\n  if (!scheme && goog.global.self && goog.global.self.location) {\\n    var protocol = goog.global.self.location.protocol;\\n    scheme = protocol.substr(0, protocol.length - 1);\\n  }\\n  // NOTE: When called from a web worker in Firefox 3.5, location may be null.\\n  // All other browsers with web workers support self.location from the worker.\\n  return scheme ? scheme.toLowerCase() : '';\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The user name still encoded, or null if none.\\n */\\ngoog.uri.utils.getUserInfoEncoded = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.getComponentByIndex_(\\n      goog.uri.utils.ComponentIndex.USER_INFO, uri);\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The decoded user info, or null if none.\\n */\\ngoog.uri.utils.getUserInfo = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.decodeIfPossible_(\\n      goog.uri.utils.getUserInfoEncoded(uri));\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The domain name still encoded, or null if none.\\n */\\ngoog.uri.utils.getDomainEncoded = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.getComponentByIndex_(\\n      goog.uri.utils.ComponentIndex.DOMAIN, uri);\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The decoded domain, or null if none.\\n */\\ngoog.uri.utils.getDomain = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.decodeIfPossible_(\\n      goog.uri.utils.getDomainEncoded(uri), true /* opt_preserveReserved */);\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?number} The port number, or null if none.\\n */\\ngoog.uri.utils.getPort = function(uri) {\\n  'use strict';\\n  // Coerce to a number.  If the result of getComponentByIndex_ is null or\\n  // non-numeric, the number coersion yields NaN.  This will then return\\n  // null for all non-numeric cases (though also zero, which isn't a relevant\\n  // port number).\\n  return Number(\\n             goog.uri.utils.getComponentByIndex_(\\n                 goog.uri.utils.ComponentIndex.PORT, uri)) ||\\n      null;\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The path still encoded, or null if none. Includes the\\n *     leading slash, if any.\\n */\\ngoog.uri.utils.getPathEncoded = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.getComponentByIndex_(\\n      goog.uri.utils.ComponentIndex.PATH, uri);\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The decoded path, or null if none.  Includes the leading\\n *     slash, if any.\\n */\\ngoog.uri.utils.getPath = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.decodeIfPossible_(\\n      goog.uri.utils.getPathEncoded(uri), true /* opt_preserveReserved */);\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The query data still encoded, or null if none.  Does not\\n *     include the question mark itself.\\n */\\ngoog.uri.utils.getQueryData = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.getComponentByIndex_(\\n      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The fragment identifier, or null if none.  Does not\\n *     include the hash mark itself.\\n */\\ngoog.uri.utils.getFragmentEncoded = function(uri) {\\n  'use strict';\\n  // The hash mark may not appear in any other part of the URL.\\n  var hashIndex = uri.indexOf('#');\\n  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @param {?string} fragment The encoded fragment identifier, or null if none.\\n *     Does not include the hash mark itself.\\n * @return {string} The URI with the fragment set.\\n */\\ngoog.uri.utils.setFragmentEncoded = function(uri, fragment) {\\n  'use strict';\\n  return goog.uri.utils.removeFragment(uri) + (fragment ? '#' + fragment : '');\\n};\\n\\n\\n/**\\n * @param {string} uri The URI to examine.\\n * @return {?string} The decoded fragment identifier, or null if none.  Does\\n *     not include the hash mark.\\n */\\ngoog.uri.utils.getFragment = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.decodeIfPossible_(\\n      goog.uri.utils.getFragmentEncoded(uri));\\n};\\n\\n\\n/**\\n * Extracts everything up to the port of the URI.\\n * @param {string} uri The URI string.\\n * @return {string} Everything up to and including the port.\\n */\\ngoog.uri.utils.getHost = function(uri) {\\n  'use strict';\\n  var pieces = goog.uri.utils.split(uri);\\n  return goog.uri.utils.buildFromEncodedParts(\\n      pieces[goog.uri.utils.ComponentIndex.SCHEME],\\n      pieces[goog.uri.utils.ComponentIndex.USER_INFO],\\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\\n};\\n\\n\\n/**\\n * Returns the origin for a given URL.\\n * @param {string} uri The URI string.\\n * @return {string} Everything up to and including the port.\\n */\\ngoog.uri.utils.getOrigin = function(uri) {\\n  'use strict';\\n  var pieces = goog.uri.utils.split(uri);\\n  return goog.uri.utils.buildFromEncodedParts(\\n      pieces[goog.uri.utils.ComponentIndex.SCHEME], null /* opt_userInfo */,\\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\\n};\\n\\n\\n/**\\n * Extracts the path of the URL and everything after.\\n * @param {string} uri The URI string.\\n * @return {string} The URI, starting at the path and including the query\\n *     parameters and fragment identifier.\\n */\\ngoog.uri.utils.getPathAndAfter = function(uri) {\\n  'use strict';\\n  var pieces = goog.uri.utils.split(uri);\\n  return goog.uri.utils.buildFromEncodedParts(\\n      null, null, null, null, pieces[goog.uri.utils.ComponentIndex.PATH],\\n      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],\\n      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);\\n};\\n\\n\\n/**\\n * Gets the URI with the fragment identifier removed.\\n * @param {string} uri The URI to examine.\\n * @return {string} Everything preceding the hash mark.\\n */\\ngoog.uri.utils.removeFragment = function(uri) {\\n  'use strict';\\n  // The hash mark may not appear in any other part of the URL.\\n  var hashIndex = uri.indexOf('#');\\n  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);\\n};\\n\\n\\n/**\\n * Ensures that two URI's have the exact same domain, scheme, and port.\\n *\\n * Unlike the version in goog.Uri, this checks protocol, and therefore is\\n * suitable for checking against the browser's same-origin policy.\\n *\\n * @param {string} uri1 The first URI.\\n * @param {string} uri2 The second URI.\\n * @return {boolean} Whether they have the same scheme, domain and port.\\n */\\ngoog.uri.utils.haveSameDomain = function(uri1, uri2) {\\n  'use strict';\\n  var pieces1 = goog.uri.utils.split(uri1);\\n  var pieces2 = goog.uri.utils.split(uri2);\\n  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==\\n      pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&\\n      pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==\\n      pieces2[goog.uri.utils.ComponentIndex.SCHEME] &&\\n      pieces1[goog.uri.utils.ComponentIndex.PORT] ==\\n      pieces2[goog.uri.utils.ComponentIndex.PORT];\\n};\\n\\n\\n/**\\n * Asserts that there are no fragment or query identifiers, only in uncompiled\\n * mode.\\n * @param {string} uri The URI to examine.\\n * @private\\n */\\ngoog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {\\n  'use strict';\\n  goog.asserts.assert(\\n      uri.indexOf('#') < 0 && uri.indexOf('?') < 0,\\n      'goog.uri.utils: Fragment or query identifiers are not supported: [%s]',\\n      uri);\\n};\\n\\n\\n/**\\n * Supported query parameter values by the parameter serializing utilities.\\n *\\n * If a value is null or undefined, the key-value pair is skipped, as an easy\\n * way to omit parameters conditionally.  Non-array parameters are converted\\n * to a string and URI encoded.  Array values are expanded into multiple\\n * &key=value pairs, with each element stringized and URI-encoded.\\n *\\n * @typedef {*}\\n */\\ngoog.uri.utils.QueryValue;\\n\\n\\n/**\\n * An array representing a set of query parameters with alternating keys\\n * and values.\\n *\\n * Keys are assumed to be URI encoded already and live at even indices.  See\\n * goog.uri.utils.QueryValue for details on how parameter values are encoded.\\n *\\n * Example:\\n * <pre>\\n * var data = [\\n *   // Simple param: ?name=BobBarker\\n *   'name', 'BobBarker',\\n *   // Conditional param -- may be omitted entirely.\\n *   'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,\\n *   // Multi-valued param: &house=LosAngeles&house=NewYork&house=null\\n *   'house', ['LosAngeles', 'NewYork', null]\\n * ];\\n * </pre>\\n *\\n * @typedef {!Array<string|goog.uri.utils.QueryValue>}\\n */\\ngoog.uri.utils.QueryArray;\\n\\n\\n/**\\n * Parses encoded query parameters and calls callback function for every\\n * parameter found in the string.\\n *\\n * Missing value of parameter (e.g. \\u201c\\u2026&key&\\u2026\\u201d) is treated as if the value was an\\n * empty string.  Keys may be empty strings (e.g. \\u201c\\u2026&=value&\\u2026\\u201d) which also means\\n * that \\u201c\\u2026&=&\\u2026\\u201d and \\u201c\\u2026&&\\u2026\\u201d will result in an empty key and value.\\n *\\n * @param {string} encodedQuery Encoded query string excluding question mark at\\n *     the beginning.\\n * @param {function(string, string)} callback Function called for every\\n *     parameter found in query string.  The first argument (name) will not be\\n *     urldecoded (so the function is consistent with buildQueryData), but the\\n *     second will.  If the parameter has no value (i.e. \\u201c=\\u201d was not present)\\n *     the second argument (value) will be an empty string.\\n */\\ngoog.uri.utils.parseQueryData = function(encodedQuery, callback) {\\n  'use strict';\\n  if (!encodedQuery) {\\n    return;\\n  }\\n  var pairs = encodedQuery.split('&');\\n  for (var i = 0; i < pairs.length; i++) {\\n    var indexOfEquals = pairs[i].indexOf('=');\\n    var name = null;\\n    var value = null;\\n    if (indexOfEquals >= 0) {\\n      name = pairs[i].substring(0, indexOfEquals);\\n      value = pairs[i].substring(indexOfEquals + 1);\\n    } else {\\n      name = pairs[i];\\n    }\\n    callback(name, value ? goog.string.urlDecode(value) : '');\\n  }\\n};\\n\\n\\n/**\\n * Split the URI into 3 parts where the [1] is the queryData without a leading\\n * '?'. For example, the URI http://foo.com/bar?a=b#abc returns\\n * ['http://foo.com/bar','a=b','#abc'].\\n * @param {string} uri The URI to parse.\\n * @return {!Array<string>} An array representation of uri of length 3 where the\\n *     middle value is the queryData without a leading '?'.\\n * @private\\n */\\ngoog.uri.utils.splitQueryData_ = function(uri) {\\n  'use strict';\\n  // Find the query data and hash.\\n  var hashIndex = uri.indexOf('#');\\n  if (hashIndex < 0) {\\n    hashIndex = uri.length;\\n  }\\n  var questionIndex = uri.indexOf('?');\\n  var queryData;\\n  if (questionIndex < 0 || questionIndex > hashIndex) {\\n    questionIndex = hashIndex;\\n    queryData = '';\\n  } else {\\n    queryData = uri.substring(questionIndex + 1, hashIndex);\\n  }\\n  return [uri.substr(0, questionIndex), queryData, uri.substr(hashIndex)];\\n};\\n\\n\\n/**\\n * Join an array created by splitQueryData_ back into a URI.\\n * @param {!Array<string>} parts A URI in the form generated by splitQueryData_.\\n * @return {string} The joined URI.\\n * @private\\n */\\ngoog.uri.utils.joinQueryData_ = function(parts) {\\n  'use strict';\\n  return parts[0] + (parts[1] ? '?' + parts[1] : '') + parts[2];\\n};\\n\\n\\n/**\\n * @param {string} queryData\\n * @param {string} newData\\n * @return {string}\\n * @private\\n */\\ngoog.uri.utils.appendQueryData_ = function(queryData, newData) {\\n  'use strict';\\n  if (!newData) {\\n    return queryData;\\n  }\\n  return queryData ? queryData + '&' + newData : newData;\\n};\\n\\n\\n/**\\n * @param {string} uri\\n * @param {string} queryData\\n * @return {string}\\n * @private\\n */\\ngoog.uri.utils.appendQueryDataToUri_ = function(uri, queryData) {\\n  'use strict';\\n  if (!queryData) {\\n    return uri;\\n  }\\n  var parts = goog.uri.utils.splitQueryData_(uri);\\n  parts[1] = goog.uri.utils.appendQueryData_(parts[1], queryData);\\n  return goog.uri.utils.joinQueryData_(parts);\\n};\\n\\n\\n/**\\n * Appends key=value pairs to an array, supporting multi-valued objects.\\n * @param {*} key The key prefix.\\n * @param {goog.uri.utils.QueryValue} value The value to serialize.\\n * @param {!Array<string>} pairs The array to which the 'key=value' strings\\n *     should be appended.\\n * @private\\n */\\ngoog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {\\n  'use strict';\\n  goog.asserts.assertString(key);\\n  if (Array.isArray(value)) {\\n    // Convince the compiler it's an array.\\n    goog.asserts.assertArray(value);\\n    for (var j = 0; j < value.length; j++) {\\n      // Convert to string explicitly, to short circuit the null and array\\n      // logic in this function -- this ensures that null and undefined get\\n      // written as literal 'null' and 'undefined', and arrays don't get\\n      // expanded out but instead encoded in the default way.\\n      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);\\n    }\\n  } else if (value != null) {\\n    // Skip a top-level null or undefined entirely.\\n    pairs.push(\\n        key +\\n        // Check for empty string. Zero gets encoded into the url as literal\\n        // strings.  For empty string, skip the equal sign, to be consistent\\n        // with UriBuilder.java.\\n        (value === '' ? '' : '=' + goog.string.urlEncode(value)));\\n  }\\n};\\n\\n\\n/**\\n * Builds a query data string from a sequence of alternating keys and values.\\n * Currently generates \\\"&key&\\\" for empty args.\\n *\\n * @param {!IArrayLike<string|goog.uri.utils.QueryValue>} keysAndValues\\n *     Alternating keys and values. See the QueryArray typedef.\\n * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.\\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\\n */\\ngoog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {\\n  'use strict';\\n  goog.asserts.assert(\\n      Math.max(keysAndValues.length - (opt_startIndex || 0), 0) % 2 == 0,\\n      'goog.uri.utils: Key/value lists must be even in length.');\\n\\n  var params = [];\\n  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {\\n    var key = /** @type {string} */ (keysAndValues[i]);\\n    goog.uri.utils.appendKeyValuePairs_(key, keysAndValues[i + 1], params);\\n  }\\n  return params.join('&');\\n};\\n\\n\\n/**\\n * Builds a query data string from a map.\\n * Currently generates \\\"&key&\\\" for empty args.\\n *\\n * @param {!Object<string, goog.uri.utils.QueryValue>} map An object where keys\\n *     are URI-encoded parameter keys, and the values are arbitrary types\\n *     or arrays. Keys with a null value are dropped.\\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\\n */\\ngoog.uri.utils.buildQueryDataFromMap = function(map) {\\n  'use strict';\\n  var params = [];\\n  for (var key in map) {\\n    goog.uri.utils.appendKeyValuePairs_(key, map[key], params);\\n  }\\n  return params.join('&');\\n};\\n\\n\\n/**\\n * Appends URI parameters to an existing URI.\\n *\\n * The variable arguments may contain alternating keys and values.  Keys are\\n * assumed to be already URI encoded.  The values should not be URI-encoded,\\n * and will instead be encoded by this function.\\n * <pre>\\n * appendParams('http://www.foo.com?existing=true',\\n *     'key1', 'value1',\\n *     'key2', 'value?willBeEncoded',\\n *     'key3', ['valueA', 'valueB', 'valueC'],\\n *     'key4', null);\\n * result: 'http://www.foo.com?existing=true&' +\\n *     'key1=value1&' +\\n *     'key2=value%3FwillBeEncoded&' +\\n *     'key3=valueA&key3=valueB&key3=valueC'\\n * </pre>\\n *\\n * A single call to this function will not exhibit quadratic behavior in IE,\\n * whereas multiple repeated calls may, although the effect is limited by\\n * fact that URL's generally can't exceed 2kb.\\n *\\n * @param {string} uri The original URI, which may already have query data.\\n * @param {...(goog.uri.utils.QueryArray|goog.uri.utils.QueryValue)}\\n * var_args\\n *     An array or argument list conforming to goog.uri.utils.QueryArray.\\n * @return {string} The URI with all query parameters added.\\n */\\ngoog.uri.utils.appendParams = function(uri, var_args) {\\n  'use strict';\\n  var queryData = arguments.length == 2 ?\\n      goog.uri.utils.buildQueryData(arguments[1], 0) :\\n      goog.uri.utils.buildQueryData(arguments, 1);\\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\\n};\\n\\n\\n/**\\n * Appends query parameters from a map.\\n *\\n * @param {string} uri The original URI, which may already have query data.\\n * @param {!Object<goog.uri.utils.QueryValue>} map An object where keys are\\n *     URI-encoded parameter keys, and the values are arbitrary types or arrays.\\n *     Keys with a null value are dropped.\\n * @return {string} The new parameters.\\n */\\ngoog.uri.utils.appendParamsFromMap = function(uri, map) {\\n  'use strict';\\n  var queryData = goog.uri.utils.buildQueryDataFromMap(map);\\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\\n};\\n\\n\\n/**\\n * Appends a single URI parameter.\\n *\\n * Repeated calls to this can exhibit quadratic behavior in IE6 due to the\\n * way string append works, though it should be limited given the 2kb limit.\\n *\\n * @param {string} uri The original URI, which may already have query data.\\n * @param {string} key The key, which must already be URI encoded.\\n * @param {*=} opt_value The value, which will be stringized and encoded\\n *     (assumed not already to be encoded).  If omitted, undefined, or null, the\\n *     key will be added as a valueless parameter.\\n * @return {string} The URI with the query parameter added.\\n */\\ngoog.uri.utils.appendParam = function(uri, key, opt_value) {\\n  'use strict';\\n  var value = (opt_value != null) ? '=' + goog.string.urlEncode(opt_value) : '';\\n  return goog.uri.utils.appendQueryDataToUri_(uri, key + value);\\n};\\n\\n\\n/**\\n * Finds the next instance of a query parameter with the specified name.\\n *\\n * Does not instantiate any objects.\\n *\\n * @param {string} uri The URI to search.  May contain a fragment identifier\\n *     if opt_hashIndex is specified.\\n * @param {number} startIndex The index to begin searching for the key at.  A\\n *     match may be found even if this is one character after the ampersand.\\n * @param {string} keyEncoded The URI-encoded key.\\n * @param {number} hashOrEndIndex Index to stop looking at.  If a hash\\n *     mark is present, it should be its index, otherwise it should be the\\n *     length of the string.\\n * @return {number} The position of the first character in the key's name,\\n *     immediately after either a question mark or a dot.\\n * @private\\n */\\ngoog.uri.utils.findParam_ = function(\\n    uri, startIndex, keyEncoded, hashOrEndIndex) {\\n  'use strict';\\n  var index = startIndex;\\n  var keyLength = keyEncoded.length;\\n\\n  // Search for the key itself and post-filter for surronuding punctuation,\\n  // rather than expensively building a regexp.\\n  while ((index = uri.indexOf(keyEncoded, index)) >= 0 &&\\n         index < hashOrEndIndex) {\\n    var precedingChar = uri.charCodeAt(index - 1);\\n    // Ensure that the preceding character is '&' or '?'.\\n    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||\\n        precedingChar == goog.uri.utils.CharCode_.QUESTION) {\\n      // Ensure the following character is '&', '=', '#', or NaN\\n      // (end of string).\\n      var followingChar = uri.charCodeAt(index + keyLength);\\n      if (!followingChar || followingChar == goog.uri.utils.CharCode_.EQUAL ||\\n          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||\\n          followingChar == goog.uri.utils.CharCode_.HASH) {\\n        return index;\\n      }\\n    }\\n    index += keyLength + 1;\\n  }\\n\\n  return -1;\\n};\\n\\n\\n/**\\n * Regular expression for finding a hash mark or end of string.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.uri.utils.hashOrEndRe_ = /#|$/;\\n\\n\\n/**\\n * Determines if the URI contains a specific key.\\n *\\n * Performs no object instantiations.\\n *\\n * @param {string} uri The URI to process.  May contain a fragment\\n *     identifier.\\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\\n * @return {boolean} Whether the key is present.\\n */\\ngoog.uri.utils.hasParam = function(uri, keyEncoded) {\\n  'use strict';\\n  return goog.uri.utils.findParam_(\\n             uri, 0, keyEncoded, uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;\\n};\\n\\n\\n/**\\n * Gets the first value of a query parameter.\\n * @param {string} uri The URI to process.  May contain a fragment.\\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\\n * @return {?string} The first value of the parameter (URI-decoded), or null\\n *     if the parameter is not found.\\n */\\ngoog.uri.utils.getParamValue = function(uri, keyEncoded) {\\n  'use strict';\\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\\n  var foundIndex =\\n      goog.uri.utils.findParam_(uri, 0, keyEncoded, hashOrEndIndex);\\n\\n  if (foundIndex < 0) {\\n    return null;\\n  } else {\\n    var endPosition = uri.indexOf('&', foundIndex);\\n    if (endPosition < 0 || endPosition > hashOrEndIndex) {\\n      endPosition = hashOrEndIndex;\\n    }\\n    // Progress forth to the end of the \\\"key=\\\" or \\\"key&\\\" substring.\\n    foundIndex += keyEncoded.length + 1;\\n    // Use substr, because it (unlike substring) will return empty string\\n    // if foundIndex > endPosition.\\n    return goog.string.urlDecode(\\n        uri.substr(foundIndex, endPosition - foundIndex));\\n  }\\n};\\n\\n\\n/**\\n * Gets all values of a query parameter.\\n * @param {string} uri The URI to process.  May contain a fragment.\\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\\n * @return {!Array<string>} All URI-decoded values with the given key.\\n *     If the key is not found, this will have length 0, but never be null.\\n */\\ngoog.uri.utils.getParamValues = function(uri, keyEncoded) {\\n  'use strict';\\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\\n  var position = 0;\\n  var foundIndex;\\n  var result = [];\\n\\n  while ((foundIndex = goog.uri.utils.findParam_(\\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\\n    // Find where this parameter ends, either the '&' or the end of the\\n    // query parameters.\\n    position = uri.indexOf('&', foundIndex);\\n    if (position < 0 || position > hashOrEndIndex) {\\n      position = hashOrEndIndex;\\n    }\\n\\n    // Progress forth to the end of the \\\"key=\\\" or \\\"key&\\\" substring.\\n    foundIndex += keyEncoded.length + 1;\\n    // Use substr, because it (unlike substring) will return empty string\\n    // if foundIndex > position.\\n    result.push(\\n        goog.string.urlDecode(uri.substr(foundIndex, position - foundIndex)));\\n  }\\n\\n  return result;\\n};\\n\\n\\n/**\\n * Regexp to find trailing question marks and ampersands.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;\\n\\n\\n/**\\n * Removes all instances of a query parameter.\\n * @param {string} uri The URI to process.  Must not contain a fragment.\\n * @param {string} keyEncoded The URI-encoded key.\\n * @return {string} The URI with all instances of the parameter removed.\\n */\\ngoog.uri.utils.removeParam = function(uri, keyEncoded) {\\n  'use strict';\\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\\n  var position = 0;\\n  var foundIndex;\\n  var buffer = [];\\n\\n  // Look for a query parameter.\\n  while ((foundIndex = goog.uri.utils.findParam_(\\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\\n    // Get the portion of the query string up to, but not including, the ?\\n    // or & starting the parameter.\\n    buffer.push(uri.substring(position, foundIndex));\\n    // Progress to immediately after the '&'.  If not found, go to the end.\\n    // Avoid including the hash mark.\\n    position = Math.min(\\n        (uri.indexOf('&', foundIndex) + 1) || hashOrEndIndex, hashOrEndIndex);\\n  }\\n\\n  // Append everything that is remaining.\\n  buffer.push(uri.substr(position));\\n\\n  // Join the buffer, and remove trailing punctuation that remains.\\n  return buffer.join('').replace(\\n      goog.uri.utils.trailingQueryPunctuationRe_, '$1');\\n};\\n\\n\\n/**\\n * Replaces all existing definitions of a parameter with a single definition.\\n *\\n * Repeated calls to this can exhibit quadratic behavior due to the need to\\n * find existing instances and reconstruct the string, though it should be\\n * limited given the 2kb limit.  Consider using appendParams or setParamsFromMap\\n * to update multiple parameters in bulk.\\n *\\n * @param {string} uri The original URI, which may already have query data.\\n * @param {string} keyEncoded The key, which must already be URI encoded.\\n * @param {*} value The value, which will be stringized and encoded (assumed\\n *     not already to be encoded).\\n * @return {string} The URI with the query parameter added.\\n */\\ngoog.uri.utils.setParam = function(uri, keyEncoded, value) {\\n  'use strict';\\n  return goog.uri.utils.appendParam(\\n      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);\\n};\\n\\n\\n/**\\n * Effeciently set or remove multiple query parameters in a URI. Order of\\n * unchanged parameters will not be modified, all updated parameters will be\\n * appended to the end of the query. Params with values of null or undefined are\\n * removed.\\n *\\n * @param {string} uri The URI to process.\\n * @param {!Object<string, goog.uri.utils.QueryValue>} params A list of\\n *     parameters to update. If null or undefined, the param will be removed.\\n * @return {string} An updated URI where the query data has been updated with\\n *     the params.\\n */\\ngoog.uri.utils.setParamsFromMap = function(uri, params) {\\n  'use strict';\\n  var parts = goog.uri.utils.splitQueryData_(uri);\\n  var queryData = parts[1];\\n  var buffer = [];\\n  if (queryData) {\\n    queryData.split('&').forEach(function(pair) {\\n      'use strict';\\n      var indexOfEquals = pair.indexOf('=');\\n      var name = indexOfEquals >= 0 ? pair.substr(0, indexOfEquals) : pair;\\n      if (!params.hasOwnProperty(name)) {\\n        buffer.push(pair);\\n      }\\n    });\\n  }\\n  parts[1] = goog.uri.utils.appendQueryData_(\\n      buffer.join('&'), goog.uri.utils.buildQueryDataFromMap(params));\\n  return goog.uri.utils.joinQueryData_(parts);\\n};\\n\\n\\n/**\\n * Generates a URI path using a given URI and a path with checks to\\n * prevent consecutive \\\"//\\\". The baseUri passed in must not contain\\n * query or fragment identifiers. The path to append may not contain query or\\n * fragment identifiers.\\n *\\n * @param {string} baseUri URI to use as the base.\\n * @param {string} path Path to append.\\n * @return {string} Updated URI.\\n */\\ngoog.uri.utils.appendPath = function(baseUri, path) {\\n  'use strict';\\n  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);\\n\\n  // Remove any trailing '/'\\n  if (goog.string.endsWith(baseUri, '/')) {\\n    baseUri = baseUri.substr(0, baseUri.length - 1);\\n  }\\n  // Remove any leading '/'\\n  if (goog.string.startsWith(path, '/')) {\\n    path = path.substr(1);\\n  }\\n  return '' + baseUri + '/' + path;\\n};\\n\\n\\n/**\\n * Replaces the path.\\n * @param {string} uri URI to use as the base.\\n * @param {string} path New path.\\n * @return {string} Updated URI.\\n */\\ngoog.uri.utils.setPath = function(uri, path) {\\n  'use strict';\\n  // Add any missing '/'.\\n  if (!goog.string.startsWith(path, '/')) {\\n    path = '/' + path;\\n  }\\n  var parts = goog.uri.utils.split(uri);\\n  return goog.uri.utils.buildFromEncodedParts(\\n      parts[goog.uri.utils.ComponentIndex.SCHEME],\\n      parts[goog.uri.utils.ComponentIndex.USER_INFO],\\n      parts[goog.uri.utils.ComponentIndex.DOMAIN],\\n      parts[goog.uri.utils.ComponentIndex.PORT], path,\\n      parts[goog.uri.utils.ComponentIndex.QUERY_DATA],\\n      parts[goog.uri.utils.ComponentIndex.FRAGMENT]);\\n};\\n\\n\\n/**\\n * Standard supported query parameters.\\n * @enum {string}\\n */\\ngoog.uri.utils.StandardQueryParam = {\\n\\n  /** Unused parameter for unique-ifying. */\\n  RANDOM: 'zx'\\n};\\n\\n\\n/**\\n * Sets the zx parameter of a URI to a random value.\\n * @param {string} uri Any URI.\\n * @return {string} That URI with the \\\"zx\\\" parameter added or replaced to\\n *     contain a random string.\\n */\\ngoog.uri.utils.makeUnique = function(uri) {\\n  'use strict';\\n  return goog.uri.utils.setParam(\\n      uri, goog.uri.utils.StandardQueryParam.RANDOM,\\n      goog.string.getRandomString());\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"uri\",\"utils\",\"CharCode_\",\"AMPERSAND\",\"EQUAL\",\"HASH\",\"QUESTION\",\"buildFromEncodedParts\",\"goog.uri.utils.buildFromEncodedParts\",\"opt_scheme\",\"opt_userInfo\",\"opt_domain\",\"opt_port\",\"opt_path\",\"opt_queryData\",\"opt_fragment\",\"out\",\"splitRe_\",\"RegExp\",\"ComponentIndex\",\"SCHEME\",\"USER_INFO\",\"DOMAIN\",\"PORT\",\"PATH\",\"QUERY_DATA\",\"FRAGMENT\",\"urlPackageSupportLoggingHandler_\",\"setUrlPackageSupportLoggingHandler\",\"goog.uri.utils.setUrlPackageSupportLoggingHandler\",\"handler\",\"split\",\"goog.uri.utils.split\",\"result\",\"match\",\"indexOf\",\"decodeIfPossible_\",\"goog.uri.utils.decodeIfPossible_\",\"opt_preserveReserved\",\"decodeURI\",\"decodeURIComponent\",\"getComponentByIndex_\",\"goog.uri.utils.getComponentByIndex_\",\"componentIndex\",\"getScheme\",\"goog.uri.utils.getScheme\",\"getEffectiveScheme\",\"goog.uri.utils.getEffectiveScheme\",\"scheme\",\"global\",\"self\",\"location\",\"protocol\",\"substr\",\"length\",\"toLowerCase\",\"getUserInfoEncoded\",\"goog.uri.utils.getUserInfoEncoded\",\"getUserInfo\",\"goog.uri.utils.getUserInfo\",\"getDomainEncoded\",\"goog.uri.utils.getDomainEncoded\",\"getDomain\",\"goog.uri.utils.getDomain\",\"getPort\",\"goog.uri.utils.getPort\",\"Number\",\"getPathEncoded\",\"goog.uri.utils.getPathEncoded\",\"getPath\",\"goog.uri.utils.getPath\",\"getQueryData\",\"goog.uri.utils.getQueryData\",\"getFragmentEncoded\",\"goog.uri.utils.getFragmentEncoded\",\"hashIndex\",\"setFragmentEncoded\",\"goog.uri.utils.setFragmentEncoded\",\"fragment\",\"removeFragment\",\"getFragment\",\"goog.uri.utils.getFragment\",\"getHost\",\"goog.uri.utils.getHost\",\"pieces\",\"getOrigin\",\"goog.uri.utils.getOrigin\",\"getPathAndAfter\",\"goog.uri.utils.getPathAndAfter\",\"goog.uri.utils.removeFragment\",\"haveSameDomain\",\"goog.uri.utils.haveSameDomain\",\"uri1\",\"uri2\",\"pieces1\",\"pieces2\",\"assertNoFragmentsOrQueries_\",\"goog.uri.utils.assertNoFragmentsOrQueries_\",\"asserts\",\"assert\",\"QueryValue\",\"QueryArray\",\"parseQueryData\",\"goog.uri.utils.parseQueryData\",\"encodedQuery\",\"callback\",\"pairs\",\"i\",\"indexOfEquals\",\"name\",\"value\",\"substring\",\"string\",\"urlDecode\",\"splitQueryData_\",\"goog.uri.utils.splitQueryData_\",\"questionIndex\",\"queryData\",\"joinQueryData_\",\"goog.uri.utils.joinQueryData_\",\"parts\",\"appendQueryData_\",\"goog.uri.utils.appendQueryData_\",\"newData\",\"appendQueryDataToUri_\",\"goog.uri.utils.appendQueryDataToUri_\",\"appendKeyValuePairs_\",\"goog.uri.utils.appendKeyValuePairs_\",\"key\",\"assertString\",\"Array\",\"isArray\",\"assertArray\",\"j\",\"String\",\"push\",\"urlEncode\",\"buildQueryData\",\"goog.uri.utils.buildQueryData\",\"keysAndValues\",\"opt_startIndex\",\"Math\",\"max\",\"params\",\"join\",\"buildQueryDataFromMap\",\"goog.uri.utils.buildQueryDataFromMap\",\"map\",\"appendParams\",\"goog.uri.utils.appendParams\",\"var_args\",\"arguments\",\"appendParamsFromMap\",\"goog.uri.utils.appendParamsFromMap\",\"appendParam\",\"goog.uri.utils.appendParam\",\"opt_value\",\"findParam_\",\"goog.uri.utils.findParam_\",\"startIndex\",\"keyEncoded\",\"hashOrEndIndex\",\"index\",\"keyLength\",\"precedingChar\",\"charCodeAt\",\"followingChar\",\"hashOrEndRe_\",\"hasParam\",\"goog.uri.utils.hasParam\",\"search\",\"getParamValue\",\"goog.uri.utils.getParamValue\",\"foundIndex\",\"endPosition\",\"getParamValues\",\"goog.uri.utils.getParamValues\",\"position\",\"trailingQueryPunctuationRe_\",\"removeParam\",\"goog.uri.utils.removeParam\",\"buffer\",\"min\",\"replace\",\"setParam\",\"goog.uri.utils.setParam\",\"setParamsFromMap\",\"goog.uri.utils.setParamsFromMap\",\"forEach\",\"pair\",\"hasOwnProperty\",\"appendPath\",\"goog.uri.utils.appendPath\",\"baseUri\",\"path\",\"endsWith\",\"startsWith\",\"setPath\",\"goog.uri.utils.setPath\",\"StandardQueryParam\",\"RANDOM\",\"makeUnique\",\"goog.uri.utils.makeUnique\",\"getRandomString\"]\n}\n"]