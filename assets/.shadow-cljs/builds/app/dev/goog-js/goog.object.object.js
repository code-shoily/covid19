["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/object/object.js"],"~:js","goog.provide(\"goog.object\");\ngoog.object.forEach = function(obj, f, opt_obj) {\n  for (const key in obj) {\n    f.call(opt_obj, obj[key], key, obj);\n  }\n};\ngoog.object.filter = function(obj, f, opt_obj) {\n  const res = {};\n  for (const key in obj) {\n    if (f.call(opt_obj, obj[key], key, obj)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n};\ngoog.object.map = function(obj, f, opt_obj) {\n  const res = {};\n  for (const key in obj) {\n    res[key] = f.call(opt_obj, obj[key], key, obj);\n  }\n  return res;\n};\ngoog.object.some = function(obj, f, opt_obj) {\n  for (const key in obj) {\n    if (f.call(opt_obj, obj[key], key, obj)) {\n      return true;\n    }\n  }\n  return false;\n};\ngoog.object.every = function(obj, f, opt_obj) {\n  for (const key in obj) {\n    if (!f.call(opt_obj, obj[key], key, obj)) {\n      return false;\n    }\n  }\n  return true;\n};\ngoog.object.getCount = function(obj) {\n  let rv = 0;\n  for (const key in obj) {\n    rv++;\n  }\n  return rv;\n};\ngoog.object.getAnyKey = function(obj) {\n  for (const key in obj) {\n    return key;\n  }\n};\ngoog.object.getAnyValue = function(obj) {\n  for (const key in obj) {\n    return obj[key];\n  }\n};\ngoog.object.contains = function(obj, val) {\n  return goog.object.containsValue(obj, val);\n};\ngoog.object.getValues = function(obj) {\n  const res = [];\n  let i = 0;\n  for (const key in obj) {\n    res[i++] = obj[key];\n  }\n  return res;\n};\ngoog.object.getKeys = function(obj) {\n  const res = [];\n  let i = 0;\n  for (const key in obj) {\n    res[i++] = key;\n  }\n  return res;\n};\ngoog.object.getValueByKeys = function(obj, var_args) {\n  const isArrayLike = goog.isArrayLike(var_args);\n  const keys = isArrayLike ? var_args : arguments;\n  for (let i = isArrayLike ? 0 : 1; i < keys.length; i++) {\n    if (obj == null) {\n      return undefined;\n    }\n    obj = obj[keys[i]];\n  }\n  return obj;\n};\ngoog.object.containsKey = function(obj, key) {\n  return obj !== null && key in obj;\n};\ngoog.object.containsValue = function(obj, val) {\n  for (const key in obj) {\n    if (obj[key] == val) {\n      return true;\n    }\n  }\n  return false;\n};\ngoog.object.findKey = function(obj, f, opt_this) {\n  for (const key in obj) {\n    if (f.call(opt_this, obj[key], key, obj)) {\n      return key;\n    }\n  }\n  return undefined;\n};\ngoog.object.findValue = function(obj, f, opt_this) {\n  const key = goog.object.findKey(obj, f, opt_this);\n  return key && obj[key];\n};\ngoog.object.isEmpty = function(obj) {\n  for (const key in obj) {\n    return false;\n  }\n  return true;\n};\ngoog.object.clear = function(obj) {\n  for (const i in obj) {\n    delete obj[i];\n  }\n};\ngoog.object.remove = function(obj, key) {\n  let rv;\n  if (rv = key in obj) {\n    delete obj[key];\n  }\n  return rv;\n};\ngoog.object.add = function(obj, key, val) {\n  if (obj !== null && key in obj) {\n    throw new Error('The object already contains the key \"' + key + '\"');\n  }\n  goog.object.set(obj, key, val);\n};\ngoog.object.get = function(obj, key, opt_val) {\n  if (obj !== null && key in obj) {\n    return obj[key];\n  }\n  return opt_val;\n};\ngoog.object.set = function(obj, key, value) {\n  obj[key] = value;\n};\ngoog.object.setIfUndefined = function(obj, key, value) {\n  return key in obj ? obj[key] : obj[key] = value;\n};\ngoog.object.setWithReturnValueIfNotSet = function(obj, key, f) {\n  if (key in obj) {\n    return obj[key];\n  }\n  const val = f();\n  obj[key] = val;\n  return val;\n};\ngoog.object.equals = function(a, b) {\n  for (const k in a) {\n    if (!(k in b) || a[k] !== b[k]) {\n      return false;\n    }\n  }\n  for (const k in b) {\n    if (!(k in a)) {\n      return false;\n    }\n  }\n  return true;\n};\ngoog.object.clone = function(obj) {\n  const res = {};\n  for (const key in obj) {\n    res[key] = obj[key];\n  }\n  return res;\n};\ngoog.object.unsafeClone = function(obj) {\n  if (!obj || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (typeof obj.clone === \"function\") {\n    return obj.clone();\n  }\n  const clone = Array.isArray(obj) ? [] : typeof ArrayBuffer === \"function\" && typeof ArrayBuffer.isView === \"function\" && ArrayBuffer.isView(obj) && !(obj instanceof DataView) ? new obj.constructor(obj.length) : {};\n  for (const key in obj) {\n    clone[key] = goog.object.unsafeClone(obj[key]);\n  }\n  return clone;\n};\ngoog.object.transpose = function(obj) {\n  const transposed = {};\n  for (const key in obj) {\n    transposed[obj[key]] = key;\n  }\n  return transposed;\n};\ngoog.object.PROTOTYPE_FIELDS_ = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"];\ngoog.object.extend = function(target, var_args) {\n  let key;\n  let source;\n  for (let i = 1; i < arguments.length; i++) {\n    source = arguments[i];\n    for (key in source) {\n      target[key] = source[key];\n    }\n    for (let j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {\n      key = goog.object.PROTOTYPE_FIELDS_[j];\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n};\ngoog.object.create = function(var_args) {\n  const argLength = arguments.length;\n  if (argLength == 1 && Array.isArray(arguments[0])) {\n    return goog.object.create.apply(null, arguments[0]);\n  }\n  if (argLength % 2) {\n    throw new Error(\"Uneven number of arguments\");\n  }\n  const rv = {};\n  for (let i = 0; i < argLength; i += 2) {\n    rv[arguments[i]] = arguments[i + 1];\n  }\n  return rv;\n};\ngoog.object.createSet = function(var_args) {\n  const argLength = arguments.length;\n  if (argLength == 1 && Array.isArray(arguments[0])) {\n    return goog.object.createSet.apply(null, arguments[0]);\n  }\n  const rv = {};\n  for (let i = 0; i < argLength; i++) {\n    rv[arguments[i]] = true;\n  }\n  return rv;\n};\ngoog.object.createImmutableView = function(obj) {\n  let result = obj;\n  if (Object.isFrozen && !Object.isFrozen(obj)) {\n    result = Object.create(obj);\n    Object.freeze(result);\n  }\n  return result;\n};\ngoog.object.isImmutableView = function(obj) {\n  return !!Object.isFrozen && Object.isFrozen(obj);\n};\ngoog.object.getAllPropertyNames = function(obj, opt_includeObjectPrototype, opt_includeFunctionPrototype) {\n  if (!obj) {\n    return [];\n  }\n  if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n    return goog.object.getKeys(obj);\n  }\n  const visitedSet = {};\n  let proto = obj;\n  while (proto && (proto !== Object.prototype || !!opt_includeObjectPrototype) && (proto !== Function.prototype || !!opt_includeFunctionPrototype)) {\n    const names = Object.getOwnPropertyNames(proto);\n    for (let i = 0; i < names.length; i++) {\n      visitedSet[names[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return goog.object.getKeys(visitedSet);\n};\ngoog.object.getSuperClass = function(constructor) {\n  var proto = Object.getPrototypeOf(constructor.prototype);\n  return proto && proto.constructor;\n};\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utilities for manipulating objects/maps/hashes.\n */\n\ngoog.provide('goog.object');\n\n\n/**\n * Calls a function for each element in an object/map/hash.\n *\n * @param {Object<K,V>} obj The object over which to iterate.\n * @param {function(this:T,V,?,Object<K,V>):?} f The function to call\n *     for every element. This function takes 3 arguments (the value, the\n *     key and the object) and the return value is ignored.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @template T,K,V\n */\ngoog.object.forEach = function(obj, f, opt_obj) {\n  'use strict';\n  for (const key in obj) {\n    f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);\n  }\n};\n\n\n/**\n * Calls a function for each element in an object/map/hash. If that call returns\n * true, adds the element to a new object.\n *\n * @param {Object<K,V>} obj The object over which to iterate.\n * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to call\n *     for every element. This\n *     function takes 3 arguments (the value, the key and the object)\n *     and should return a boolean. If the return value is true the\n *     element is added to the result object. If it is false the\n *     element is not included.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @return {!Object<K,V>} a new object in which only elements that passed the\n *     test are present.\n * @template T,K,V\n */\ngoog.object.filter = function(obj, f, opt_obj) {\n  'use strict';\n  const res = {};\n  for (const key in obj) {\n    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n};\n\n\n/**\n * For every element in an object/map/hash calls a function and inserts the\n * result into a new object.\n *\n * @param {Object<K,V>} obj The object over which to iterate.\n * @param {function(this:T,V,?,Object<K,V>):R} f The function to call\n *     for every element. This function\n *     takes 3 arguments (the value, the key and the object)\n *     and should return something. The result will be inserted\n *     into a new object.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @return {!Object<K,R>} a new object with the results from f.\n * @template T,K,V,R\n */\ngoog.object.map = function(obj, f, opt_obj) {\n  'use strict';\n  const res = {};\n  for (const key in obj) {\n    res[key] = f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);\n  }\n  return res;\n};\n\n\n/**\n * Calls a function for each element in an object/map/hash. If any\n * call returns true, returns true (without checking the rest). If\n * all calls return false, returns false.\n *\n * @param {Object<K,V>} obj The object to check.\n * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to\n *     call for every element. This function\n *     takes 3 arguments (the value, the key and the object) and should\n *     return a boolean.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @return {boolean} true if any element passes the test.\n * @template T,K,V\n */\ngoog.object.some = function(obj, f, opt_obj) {\n  'use strict';\n  for (const key in obj) {\n    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Calls a function for each element in an object/map/hash. If\n * all calls return true, returns true. If any call returns false, returns\n * false at this point and does not continue to check the remaining elements.\n *\n * @param {Object<K,V>} obj The object to check.\n * @param {?function(this:T,V,?,Object<K,V>):boolean} f The function to\n *     call for every element. This function\n *     takes 3 arguments (the value, the key and the object) and should\n *     return a boolean.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @return {boolean} false if any element fails the test.\n * @template T,K,V\n */\ngoog.object.every = function(obj, f, opt_obj) {\n  'use strict';\n  for (const key in obj) {\n    if (!f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Returns the number of key-value pairs in the object map.\n *\n * @param {Object} obj The object for which to get the number of key-value\n *     pairs.\n * @return {number} The number of key-value pairs in the object map.\n */\ngoog.object.getCount = function(obj) {\n  'use strict';\n  let rv = 0;\n  for (const key in obj) {\n    rv++;\n  }\n  return rv;\n};\n\n\n/**\n * Returns one key from the object map, if any exists.\n * For map literals the returned key will be the first one in most of the\n * browsers (a know exception is Konqueror).\n *\n * @param {Object} obj The object to pick a key from.\n * @return {string|undefined} The key or undefined if the object is empty.\n */\ngoog.object.getAnyKey = function(obj) {\n  'use strict';\n  for (const key in obj) {\n    return key;\n  }\n};\n\n\n/**\n * Returns one value from the object map, if any exists.\n * For map literals the returned value will be the first one in most of the\n * browsers (a know exception is Konqueror).\n *\n * @param {Object<K,V>} obj The object to pick a value from.\n * @return {V|undefined} The value or undefined if the object is empty.\n * @template K,V\n */\ngoog.object.getAnyValue = function(obj) {\n  'use strict';\n  for (const key in obj) {\n    return obj[key];\n  }\n};\n\n\n/**\n * Whether the object/hash/map contains the given object as a value.\n * An alias for goog.object.containsValue(obj, val).\n *\n * @param {Object<K,V>} obj The object in which to look for val.\n * @param {V} val The object for which to check.\n * @return {boolean} true if val is present.\n * @template K,V\n */\ngoog.object.contains = function(obj, val) {\n  'use strict';\n  return goog.object.containsValue(obj, val);\n};\n\n\n/**\n * Returns the values of the object/map/hash.\n *\n * @param {Object<K,V>} obj The object from which to get the values.\n * @return {!Array<V>} The values in the object/map/hash.\n * @template K,V\n */\ngoog.object.getValues = function(obj) {\n  'use strict';\n  const res = [];\n  let i = 0;\n  for (const key in obj) {\n    res[i++] = obj[key];\n  }\n  return res;\n};\n\n\n/**\n * Returns the keys of the object/map/hash.\n *\n * @param {Object} obj The object from which to get the keys.\n * @return {!Array<string>} Array of property keys.\n */\ngoog.object.getKeys = function(obj) {\n  'use strict';\n  const res = [];\n  let i = 0;\n  for (const key in obj) {\n    res[i++] = key;\n  }\n  return res;\n};\n\n\n/**\n * Get a value from an object multiple levels deep.  This is useful for\n * pulling values from deeply nested objects, such as JSON responses.\n * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)\n *\n * @param {!Object} obj An object to get the value from.  Can be array-like.\n * @param {...(string|number|!IArrayLike<number|string>)}\n *     var_args A number of keys\n *     (as strings, or numbers, for array-like objects).  Can also be\n *     specified as a single array of keys.\n * @return {*} The resulting value.  If, at any point, the value for a key\n *     in the current object is null or undefined, returns undefined.\n */\ngoog.object.getValueByKeys = function(obj, var_args) {\n  'use strict';\n  const isArrayLike = goog.isArrayLike(var_args);\n  const keys = isArrayLike ?\n      /** @type {!IArrayLike<number|string>} */ (var_args) :\n      arguments;\n\n  // Start with the 2nd parameter for the variable parameters syntax.\n  for (let i = isArrayLike ? 0 : 1; i < keys.length; i++) {\n    if (obj == null) return undefined;\n    obj = obj[keys[i]];\n  }\n\n  return obj;\n};\n\n\n/**\n * Whether the object/map/hash contains the given key.\n *\n * @param {Object} obj The object in which to look for key.\n * @param {?} key The key for which to check.\n * @return {boolean} true If the map contains the key.\n */\ngoog.object.containsKey = function(obj, key) {\n  'use strict';\n  return obj !== null && key in obj;\n};\n\n\n/**\n * Whether the object/map/hash contains the given value. This is O(n).\n *\n * @param {Object<K,V>} obj The object in which to look for val.\n * @param {V} val The value for which to check.\n * @return {boolean} true If the map contains the value.\n * @template K,V\n */\ngoog.object.containsValue = function(obj, val) {\n  'use strict';\n  for (const key in obj) {\n    if (obj[key] == val) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Searches an object for an element that satisfies the given condition and\n * returns its key.\n * @param {Object<K,V>} obj The object to search in.\n * @param {function(this:T,V,string,Object<K,V>):boolean} f The\n *      function to call for every element. Takes 3 arguments (the value,\n *     the key and the object) and should return a boolean.\n * @param {T=} opt_this An optional \"this\" context for the function.\n * @return {string|undefined} The key of an element for which the function\n *     returns true or undefined if no such element is found.\n * @template T,K,V\n */\ngoog.object.findKey = function(obj, f, opt_this) {\n  'use strict';\n  for (const key in obj) {\n    if (f.call(/** @type {?} */ (opt_this), obj[key], key, obj)) {\n      return key;\n    }\n  }\n  return undefined;\n};\n\n\n/**\n * Searches an object for an element that satisfies the given condition and\n * returns its value.\n * @param {Object<K,V>} obj The object to search in.\n * @param {function(this:T,V,string,Object<K,V>):boolean} f The function\n *     to call for every element. Takes 3 arguments (the value, the key\n *     and the object) and should return a boolean.\n * @param {T=} opt_this An optional \"this\" context for the function.\n * @return {V} The value of an element for which the function returns true or\n *     undefined if no such element is found.\n * @template T,K,V\n */\ngoog.object.findValue = function(obj, f, opt_this) {\n  'use strict';\n  const key = goog.object.findKey(obj, f, opt_this);\n  return key && obj[key];\n};\n\n\n/**\n * Whether the object/map/hash is empty.\n *\n * @param {Object} obj The object to test.\n * @return {boolean} true if obj is empty.\n */\ngoog.object.isEmpty = function(obj) {\n  'use strict';\n  for (const key in obj) {\n    return false;\n  }\n  return true;\n};\n\n\n/**\n * Removes all key value pairs from the object/map/hash.\n *\n * @param {Object} obj The object to clear.\n */\ngoog.object.clear = function(obj) {\n  'use strict';\n  for (const i in obj) {\n    delete obj[i];\n  }\n};\n\n\n/**\n * Removes a key-value pair based on the key.\n *\n * @param {Object} obj The object from which to remove the key.\n * @param {?} key The key to remove.\n * @return {boolean} Whether an element was removed.\n */\ngoog.object.remove = function(obj, key) {\n  'use strict';\n  let rv;\n  if (rv = key in /** @type {!Object} */ (obj)) {\n    delete obj[key];\n  }\n  return rv;\n};\n\n\n/**\n * Adds a key-value pair to the object. Throws an exception if the key is\n * already in use. Use set if you want to change an existing pair.\n *\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\n * @param {string} key The key to add.\n * @param {V} val The value to add.\n * @template K,V\n */\ngoog.object.add = function(obj, key, val) {\n  'use strict';\n  if (obj !== null && key in obj) {\n    throw new Error('The object already contains the key \"' + key + '\"');\n  }\n  goog.object.set(obj, key, val);\n};\n\n\n/**\n * Returns the value for the given key.\n *\n * @param {Object<K,V>} obj The object from which to get the value.\n * @param {string} key The key for which to get the value.\n * @param {R=} opt_val The value to return if no item is found for the given\n *     key (default is undefined).\n * @return {V|R|undefined} The value for the given key.\n * @template K,V,R\n */\ngoog.object.get = function(obj, key, opt_val) {\n  'use strict';\n  if (obj !== null && key in obj) {\n    return obj[key];\n  }\n  return opt_val;\n};\n\n\n/**\n * Adds a key-value pair to the object/map/hash.\n *\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\n * @param {string} key The key to add.\n * @param {V} value The value to add.\n * @template K,V\n */\ngoog.object.set = function(obj, key, value) {\n  'use strict';\n  obj[key] = value;\n};\n\n\n/**\n * Adds a key-value pair to the object/map/hash if it doesn't exist yet.\n *\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\n * @param {string} key The key to add.\n * @param {V} value The value to add if the key wasn't present.\n * @return {V} The value of the entry at the end of the function.\n * @template K,V\n */\ngoog.object.setIfUndefined = function(obj, key, value) {\n  'use strict';\n  return key in /** @type {!Object} */ (obj) ? obj[key] : (obj[key] = value);\n};\n\n\n/**\n * Sets a key and value to an object if the key is not set. The value will be\n * the return value of the given function. If the key already exists, the\n * object will not be changed and the function will not be called (the function\n * will be lazily evaluated -- only called if necessary).\n *\n * This function is particularly useful when used with an `Object` which is\n * acting as a cache.\n *\n * @param {!Object<K,V>} obj The object to which to add the key-value pair.\n * @param {string} key The key to add.\n * @param {function():V} f The value to add if the key wasn't present.\n * @return {V} The value of the entry at the end of the function.\n * @template K,V\n */\ngoog.object.setWithReturnValueIfNotSet = function(obj, key, f) {\n  'use strict';\n  if (key in obj) {\n    return obj[key];\n  }\n\n  const val = f();\n  obj[key] = val;\n  return val;\n};\n\n\n/**\n * Compares two objects for equality using === on the values.\n *\n * @param {!Object<K,V>} a\n * @param {!Object<K,V>} b\n * @return {boolean}\n * @template K,V\n */\ngoog.object.equals = function(a, b) {\n  'use strict';\n  for (const k in a) {\n    if (!(k in b) || a[k] !== b[k]) {\n      return false;\n    }\n  }\n  for (const k in b) {\n    if (!(k in a)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Returns a shallow clone of the object.\n *\n * @param {Object<K,V>} obj Object to clone.\n * @return {!Object<K,V>} Clone of the input object.\n * @template K,V\n */\ngoog.object.clone = function(obj) {\n  'use strict';\n  const res = {};\n  for (const key in obj) {\n    res[key] = obj[key];\n  }\n  return res;\n};\n\n\n/**\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\n * arrays will be cloned recursively.\n *\n * WARNINGS:\n * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects\n * that refer to themselves will cause infinite recursion.\n *\n * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and\n * copies UIDs created by <code>getUid</code> into cloned results.\n *\n * @param {T} obj The value to clone.\n * @return {T} A clone of the input value.\n * @template T\n */\ngoog.object.unsafeClone = function(obj) {\n  'use strict';\n  if (!obj || typeof obj !== 'object') return obj;\n  if (typeof obj.clone === 'function') return obj.clone();\n  const clone = Array.isArray(obj) ? [] :\n      typeof ArrayBuffer === 'function' &&\n          typeof ArrayBuffer.isView === 'function' && ArrayBuffer.isView(obj) &&\n          !(obj instanceof DataView) ?\n                                     new obj.constructor(obj.length) :\n                                     {};\n  for (const key in obj) {\n    clone[key] = goog.object.unsafeClone(obj[key]);\n  }\n  return clone;\n};\n\n\n/**\n * Returns a new object in which all the keys and values are interchanged\n * (keys become values and values become keys). If multiple keys map to the\n * same value, the chosen transposed value is implementation-dependent.\n *\n * @param {Object} obj The object to transpose.\n * @return {!Object} The transposed object.\n */\ngoog.object.transpose = function(obj) {\n  'use strict';\n  const transposed = {};\n  for (const key in obj) {\n    transposed[obj[key]] = key;\n  }\n  return transposed;\n};\n\n\n/**\n * The names of the fields that are defined on Object.prototype.\n * @type {Array<string>}\n * @private\n */\ngoog.object.PROTOTYPE_FIELDS_ = [\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\n  'toLocaleString', 'toString', 'valueOf'\n];\n\n\n/**\n * Extends an object with another object.\n * This operates 'in-place'; it does not create a new Object.\n *\n * Example:\n * var o = {};\n * goog.object.extend(o, {a: 0, b: 1});\n * o; // {a: 0, b: 1}\n * goog.object.extend(o, {b: 2, c: 3});\n * o; // {a: 0, b: 2, c: 3}\n *\n * @param {Object} target The object to modify. Existing properties will be\n *     overwritten if they are also present in one of the objects in\n *     `var_args`.\n * @param {...(Object|null|undefined)} var_args The objects from which values\n *     will be copied.\n * @deprecated Prefer Object.assign\n */\ngoog.object.extend = function(target, var_args) {\n  'use strict';\n  let key;\n  let source;\n  for (let i = 1; i < arguments.length; i++) {\n    source = arguments[i];\n    for (key in source) {\n      target[key] = source[key];\n    }\n\n    // For IE the for-in-loop does not contain any properties that are not\n    // enumerable on the prototype object (for example isPrototypeOf from\n    // Object.prototype) and it will also not include 'replace' on objects that\n    // extend String and change 'replace' (not that it is common for anyone to\n    // extend anything except Object).\n\n    for (let j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {\n      key = goog.object.PROTOTYPE_FIELDS_[j];\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n};\n\n\n/**\n * Creates a new object built from the key-value pairs provided as arguments.\n * @param {...*} var_args If only one argument is provided and it is an array\n *     then this is used as the arguments, otherwise even arguments are used as\n *     the property names and odd arguments are used as the property values.\n * @return {!Object} The new object.\n * @throws {Error} If there are uneven number of arguments or there is only one\n *     non array argument.\n */\ngoog.object.create = function(var_args) {\n  'use strict';\n  const argLength = arguments.length;\n  if (argLength == 1 && Array.isArray(arguments[0])) {\n    return goog.object.create.apply(null, arguments[0]);\n  }\n\n  if (argLength % 2) {\n    throw new Error('Uneven number of arguments');\n  }\n\n  const rv = {};\n  for (let i = 0; i < argLength; i += 2) {\n    rv[arguments[i]] = arguments[i + 1];\n  }\n  return rv;\n};\n\n\n/**\n * Creates a new object where the property names come from the arguments but\n * the value is always set to true\n * @param {...*} var_args If only one argument is provided and it is an array\n *     then this is used as the arguments, otherwise the arguments are used\n *     as the property names.\n * @return {!Object} The new object.\n */\ngoog.object.createSet = function(var_args) {\n  'use strict';\n  const argLength = arguments.length;\n  if (argLength == 1 && Array.isArray(arguments[0])) {\n    return goog.object.createSet.apply(null, arguments[0]);\n  }\n\n  const rv = {};\n  for (let i = 0; i < argLength; i++) {\n    rv[arguments[i]] = true;\n  }\n  return rv;\n};\n\n\n/**\n * Creates an immutable view of the underlying object, if the browser\n * supports immutable objects.\n *\n * In default mode, writes to this view will fail silently. In strict mode,\n * they will throw an error.\n *\n * @param {!Object<K,V>} obj An object.\n * @return {!Object<K,V>} An immutable view of that object, or the\n *     original object if this browser does not support immutables.\n * @template K,V\n */\ngoog.object.createImmutableView = function(obj) {\n  'use strict';\n  let result = obj;\n  if (Object.isFrozen && !Object.isFrozen(obj)) {\n    result = Object.create(obj);\n    Object.freeze(result);\n  }\n  return result;\n};\n\n\n/**\n * @param {!Object} obj An object.\n * @return {boolean} Whether this is an immutable view of the object.\n */\ngoog.object.isImmutableView = function(obj) {\n  'use strict';\n  return !!Object.isFrozen && Object.isFrozen(obj);\n};\n\n\n/**\n * Get all properties names on a given Object regardless of enumerability.\n *\n * <p> If the browser does not support `Object.getOwnPropertyNames` nor\n * `Object.getPrototypeOf` then this is equivalent to using\n * `goog.object.getKeys`\n *\n * @param {?Object} obj The object to get the properties of.\n * @param {boolean=} opt_includeObjectPrototype Whether properties defined on\n *     `Object.prototype` should be included in the result.\n * @param {boolean=} opt_includeFunctionPrototype Whether properties defined on\n *     `Function.prototype` should be included in the result.\n * @return {!Array<string>}\n * @public\n */\ngoog.object.getAllPropertyNames = function(\n    obj, opt_includeObjectPrototype, opt_includeFunctionPrototype) {\n  'use strict';\n  if (!obj) {\n    return [];\n  }\n\n  // Naively use a for..in loop to get the property names if the browser doesn't\n  // support any other APIs for getting it.\n  if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n    return goog.object.getKeys(obj);\n  }\n\n  const visitedSet = {};\n\n  // Traverse the prototype chain and add all properties to the visited set.\n  let proto = obj;\n  while (proto &&\n         (proto !== Object.prototype || !!opt_includeObjectPrototype) &&\n         (proto !== Function.prototype || !!opt_includeFunctionPrototype)) {\n    const names = Object.getOwnPropertyNames(proto);\n    for (let i = 0; i < names.length; i++) {\n      visitedSet[names[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return goog.object.getKeys(visitedSet);\n};\n\n\n/**\n * Given a ES5 or ES6 class reference, return its super class / super\n * constructor.\n *\n * This should be used in rare cases where you need to walk up the inheritance\n * tree (this is generally a bad idea). But this work with ES5 and ES6 classes,\n * unlike relying on the superClass_ property.\n *\n * Note: To start walking up the hierarchy from an instance call this with its\n * `constructor` property; e.g. `getSuperClass(instance.constructor)`.\n *\n * @param {function(new: ?)} constructor\n * @return {?Object}\n */\ngoog.object.getSuperClass = function(constructor) {\n  'use strict';\n  var proto = Object.getPrototypeOf(constructor.prototype);\n  return proto && proto.constructor;\n};\n","~:compiled-at",1623605884858,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.object.object.js\",\n\"lineCount\":268,\n\"mappings\":\"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\",\n\"sources\":[\"goog/object/object.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n/**\\n * @fileoverview Utilities for manipulating objects/maps/hashes.\\n */\\n\\ngoog.provide('goog.object');\\n\\n\\n/**\\n * Calls a function for each element in an object/map/hash.\\n *\\n * @param {Object<K,V>} obj The object over which to iterate.\\n * @param {function(this:T,V,?,Object<K,V>):?} f The function to call\\n *     for every element. This function takes 3 arguments (the value, the\\n *     key and the object) and the return value is ignored.\\n * @param {T=} opt_obj This is used as the 'this' object within f.\\n * @template T,K,V\\n */\\ngoog.object.forEach = function(obj, f, opt_obj) {\\n  'use strict';\\n  for (const key in obj) {\\n    f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);\\n  }\\n};\\n\\n\\n/**\\n * Calls a function for each element in an object/map/hash. If that call returns\\n * true, adds the element to a new object.\\n *\\n * @param {Object<K,V>} obj The object over which to iterate.\\n * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to call\\n *     for every element. This\\n *     function takes 3 arguments (the value, the key and the object)\\n *     and should return a boolean. If the return value is true the\\n *     element is added to the result object. If it is false the\\n *     element is not included.\\n * @param {T=} opt_obj This is used as the 'this' object within f.\\n * @return {!Object<K,V>} a new object in which only elements that passed the\\n *     test are present.\\n * @template T,K,V\\n */\\ngoog.object.filter = function(obj, f, opt_obj) {\\n  'use strict';\\n  const res = {};\\n  for (const key in obj) {\\n    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\\n      res[key] = obj[key];\\n    }\\n  }\\n  return res;\\n};\\n\\n\\n/**\\n * For every element in an object/map/hash calls a function and inserts the\\n * result into a new object.\\n *\\n * @param {Object<K,V>} obj The object over which to iterate.\\n * @param {function(this:T,V,?,Object<K,V>):R} f The function to call\\n *     for every element. This function\\n *     takes 3 arguments (the value, the key and the object)\\n *     and should return something. The result will be inserted\\n *     into a new object.\\n * @param {T=} opt_obj This is used as the 'this' object within f.\\n * @return {!Object<K,R>} a new object with the results from f.\\n * @template T,K,V,R\\n */\\ngoog.object.map = function(obj, f, opt_obj) {\\n  'use strict';\\n  const res = {};\\n  for (const key in obj) {\\n    res[key] = f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);\\n  }\\n  return res;\\n};\\n\\n\\n/**\\n * Calls a function for each element in an object/map/hash. If any\\n * call returns true, returns true (without checking the rest). If\\n * all calls return false, returns false.\\n *\\n * @param {Object<K,V>} obj The object to check.\\n * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to\\n *     call for every element. This function\\n *     takes 3 arguments (the value, the key and the object) and should\\n *     return a boolean.\\n * @param {T=} opt_obj This is used as the 'this' object within f.\\n * @return {boolean} true if any element passes the test.\\n * @template T,K,V\\n */\\ngoog.object.some = function(obj, f, opt_obj) {\\n  'use strict';\\n  for (const key in obj) {\\n    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * Calls a function for each element in an object/map/hash. If\\n * all calls return true, returns true. If any call returns false, returns\\n * false at this point and does not continue to check the remaining elements.\\n *\\n * @param {Object<K,V>} obj The object to check.\\n * @param {?function(this:T,V,?,Object<K,V>):boolean} f The function to\\n *     call for every element. This function\\n *     takes 3 arguments (the value, the key and the object) and should\\n *     return a boolean.\\n * @param {T=} opt_obj This is used as the 'this' object within f.\\n * @return {boolean} false if any element fails the test.\\n * @template T,K,V\\n */\\ngoog.object.every = function(obj, f, opt_obj) {\\n  'use strict';\\n  for (const key in obj) {\\n    if (!f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n};\\n\\n\\n/**\\n * Returns the number of key-value pairs in the object map.\\n *\\n * @param {Object} obj The object for which to get the number of key-value\\n *     pairs.\\n * @return {number} The number of key-value pairs in the object map.\\n */\\ngoog.object.getCount = function(obj) {\\n  'use strict';\\n  let rv = 0;\\n  for (const key in obj) {\\n    rv++;\\n  }\\n  return rv;\\n};\\n\\n\\n/**\\n * Returns one key from the object map, if any exists.\\n * For map literals the returned key will be the first one in most of the\\n * browsers (a know exception is Konqueror).\\n *\\n * @param {Object} obj The object to pick a key from.\\n * @return {string|undefined} The key or undefined if the object is empty.\\n */\\ngoog.object.getAnyKey = function(obj) {\\n  'use strict';\\n  for (const key in obj) {\\n    return key;\\n  }\\n};\\n\\n\\n/**\\n * Returns one value from the object map, if any exists.\\n * For map literals the returned value will be the first one in most of the\\n * browsers (a know exception is Konqueror).\\n *\\n * @param {Object<K,V>} obj The object to pick a value from.\\n * @return {V|undefined} The value or undefined if the object is empty.\\n * @template K,V\\n */\\ngoog.object.getAnyValue = function(obj) {\\n  'use strict';\\n  for (const key in obj) {\\n    return obj[key];\\n  }\\n};\\n\\n\\n/**\\n * Whether the object/hash/map contains the given object as a value.\\n * An alias for goog.object.containsValue(obj, val).\\n *\\n * @param {Object<K,V>} obj The object in which to look for val.\\n * @param {V} val The object for which to check.\\n * @return {boolean} true if val is present.\\n * @template K,V\\n */\\ngoog.object.contains = function(obj, val) {\\n  'use strict';\\n  return goog.object.containsValue(obj, val);\\n};\\n\\n\\n/**\\n * Returns the values of the object/map/hash.\\n *\\n * @param {Object<K,V>} obj The object from which to get the values.\\n * @return {!Array<V>} The values in the object/map/hash.\\n * @template K,V\\n */\\ngoog.object.getValues = function(obj) {\\n  'use strict';\\n  const res = [];\\n  let i = 0;\\n  for (const key in obj) {\\n    res[i++] = obj[key];\\n  }\\n  return res;\\n};\\n\\n\\n/**\\n * Returns the keys of the object/map/hash.\\n *\\n * @param {Object} obj The object from which to get the keys.\\n * @return {!Array<string>} Array of property keys.\\n */\\ngoog.object.getKeys = function(obj) {\\n  'use strict';\\n  const res = [];\\n  let i = 0;\\n  for (const key in obj) {\\n    res[i++] = key;\\n  }\\n  return res;\\n};\\n\\n\\n/**\\n * Get a value from an object multiple levels deep.  This is useful for\\n * pulling values from deeply nested objects, such as JSON responses.\\n * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)\\n *\\n * @param {!Object} obj An object to get the value from.  Can be array-like.\\n * @param {...(string|number|!IArrayLike<number|string>)}\\n *     var_args A number of keys\\n *     (as strings, or numbers, for array-like objects).  Can also be\\n *     specified as a single array of keys.\\n * @return {*} The resulting value.  If, at any point, the value for a key\\n *     in the current object is null or undefined, returns undefined.\\n */\\ngoog.object.getValueByKeys = function(obj, var_args) {\\n  'use strict';\\n  const isArrayLike = goog.isArrayLike(var_args);\\n  const keys = isArrayLike ?\\n      /** @type {!IArrayLike<number|string>} */ (var_args) :\\n      arguments;\\n\\n  // Start with the 2nd parameter for the variable parameters syntax.\\n  for (let i = isArrayLike ? 0 : 1; i < keys.length; i++) {\\n    if (obj == null) return undefined;\\n    obj = obj[keys[i]];\\n  }\\n\\n  return obj;\\n};\\n\\n\\n/**\\n * Whether the object/map/hash contains the given key.\\n *\\n * @param {Object} obj The object in which to look for key.\\n * @param {?} key The key for which to check.\\n * @return {boolean} true If the map contains the key.\\n */\\ngoog.object.containsKey = function(obj, key) {\\n  'use strict';\\n  return obj !== null && key in obj;\\n};\\n\\n\\n/**\\n * Whether the object/map/hash contains the given value. This is O(n).\\n *\\n * @param {Object<K,V>} obj The object in which to look for val.\\n * @param {V} val The value for which to check.\\n * @return {boolean} true If the map contains the value.\\n * @template K,V\\n */\\ngoog.object.containsValue = function(obj, val) {\\n  'use strict';\\n  for (const key in obj) {\\n    if (obj[key] == val) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * Searches an object for an element that satisfies the given condition and\\n * returns its key.\\n * @param {Object<K,V>} obj The object to search in.\\n * @param {function(this:T,V,string,Object<K,V>):boolean} f The\\n *      function to call for every element. Takes 3 arguments (the value,\\n *     the key and the object) and should return a boolean.\\n * @param {T=} opt_this An optional \\\"this\\\" context for the function.\\n * @return {string|undefined} The key of an element for which the function\\n *     returns true or undefined if no such element is found.\\n * @template T,K,V\\n */\\ngoog.object.findKey = function(obj, f, opt_this) {\\n  'use strict';\\n  for (const key in obj) {\\n    if (f.call(/** @type {?} */ (opt_this), obj[key], key, obj)) {\\n      return key;\\n    }\\n  }\\n  return undefined;\\n};\\n\\n\\n/**\\n * Searches an object for an element that satisfies the given condition and\\n * returns its value.\\n * @param {Object<K,V>} obj The object to search in.\\n * @param {function(this:T,V,string,Object<K,V>):boolean} f The function\\n *     to call for every element. Takes 3 arguments (the value, the key\\n *     and the object) and should return a boolean.\\n * @param {T=} opt_this An optional \\\"this\\\" context for the function.\\n * @return {V} The value of an element for which the function returns true or\\n *     undefined if no such element is found.\\n * @template T,K,V\\n */\\ngoog.object.findValue = function(obj, f, opt_this) {\\n  'use strict';\\n  const key = goog.object.findKey(obj, f, opt_this);\\n  return key && obj[key];\\n};\\n\\n\\n/**\\n * Whether the object/map/hash is empty.\\n *\\n * @param {Object} obj The object to test.\\n * @return {boolean} true if obj is empty.\\n */\\ngoog.object.isEmpty = function(obj) {\\n  'use strict';\\n  for (const key in obj) {\\n    return false;\\n  }\\n  return true;\\n};\\n\\n\\n/**\\n * Removes all key value pairs from the object/map/hash.\\n *\\n * @param {Object} obj The object to clear.\\n */\\ngoog.object.clear = function(obj) {\\n  'use strict';\\n  for (const i in obj) {\\n    delete obj[i];\\n  }\\n};\\n\\n\\n/**\\n * Removes a key-value pair based on the key.\\n *\\n * @param {Object} obj The object from which to remove the key.\\n * @param {?} key The key to remove.\\n * @return {boolean} Whether an element was removed.\\n */\\ngoog.object.remove = function(obj, key) {\\n  'use strict';\\n  let rv;\\n  if (rv = key in /** @type {!Object} */ (obj)) {\\n    delete obj[key];\\n  }\\n  return rv;\\n};\\n\\n\\n/**\\n * Adds a key-value pair to the object. Throws an exception if the key is\\n * already in use. Use set if you want to change an existing pair.\\n *\\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\\n * @param {string} key The key to add.\\n * @param {V} val The value to add.\\n * @template K,V\\n */\\ngoog.object.add = function(obj, key, val) {\\n  'use strict';\\n  if (obj !== null && key in obj) {\\n    throw new Error('The object already contains the key \\\"' + key + '\\\"');\\n  }\\n  goog.object.set(obj, key, val);\\n};\\n\\n\\n/**\\n * Returns the value for the given key.\\n *\\n * @param {Object<K,V>} obj The object from which to get the value.\\n * @param {string} key The key for which to get the value.\\n * @param {R=} opt_val The value to return if no item is found for the given\\n *     key (default is undefined).\\n * @return {V|R|undefined} The value for the given key.\\n * @template K,V,R\\n */\\ngoog.object.get = function(obj, key, opt_val) {\\n  'use strict';\\n  if (obj !== null && key in obj) {\\n    return obj[key];\\n  }\\n  return opt_val;\\n};\\n\\n\\n/**\\n * Adds a key-value pair to the object/map/hash.\\n *\\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\\n * @param {string} key The key to add.\\n * @param {V} value The value to add.\\n * @template K,V\\n */\\ngoog.object.set = function(obj, key, value) {\\n  'use strict';\\n  obj[key] = value;\\n};\\n\\n\\n/**\\n * Adds a key-value pair to the object/map/hash if it doesn't exist yet.\\n *\\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\\n * @param {string} key The key to add.\\n * @param {V} value The value to add if the key wasn't present.\\n * @return {V} The value of the entry at the end of the function.\\n * @template K,V\\n */\\ngoog.object.setIfUndefined = function(obj, key, value) {\\n  'use strict';\\n  return key in /** @type {!Object} */ (obj) ? obj[key] : (obj[key] = value);\\n};\\n\\n\\n/**\\n * Sets a key and value to an object if the key is not set. The value will be\\n * the return value of the given function. If the key already exists, the\\n * object will not be changed and the function will not be called (the function\\n * will be lazily evaluated -- only called if necessary).\\n *\\n * This function is particularly useful when used with an `Object` which is\\n * acting as a cache.\\n *\\n * @param {!Object<K,V>} obj The object to which to add the key-value pair.\\n * @param {string} key The key to add.\\n * @param {function():V} f The value to add if the key wasn't present.\\n * @return {V} The value of the entry at the end of the function.\\n * @template K,V\\n */\\ngoog.object.setWithReturnValueIfNotSet = function(obj, key, f) {\\n  'use strict';\\n  if (key in obj) {\\n    return obj[key];\\n  }\\n\\n  const val = f();\\n  obj[key] = val;\\n  return val;\\n};\\n\\n\\n/**\\n * Compares two objects for equality using === on the values.\\n *\\n * @param {!Object<K,V>} a\\n * @param {!Object<K,V>} b\\n * @return {boolean}\\n * @template K,V\\n */\\ngoog.object.equals = function(a, b) {\\n  'use strict';\\n  for (const k in a) {\\n    if (!(k in b) || a[k] !== b[k]) {\\n      return false;\\n    }\\n  }\\n  for (const k in b) {\\n    if (!(k in a)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n};\\n\\n\\n/**\\n * Returns a shallow clone of the object.\\n *\\n * @param {Object<K,V>} obj Object to clone.\\n * @return {!Object<K,V>} Clone of the input object.\\n * @template K,V\\n */\\ngoog.object.clone = function(obj) {\\n  'use strict';\\n  const res = {};\\n  for (const key in obj) {\\n    res[key] = obj[key];\\n  }\\n  return res;\\n};\\n\\n\\n/**\\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\\n * arrays will be cloned recursively.\\n *\\n * WARNINGS:\\n * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects\\n * that refer to themselves will cause infinite recursion.\\n *\\n * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and\\n * copies UIDs created by <code>getUid</code> into cloned results.\\n *\\n * @param {T} obj The value to clone.\\n * @return {T} A clone of the input value.\\n * @template T\\n */\\ngoog.object.unsafeClone = function(obj) {\\n  'use strict';\\n  if (!obj || typeof obj !== 'object') return obj;\\n  if (typeof obj.clone === 'function') return obj.clone();\\n  const clone = Array.isArray(obj) ? [] :\\n      typeof ArrayBuffer === 'function' &&\\n          typeof ArrayBuffer.isView === 'function' && ArrayBuffer.isView(obj) &&\\n          !(obj instanceof DataView) ?\\n                                     new obj.constructor(obj.length) :\\n                                     {};\\n  for (const key in obj) {\\n    clone[key] = goog.object.unsafeClone(obj[key]);\\n  }\\n  return clone;\\n};\\n\\n\\n/**\\n * Returns a new object in which all the keys and values are interchanged\\n * (keys become values and values become keys). If multiple keys map to the\\n * same value, the chosen transposed value is implementation-dependent.\\n *\\n * @param {Object} obj The object to transpose.\\n * @return {!Object} The transposed object.\\n */\\ngoog.object.transpose = function(obj) {\\n  'use strict';\\n  const transposed = {};\\n  for (const key in obj) {\\n    transposed[obj[key]] = key;\\n  }\\n  return transposed;\\n};\\n\\n\\n/**\\n * The names of the fields that are defined on Object.prototype.\\n * @type {Array<string>}\\n * @private\\n */\\ngoog.object.PROTOTYPE_FIELDS_ = [\\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\\n  'toLocaleString', 'toString', 'valueOf'\\n];\\n\\n\\n/**\\n * Extends an object with another object.\\n * This operates 'in-place'; it does not create a new Object.\\n *\\n * Example:\\n * var o = {};\\n * goog.object.extend(o, {a: 0, b: 1});\\n * o; // {a: 0, b: 1}\\n * goog.object.extend(o, {b: 2, c: 3});\\n * o; // {a: 0, b: 2, c: 3}\\n *\\n * @param {Object} target The object to modify. Existing properties will be\\n *     overwritten if they are also present in one of the objects in\\n *     `var_args`.\\n * @param {...(Object|null|undefined)} var_args The objects from which values\\n *     will be copied.\\n * @deprecated Prefer Object.assign\\n */\\ngoog.object.extend = function(target, var_args) {\\n  'use strict';\\n  let key;\\n  let source;\\n  for (let i = 1; i < arguments.length; i++) {\\n    source = arguments[i];\\n    for (key in source) {\\n      target[key] = source[key];\\n    }\\n\\n    // For IE the for-in-loop does not contain any properties that are not\\n    // enumerable on the prototype object (for example isPrototypeOf from\\n    // Object.prototype) and it will also not include 'replace' on objects that\\n    // extend String and change 'replace' (not that it is common for anyone to\\n    // extend anything except Object).\\n\\n    for (let j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {\\n      key = goog.object.PROTOTYPE_FIELDS_[j];\\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\\n        target[key] = source[key];\\n      }\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Creates a new object built from the key-value pairs provided as arguments.\\n * @param {...*} var_args If only one argument is provided and it is an array\\n *     then this is used as the arguments, otherwise even arguments are used as\\n *     the property names and odd arguments are used as the property values.\\n * @return {!Object} The new object.\\n * @throws {Error} If there are uneven number of arguments or there is only one\\n *     non array argument.\\n */\\ngoog.object.create = function(var_args) {\\n  'use strict';\\n  const argLength = arguments.length;\\n  if (argLength == 1 && Array.isArray(arguments[0])) {\\n    return goog.object.create.apply(null, arguments[0]);\\n  }\\n\\n  if (argLength % 2) {\\n    throw new Error('Uneven number of arguments');\\n  }\\n\\n  const rv = {};\\n  for (let i = 0; i < argLength; i += 2) {\\n    rv[arguments[i]] = arguments[i + 1];\\n  }\\n  return rv;\\n};\\n\\n\\n/**\\n * Creates a new object where the property names come from the arguments but\\n * the value is always set to true\\n * @param {...*} var_args If only one argument is provided and it is an array\\n *     then this is used as the arguments, otherwise the arguments are used\\n *     as the property names.\\n * @return {!Object} The new object.\\n */\\ngoog.object.createSet = function(var_args) {\\n  'use strict';\\n  const argLength = arguments.length;\\n  if (argLength == 1 && Array.isArray(arguments[0])) {\\n    return goog.object.createSet.apply(null, arguments[0]);\\n  }\\n\\n  const rv = {};\\n  for (let i = 0; i < argLength; i++) {\\n    rv[arguments[i]] = true;\\n  }\\n  return rv;\\n};\\n\\n\\n/**\\n * Creates an immutable view of the underlying object, if the browser\\n * supports immutable objects.\\n *\\n * In default mode, writes to this view will fail silently. In strict mode,\\n * they will throw an error.\\n *\\n * @param {!Object<K,V>} obj An object.\\n * @return {!Object<K,V>} An immutable view of that object, or the\\n *     original object if this browser does not support immutables.\\n * @template K,V\\n */\\ngoog.object.createImmutableView = function(obj) {\\n  'use strict';\\n  let result = obj;\\n  if (Object.isFrozen && !Object.isFrozen(obj)) {\\n    result = Object.create(obj);\\n    Object.freeze(result);\\n  }\\n  return result;\\n};\\n\\n\\n/**\\n * @param {!Object} obj An object.\\n * @return {boolean} Whether this is an immutable view of the object.\\n */\\ngoog.object.isImmutableView = function(obj) {\\n  'use strict';\\n  return !!Object.isFrozen && Object.isFrozen(obj);\\n};\\n\\n\\n/**\\n * Get all properties names on a given Object regardless of enumerability.\\n *\\n * <p> If the browser does not support `Object.getOwnPropertyNames` nor\\n * `Object.getPrototypeOf` then this is equivalent to using\\n * `goog.object.getKeys`\\n *\\n * @param {?Object} obj The object to get the properties of.\\n * @param {boolean=} opt_includeObjectPrototype Whether properties defined on\\n *     `Object.prototype` should be included in the result.\\n * @param {boolean=} opt_includeFunctionPrototype Whether properties defined on\\n *     `Function.prototype` should be included in the result.\\n * @return {!Array<string>}\\n * @public\\n */\\ngoog.object.getAllPropertyNames = function(\\n    obj, opt_includeObjectPrototype, opt_includeFunctionPrototype) {\\n  'use strict';\\n  if (!obj) {\\n    return [];\\n  }\\n\\n  // Naively use a for..in loop to get the property names if the browser doesn't\\n  // support any other APIs for getting it.\\n  if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\\n    return goog.object.getKeys(obj);\\n  }\\n\\n  const visitedSet = {};\\n\\n  // Traverse the prototype chain and add all properties to the visited set.\\n  let proto = obj;\\n  while (proto &&\\n         (proto !== Object.prototype || !!opt_includeObjectPrototype) &&\\n         (proto !== Function.prototype || !!opt_includeFunctionPrototype)) {\\n    const names = Object.getOwnPropertyNames(proto);\\n    for (let i = 0; i < names.length; i++) {\\n      visitedSet[names[i]] = true;\\n    }\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n\\n  return goog.object.getKeys(visitedSet);\\n};\\n\\n\\n/**\\n * Given a ES5 or ES6 class reference, return its super class / super\\n * constructor.\\n *\\n * This should be used in rare cases where you need to walk up the inheritance\\n * tree (this is generally a bad idea). But this work with ES5 and ES6 classes,\\n * unlike relying on the superClass_ property.\\n *\\n * Note: To start walking up the hierarchy from an instance call this with its\\n * `constructor` property; e.g. `getSuperClass(instance.constructor)`.\\n *\\n * @param {function(new: ?)} constructor\\n * @return {?Object}\\n */\\ngoog.object.getSuperClass = function(constructor) {\\n  'use strict';\\n  var proto = Object.getPrototypeOf(constructor.prototype);\\n  return proto && proto.constructor;\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"object\",\"forEach\",\"goog.object.forEach\",\"obj\",\"f\",\"opt_obj\",\"key\",\"call\",\"filter\",\"goog.object.filter\",\"res\",\"map\",\"goog.object.map\",\"some\",\"goog.object.some\",\"every\",\"goog.object.every\",\"getCount\",\"goog.object.getCount\",\"rv\",\"getAnyKey\",\"goog.object.getAnyKey\",\"getAnyValue\",\"goog.object.getAnyValue\",\"contains\",\"goog.object.contains\",\"val\",\"containsValue\",\"getValues\",\"goog.object.getValues\",\"i\",\"getKeys\",\"goog.object.getKeys\",\"getValueByKeys\",\"goog.object.getValueByKeys\",\"var_args\",\"isArrayLike\",\"keys\",\"arguments\",\"length\",\"undefined\",\"containsKey\",\"goog.object.containsKey\",\"goog.object.containsValue\",\"findKey\",\"goog.object.findKey\",\"opt_this\",\"findValue\",\"goog.object.findValue\",\"isEmpty\",\"goog.object.isEmpty\",\"clear\",\"goog.object.clear\",\"remove\",\"goog.object.remove\",\"add\",\"goog.object.add\",\"Error\",\"set\",\"get\",\"goog.object.get\",\"opt_val\",\"goog.object.set\",\"value\",\"setIfUndefined\",\"goog.object.setIfUndefined\",\"setWithReturnValueIfNotSet\",\"goog.object.setWithReturnValueIfNotSet\",\"equals\",\"goog.object.equals\",\"a\",\"b\",\"k\",\"clone\",\"goog.object.clone\",\"unsafeClone\",\"goog.object.unsafeClone\",\"Array\",\"isArray\",\"ArrayBuffer\",\"isView\",\"DataView\",\"constructor\",\"transpose\",\"goog.object.transpose\",\"transposed\",\"PROTOTYPE_FIELDS_\",\"extend\",\"goog.object.extend\",\"target\",\"source\",\"j\",\"Object\",\"prototype\",\"hasOwnProperty\",\"create\",\"goog.object.create\",\"argLength\",\"apply\",\"createSet\",\"goog.object.createSet\",\"createImmutableView\",\"goog.object.createImmutableView\",\"result\",\"isFrozen\",\"freeze\",\"isImmutableView\",\"goog.object.isImmutableView\",\"getAllPropertyNames\",\"goog.object.getAllPropertyNames\",\"opt_includeObjectPrototype\",\"opt_includeFunctionPrototype\",\"getOwnPropertyNames\",\"getPrototypeOf\",\"visitedSet\",\"proto\",\"Function\",\"names\",\"getSuperClass\",\"goog.object.getSuperClass\"]\n}\n"]