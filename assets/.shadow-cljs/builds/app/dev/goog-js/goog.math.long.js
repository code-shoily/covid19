["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/math/long.js"],"~:js","goog.loadModule(function(exports) {\n  \"use strict\";\n  goog.module(\"goog.math.Long\");\n  goog.module.declareLegacyNamespace();\n  const asserts = goog.require(\"goog.asserts\");\n  const reflect = goog.require(\"goog.reflect\");\n  class Long {\n    constructor(low, high) {\n      this.low_ = low | 0;\n      this.high_ = high | 0;\n    }\n    toInt() {\n      return this.low_;\n    }\n    toNumber() {\n      return this.high_ * TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();\n    }\n    isSafeInteger() {\n      var top11Bits = this.high_ >> 21;\n      return top11Bits == 0 || top11Bits == -1 && !(this.low_ == 0 && this.high_ == (4292870144 | 0));\n    }\n    toString(opt_radix) {\n      var radix = opt_radix || 10;\n      if (radix < 2 || 36 < radix) {\n        throw new Error(\"radix out of range: \" + radix);\n      }\n      if (this.isSafeInteger()) {\n        var asNumber = this.toNumber();\n        return radix == 10 ? \"\" + asNumber : asNumber.toString(radix);\n      }\n      var safeDigits = 14 - (radix >> 2);\n      var radixPowSafeDigits = Math.pow(radix, safeDigits);\n      var radixToPower = Long.fromBits(radixPowSafeDigits, radixPowSafeDigits / TWO_PWR_32_DBL_);\n      var remDiv = this.div(radixToPower);\n      var val = Math.abs(this.subtract(remDiv.multiply(radixToPower)).toNumber());\n      var digits = radix == 10 ? \"\" + val : val.toString(radix);\n      if (digits.length < safeDigits) {\n        digits = \"0000000000000\".substr(digits.length - safeDigits) + digits;\n      }\n      val = remDiv.toNumber();\n      return (radix == 10 ? val : val.toString(radix)) + digits;\n    }\n    getHighBits() {\n      return this.high_;\n    }\n    getLowBits() {\n      return this.low_;\n    }\n    getLowBitsUnsigned() {\n      return this.low_ >>> 0;\n    }\n    getNumBitsAbs() {\n      if (this.isNegative()) {\n        if (this.equals(Long.getMinValue())) {\n          return 64;\n        } else {\n          return this.negate().getNumBitsAbs();\n        }\n      } else {\n        var val = this.high_ != 0 ? this.high_ : this.low_;\n        for (var bit = 31; bit > 0; bit--) {\n          if ((val & 1 << bit) != 0) {\n            break;\n          }\n        }\n        return this.high_ != 0 ? bit + 33 : bit + 1;\n      }\n    }\n    isZero() {\n      return this.low_ == 0 && this.high_ == 0;\n    }\n    isNegative() {\n      return this.high_ < 0;\n    }\n    isOdd() {\n      return (this.low_ & 1) == 1;\n    }\n    equals(other) {\n      return this.low_ == other.low_ && this.high_ == other.high_;\n    }\n    notEquals(other) {\n      return !this.equals(other);\n    }\n    lessThan(other) {\n      return this.compare(other) < 0;\n    }\n    lessThanOrEqual(other) {\n      return this.compare(other) <= 0;\n    }\n    greaterThan(other) {\n      return this.compare(other) > 0;\n    }\n    greaterThanOrEqual(other) {\n      return this.compare(other) >= 0;\n    }\n    compare(other) {\n      if (this.high_ == other.high_) {\n        if (this.low_ == other.low_) {\n          return 0;\n        }\n        return this.getLowBitsUnsigned() > other.getLowBitsUnsigned() ? 1 : -1;\n      }\n      return this.high_ > other.high_ ? 1 : -1;\n    }\n    negate() {\n      var negLow = ~this.low_ + 1 | 0;\n      var overflowFromLow = !negLow;\n      var negHigh = ~this.high_ + overflowFromLow | 0;\n      return Long.fromBits(negLow, negHigh);\n    }\n    add(other) {\n      var a48 = this.high_ >>> 16;\n      var a32 = this.high_ & 65535;\n      var a16 = this.low_ >>> 16;\n      var a00 = this.low_ & 65535;\n      var b48 = other.high_ >>> 16;\n      var b32 = other.high_ & 65535;\n      var b16 = other.low_ >>> 16;\n      var b00 = other.low_ & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 + b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 + b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 + b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 + b48;\n      c48 &= 65535;\n      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    multiply(other) {\n      if (this.isZero()) {\n        return this;\n      }\n      if (other.isZero()) {\n        return other;\n      }\n      var a48 = this.high_ >>> 16;\n      var a32 = this.high_ & 65535;\n      var a16 = this.low_ >>> 16;\n      var a00 = this.low_ & 65535;\n      var b48 = other.high_ >>> 16;\n      var b32 = other.high_ & 65535;\n      var b16 = other.low_ >>> 16;\n      var b00 = other.low_ & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 * b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 * b00;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c16 += a00 * b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 * b00;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a16 * b16;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a00 * b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n      c48 &= 65535;\n      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32);\n    }\n    div(other) {\n      if (other.isZero()) {\n        throw new Error(\"division by zero\");\n      }\n      if (this.isNegative()) {\n        if (this.equals(Long.getMinValue())) {\n          if (other.equals(Long.getOne()) || other.equals(Long.getNegOne())) {\n            return Long.getMinValue();\n          }\n          if (other.equals(Long.getMinValue())) {\n            return Long.getOne();\n          }\n          var halfThis = this.shiftRight(1);\n          var approx = halfThis.div(other).shiftLeft(1);\n          if (approx.equals(Long.getZero())) {\n            return other.isNegative() ? Long.getOne() : Long.getNegOne();\n          }\n          var rem = this.subtract(other.multiply(approx));\n          var result = approx.add(rem.div(other));\n          return result;\n        }\n        if (other.isNegative()) {\n          return this.negate().div(other.negate());\n        }\n        return this.negate().div(other).negate();\n      }\n      if (this.isZero()) {\n        return Long.getZero();\n      }\n      if (other.isNegative()) {\n        if (other.equals(Long.getMinValue())) {\n          return Long.getZero();\n        }\n        return this.div(other.negate()).negate();\n      }\n      var res = Long.getZero();\n      var rem = this;\n      while (rem.greaterThanOrEqual(other)) {\n        var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n        var approxRes = Long.fromNumber(approx);\n        var approxRem = approxRes.multiply(other);\n        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n          approx -= delta;\n          approxRes = Long.fromNumber(approx);\n          approxRem = approxRes.multiply(other);\n        }\n        if (approxRes.isZero()) {\n          approxRes = Long.getOne();\n        }\n        res = res.add(approxRes);\n        rem = rem.subtract(approxRem);\n      }\n      return res;\n    }\n    modulo(other) {\n      return this.subtract(this.div(other).multiply(other));\n    }\n    not() {\n      return Long.fromBits(~this.low_, ~this.high_);\n    }\n    and(other) {\n      return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);\n    }\n    or(other) {\n      return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);\n    }\n    xor(other) {\n      return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);\n    }\n    shiftLeft(numBits) {\n      numBits &= 63;\n      if (numBits == 0) {\n        return this;\n      } else {\n        var low = this.low_;\n        if (numBits < 32) {\n          var high = this.high_;\n          return Long.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);\n        } else {\n          return Long.fromBits(0, low << numBits - 32);\n        }\n      }\n    }\n    shiftRight(numBits) {\n      numBits &= 63;\n      if (numBits == 0) {\n        return this;\n      } else {\n        var high = this.high_;\n        if (numBits < 32) {\n          var low = this.low_;\n          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);\n        } else {\n          return Long.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);\n        }\n      }\n    }\n    shiftRightUnsigned(numBits) {\n      numBits &= 63;\n      if (numBits == 0) {\n        return this;\n      } else {\n        var high = this.high_;\n        if (numBits < 32) {\n          var low = this.low_;\n          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);\n        } else {\n          if (numBits == 32) {\n            return Long.fromBits(high, 0);\n          } else {\n            return Long.fromBits(high >>> numBits - 32, 0);\n          }\n        }\n      }\n    }\n    static fromInt(value) {\n      var intValue = value | 0;\n      asserts.assert(value === intValue, \"value should be a 32-bit integer\");\n      if (-128 <= intValue && intValue < 128) {\n        return getCachedIntValue_(intValue);\n      } else {\n        return new Long(intValue, intValue < 0 ? -1 : 0);\n      }\n    }\n    static fromNumber(value) {\n      if (value > 0) {\n        if (value >= TWO_PWR_63_DBL_) {\n          return Long.getMaxValue();\n        }\n        return new Long(value, value / TWO_PWR_32_DBL_);\n      } else {\n        if (value < 0) {\n          if (value <= -TWO_PWR_63_DBL_) {\n            return Long.getMinValue();\n          }\n          return (new Long(-value, -value / TWO_PWR_32_DBL_)).negate();\n        } else {\n          return Long.getZero();\n        }\n      }\n    }\n    static fromBits(lowBits, highBits) {\n      return new Long(lowBits, highBits);\n    }\n    static fromString(str, opt_radix) {\n      if (str.charAt(0) == \"-\") {\n        return Long.fromString(str.substring(1), opt_radix).negate();\n      }\n      var numberValue = parseInt(str, opt_radix || 10);\n      if (numberValue <= MAX_SAFE_INTEGER_) {\n        return new Long(numberValue % TWO_PWR_32_DBL_ | 0, numberValue / TWO_PWR_32_DBL_ | 0);\n      }\n      if (str.length == 0) {\n        throw new Error(\"number format error: empty string\");\n      }\n      if (str.indexOf(\"-\") >= 0) {\n        throw new Error('number format error: interior \"-\" character: ' + str);\n      }\n      var radix = opt_radix || 10;\n      if (radix < 2 || 36 < radix) {\n        throw new Error(\"radix out of range: \" + radix);\n      }\n      var radixToPower = Long.fromNumber(Math.pow(radix, 8));\n      var result = Long.getZero();\n      for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i);\n        var value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n          var power = Long.fromNumber(Math.pow(radix, size));\n          result = result.multiply(power).add(Long.fromNumber(value));\n        } else {\n          result = result.multiply(radixToPower);\n          result = result.add(Long.fromNumber(value));\n        }\n      }\n      return result;\n    }\n    static isStringInRange(str, opt_radix) {\n      var radix = opt_radix || 10;\n      if (radix < 2 || 36 < radix) {\n        throw new Error(\"radix out of range: \" + radix);\n      }\n      var extremeValue = str.charAt(0) == \"-\" ? MIN_VALUE_FOR_RADIX_[radix] : MAX_VALUE_FOR_RADIX_[radix];\n      if (str.length < extremeValue.length) {\n        return true;\n      } else {\n        if (str.length == extremeValue.length && str <= extremeValue) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }\n    static getZero() {\n      return ZERO_;\n    }\n    static getOne() {\n      return ONE_;\n    }\n    static getNegOne() {\n      return NEG_ONE_;\n    }\n    static getMaxValue() {\n      return MAX_VALUE_;\n    }\n    static getMinValue() {\n      return MIN_VALUE_;\n    }\n    static getTwoPwr24() {\n      return TWO_PWR_24_;\n    }\n  }\n  exports = Long;\n  const IntCache_ = {};\n  function getCachedIntValue_(value) {\n    return reflect.cache(IntCache_, value, function(val) {\n      return new Long(val, val < 0 ? -1 : 0);\n    });\n  }\n  const MAX_VALUE_FOR_RADIX_ = [\"\", \"\", \"111111111111111111111111111111111111111111111111111111111111111\", \"2021110011022210012102010021220101220221\", \"13333333333333333333333333333333\", \"1104332401304422434310311212\", \"1540241003031030222122211\", \"22341010611245052052300\", \"777777777777777777777\", \"67404283172107811827\", \"9223372036854775807\", \"1728002635214590697\", \"41a792678515120367\", \"10b269549075433c37\", \"4340724c6c71dc7a7\", \"160e2ad3246366807\", \"7fffffffffffffff\", \"33d3d8307b214008\", \"16agh595df825fa7\", \n  \"ba643dci0ffeehh\", \"5cbfjia3fh26ja7\", \"2heiciiie82dh97\", \"1adaibb21dckfa7\", \"i6k448cf4192c2\", \"acd772jnc9l0l7\", \"64ie1focnn5g77\", \"3igoecjbmca687\", \"27c48l5b37oaop\", \"1bk39f3ah3dmq7\", \"q1se8f0m04isb\", \"hajppbc1fc207\", \"bm03i95hia437\", \"7vvvvvvvvvvvv\", \"5hg4ck9jd4u37\", \"3tdtk1v8j6tpp\", \"2pijmikexrxp7\", \"1y2p0ij32e8e7\"];\n  const MIN_VALUE_FOR_RADIX_ = [\"\", \"\", \"-1000000000000000000000000000000000000000000000000000000000000000\", \"-2021110011022210012102010021220101220222\", \"-20000000000000000000000000000000\", \"-1104332401304422434310311213\", \"-1540241003031030222122212\", \"-22341010611245052052301\", \"-1000000000000000000000\", \"-67404283172107811828\", \"-9223372036854775808\", \"-1728002635214590698\", \"-41a792678515120368\", \"-10b269549075433c38\", \"-4340724c6c71dc7a8\", \"-160e2ad3246366808\", \"-8000000000000000\", \"-33d3d8307b214009\", \n  \"-16agh595df825fa8\", \"-ba643dci0ffeehi\", \"-5cbfjia3fh26ja8\", \"-2heiciiie82dh98\", \"-1adaibb21dckfa8\", \"-i6k448cf4192c3\", \"-acd772jnc9l0l8\", \"-64ie1focnn5g78\", \"-3igoecjbmca688\", \"-27c48l5b37oaoq\", \"-1bk39f3ah3dmq8\", \"-q1se8f0m04isc\", \"-hajppbc1fc208\", \"-bm03i95hia438\", \"-8000000000000\", \"-5hg4ck9jd4u38\", \"-3tdtk1v8j6tpq\", \"-2pijmikexrxp8\", \"-1y2p0ij32e8e8\"];\n  const MAX_SAFE_INTEGER_ = 9007199254740991;\n  const TWO_PWR_32_DBL_ = 4294967296;\n  const TWO_PWR_63_DBL_ = 0x7fffffffffffffff;\n  const ZERO_ = Long.fromBits(0, 0);\n  const ONE_ = Long.fromBits(1, 0);\n  const NEG_ONE_ = Long.fromBits(-1, -1);\n  const MAX_VALUE_ = Long.fromBits(4294967295, 2147483647);\n  const MIN_VALUE_ = Long.fromBits(0, 2147483648);\n  const TWO_PWR_24_ = Long.fromBits(1 << 24, 0);\n  return exports;\n});\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Defines a Long class for representing a 64-bit two's-complement\n * integer value, which faithfully simulates the behavior of a Java \"long\". This\n * implementation is derived from LongLib in GWT.\n */\n\ngoog.module('goog.math.Long');\ngoog.module.declareLegacyNamespace();\n\nconst asserts = goog.require('goog.asserts');\nconst reflect = goog.require('goog.reflect');\n\n/**\n * Represents a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * JavaScript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within JavaScript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n * @final\n */\nclass Long {\n  /**\n   * @param {number} low  The low (signed) 32 bits of the long.\n   * @param {number} high  The high (signed) 32 bits of the long.\n   */\n  constructor(low, high) {\n    /**\n     * @const {number}\n     * @private\n     */\n    this.low_ = low | 0;  // force into 32 signed bits.\n\n    /**\n     * @const {number}\n     * @private\n     */\n    this.high_ = high | 0;  // force into 32 signed bits.\n  }\n\n  /** @return {number} The value, assuming it is a 32-bit integer. */\n  toInt() {\n    return this.low_;\n  }\n\n  /**\n   * @return {number} The closest floating-point representation to this value.\n   */\n  toNumber() {\n    return this.high_ * TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();\n  }\n\n  /**\n   * @return {boolean} if can be exactly represented using number (i.e.\n   *     abs(value) < 2^53).\n   */\n  isSafeInteger() {\n    var top11Bits = this.high_ >> 21;\n    // If top11Bits are all 0s, then the number is between [0, 2^53-1]\n    return top11Bits == 0\n        // If top11Bits are all 1s, then the number is between [-1, -2^53]\n        || (top11Bits == -1\n            // and exclude -2^53\n            && !(this.low_ == 0 && this.high_ == (0xffe00000 | 0)));\n  }\n\n  /**\n   * @param {number=} opt_radix The radix in which the text should be written.\n   * @return {string} The textual representation of this value.\n   * @override\n   */\n  toString(opt_radix) {\n    var radix = opt_radix || 10;\n    if (radix < 2 || 36 < radix) {\n      throw new Error('radix out of range: ' + radix);\n    }\n\n    // We can avoid very expensive division based code path for some common\n    // cases.\n    if (this.isSafeInteger()) {\n      var asNumber = this.toNumber();\n      // Shortcutting for radix 10 (common case) to avoid boxing via toString:\n      // https://jsperf.com/tostring-vs-vs-if\n      return radix == 10 ? ('' + asNumber) : asNumber.toString(radix);\n    }\n\n    // We need to split 64bit integer into: `a * radix**safeDigits + b` where\n    // neither `a` nor `b` exceeds 53 bits, meaning that safeDigits can be any\n    // number in a range: [(63 - 53) / log2(radix); 53 / log2(radix)].\n\n    // Other options that need to be benchmarked:\n    //   11..16 - (radix >> 2);\n    //   10..13 - (radix >> 3);\n    //   10..11 - (radix >> 4);\n    var safeDigits = 14 - (radix >> 2);\n\n    var radixPowSafeDigits = Math.pow(radix, safeDigits);\n    var radixToPower =\n        Long.fromBits(radixPowSafeDigits, radixPowSafeDigits / TWO_PWR_32_DBL_);\n\n    var remDiv = this.div(radixToPower);\n    var val = Math.abs(this.subtract(remDiv.multiply(radixToPower)).toNumber());\n    var digits = radix == 10 ? ('' + val) : val.toString(radix);\n\n    if (digits.length < safeDigits) {\n      // Up to 13 leading 0s we might need to insert as the greatest safeDigits\n      // value is 14 (for radix 2).\n      digits = '0000000000000'.substr(digits.length - safeDigits) + digits;\n    }\n\n    val = remDiv.toNumber();\n    return (radix == 10 ? val : val.toString(radix)) + digits;\n  }\n\n  /** @return {number} The high 32-bits as a signed value. */\n  getHighBits() {\n    return this.high_;\n  }\n\n  /** @return {number} The low 32-bits as a signed value. */\n  getLowBits() {\n    return this.low_;\n  }\n\n  /** @return {number} The low 32-bits as an unsigned value. */\n  getLowBitsUnsigned() {\n    // The right shifting fixes negative values in the case when\n    // intval >= 2^31; for more details see\n    // https://github.com/google/closure-library/pull/498\n    return this.low_ >>> 0;\n  }\n\n  /**\n   * @return {number} Returns the number of bits needed to represent the\n   *     absolute value of this Long.\n   */\n  getNumBitsAbs() {\n    if (this.isNegative()) {\n      if (this.equals(Long.getMinValue())) {\n        return 64;\n      } else {\n        return this.negate().getNumBitsAbs();\n      }\n    } else {\n      var val = this.high_ != 0 ? this.high_ : this.low_;\n      for (var bit = 31; bit > 0; bit--) {\n        if ((val & (1 << bit)) != 0) {\n          break;\n        }\n      }\n      return this.high_ != 0 ? bit + 33 : bit + 1;\n    }\n  }\n\n  /** @return {boolean} Whether this value is zero. */\n  isZero() {\n    // Check low part first as there is high chance it's not 0.\n    return this.low_ == 0 && this.high_ == 0;\n  }\n\n  /** @return {boolean} Whether this value is negative. */\n  isNegative() {\n    return this.high_ < 0;\n  }\n\n  /** @return {boolean} Whether this value is odd. */\n  isOdd() {\n    return (this.low_ & 1) == 1;\n  }\n\n  /**\n   * @param {?Long} other Long to compare against.\n   * @return {boolean} Whether this Long equals the other.\n   */\n  equals(other) {\n    // Compare low parts first as there is higher chance they are different.\n    return (this.low_ == other.low_) && (this.high_ == other.high_);\n  }\n\n  /**\n   * @param {?Long} other Long to compare against.\n   * @return {boolean} Whether this Long does not equal the other.\n   */\n  notEquals(other) {\n    return !this.equals(other);\n  }\n\n  /**\n   * @param {?Long} other Long to compare against.\n   * @return {boolean} Whether this Long is less than the other.\n   */\n  lessThan(other) {\n    return this.compare(other) < 0;\n  }\n\n  /**\n   * @param {?Long} other Long to compare against.\n   * @return {boolean} Whether this Long is less than or equal to the other.\n   */\n  lessThanOrEqual(other) {\n    return this.compare(other) <= 0;\n  }\n\n  /**\n   * @param {?Long} other Long to compare against.\n   * @return {boolean} Whether this Long is greater than the other.\n   */\n  greaterThan(other) {\n    return this.compare(other) > 0;\n  }\n\n  /**\n   * @param {?Long} other Long to compare against.\n   * @return {boolean} Whether this Long is greater than or equal to the other.\n   */\n  greaterThanOrEqual(other) {\n    return this.compare(other) >= 0;\n  }\n\n  /**\n   * Compares this Long with the given one.\n   * @param {?Long} other Long to compare against.\n   * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n   *     if the given one is greater.\n   */\n  compare(other) {\n    if (this.high_ == other.high_) {\n      if (this.low_ == other.low_) {\n        return 0;\n      }\n      return this.getLowBitsUnsigned() > other.getLowBitsUnsigned() ? 1 : -1;\n    }\n    return this.high_ > other.high_ ? 1 : -1;\n  }\n\n  /** @return {!Long} The negation of this value. */\n  negate() {\n    var negLow = (~this.low_ + 1) | 0;\n    var overflowFromLow = !negLow;\n    var negHigh = (~this.high_ + overflowFromLow) | 0;\n    return Long.fromBits(negLow, negHigh);\n  }\n\n  /**\n   * Returns the sum of this and the given Long.\n   * @param {?Long} other Long to add to this one.\n   * @return {!Long} The sum of this and the given Long.\n   */\n  add(other) {\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n    var a48 = this.high_ >>> 16;\n    var a32 = this.high_ & 0xFFFF;\n    var a16 = this.low_ >>> 16;\n    var a00 = this.low_ & 0xFFFF;\n\n    var b48 = other.high_ >>> 16;\n    var b32 = other.high_ & 0xFFFF;\n    var b16 = other.low_ >>> 16;\n    var b00 = other.low_ & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n  }\n\n  /**\n   * Returns the difference of this and the given Long.\n   * @param {?Long} other Long to subtract from this.\n   * @return {!Long} The difference of this and the given Long.\n   */\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  /**\n   * Returns the product of this and the given long.\n   * @param {?Long} other Long to multiply with this.\n   * @return {!Long} The product of this and the other.\n   */\n  multiply(other) {\n    if (this.isZero()) {\n      return this;\n    }\n    if (other.isZero()) {\n      return other;\n    }\n\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n\n    var a48 = this.high_ >>> 16;\n    var a32 = this.high_ & 0xFFFF;\n    var a16 = this.low_ >>> 16;\n    var a00 = this.low_ & 0xFFFF;\n\n    var b48 = other.high_ >>> 16;\n    var b32 = other.high_ & 0xFFFF;\n    var b16 = other.low_ >>> 16;\n    var b00 = other.low_ & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n  }\n\n  /**\n   * Returns this Long divided by the given one.\n   * @param {?Long} other Long by which to divide.\n   * @return {!Long} This Long divided by the given one.\n   */\n  div(other) {\n    if (other.isZero()) {\n      throw new Error('division by zero');\n    }\n    if (this.isNegative()) {\n      if (this.equals(Long.getMinValue())) {\n        if (other.equals(Long.getOne()) || other.equals(Long.getNegOne())) {\n          return Long.getMinValue();  // recall -MIN_VALUE == MIN_VALUE\n        }\n        if (other.equals(Long.getMinValue())) {\n          return Long.getOne();\n        }\n        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n        var halfThis = this.shiftRight(1);\n        var approx = halfThis.div(other).shiftLeft(1);\n        if (approx.equals(Long.getZero())) {\n          return other.isNegative() ? Long.getOne() : Long.getNegOne();\n        }\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n      if (other.isNegative()) {\n        return this.negate().div(other.negate());\n      }\n      return this.negate().div(other).negate();\n    }\n    if (this.isZero()) {\n      return Long.getZero();\n    }\n    if (other.isNegative()) {\n      if (other.equals(Long.getMinValue())) {\n        return Long.getZero();\n      }\n      return this.div(other.negate()).negate();\n    }\n\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    var res = Long.getZero();\n    var rem = this;\n    while (rem.greaterThanOrEqual(other)) {\n      // Approximate the result of division. This may be a little greater or\n      // smaller than the actual value.\n      var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n      // We will tweak the approximate result by changing it in the 48-th digit\n      // or the smallest non-fractional digit, whichever is larger.\n      var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n      var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n      // Decrease the approximation until it is smaller than the remainder. Note\n      // that if it is too large, the product overflows and is negative.\n      var approxRes = Long.fromNumber(approx);\n      var approxRem = approxRes.multiply(other);\n      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n        approx -= delta;\n        approxRes = Long.fromNumber(approx);\n        approxRem = approxRes.multiply(other);\n      }\n\n      // We know the answer can't be zero... and actually, zero would cause\n      // infinite recursion since we would make no progress.\n      if (approxRes.isZero()) {\n        approxRes = Long.getOne();\n      }\n\n      res = res.add(approxRes);\n      rem = rem.subtract(approxRem);\n    }\n    return res;\n  }\n\n  /**\n   * Returns this Long modulo the given one.\n   * @param {?Long} other Long by which to mod.\n   * @return {!Long} This Long modulo the given one.\n   */\n  modulo(other) {\n    return this.subtract(this.div(other).multiply(other));\n  }\n\n  /** @return {!Long} The bitwise-NOT of this value. */\n  not() {\n    return Long.fromBits(~this.low_, ~this.high_);\n  }\n\n  /**\n   * Returns the bitwise-AND of this Long and the given one.\n   * @param {?Long} other The Long with which to AND.\n   * @return {!Long} The bitwise-AND of this and the other.\n   */\n  and(other) {\n    return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);\n  }\n\n  /**\n   * Returns the bitwise-OR of this Long and the given one.\n   * @param {?Long} other The Long with which to OR.\n   * @return {!Long} The bitwise-OR of this and the other.\n   */\n  or(other) {\n    return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);\n  }\n\n  /**\n   * Returns the bitwise-XOR of this Long and the given one.\n   * @param {?Long} other The Long with which to XOR.\n   * @return {!Long} The bitwise-XOR of this and the other.\n   */\n  xor(other) {\n    return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);\n  }\n\n  /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @param {number} numBits The number of bits by which to shift.\n   * @return {!Long} This shifted to the left by the given amount.\n   */\n  shiftLeft(numBits) {\n    numBits &= 63;\n    if (numBits == 0) {\n      return this;\n    } else {\n      var low = this.low_;\n      if (numBits < 32) {\n        var high = this.high_;\n        return Long.fromBits(\n            low << numBits, (high << numBits) | (low >>> (32 - numBits)));\n      } else {\n        return Long.fromBits(0, low << (numBits - 32));\n      }\n    }\n  }\n\n  /**\n   * Returns this Long with bits shifted to the right by the given amount.\n   * The new leading bits match the current sign bit.\n   * @param {number} numBits The number of bits by which to shift.\n   * @return {!Long} This shifted to the right by the given amount.\n   */\n  shiftRight(numBits) {\n    numBits &= 63;\n    if (numBits == 0) {\n      return this;\n    } else {\n      var high = this.high_;\n      if (numBits < 32) {\n        var low = this.low_;\n        return Long.fromBits(\n            (low >>> numBits) | (high << (32 - numBits)), high >> numBits);\n      } else {\n        return Long.fromBits(high >> (numBits - 32), high >= 0 ? 0 : -1);\n      }\n    }\n  }\n\n  /**\n   * Returns this Long with bits shifted to the right by the given amount, with\n   * zeros placed into the new leading bits.\n   * @param {number} numBits The number of bits by which to shift.\n   * @return {!Long} This shifted to the right by the given amount,\n   *     with zeros placed into the new leading bits.\n   */\n  shiftRightUnsigned(numBits) {\n    numBits &= 63;\n    if (numBits == 0) {\n      return this;\n    } else {\n      var high = this.high_;\n      if (numBits < 32) {\n        var low = this.low_;\n        return Long.fromBits(\n            (low >>> numBits) | (high << (32 - numBits)), high >>> numBits);\n      } else if (numBits == 32) {\n        return Long.fromBits(high, 0);\n      } else {\n        return Long.fromBits(high >>> (numBits - 32), 0);\n      }\n    }\n  }\n\n  /**\n   * Returns a Long representing the given (32-bit) integer value.\n   * @param {number} value The 32-bit integer in question.\n   * @return {!Long} The corresponding Long value.\n   */\n  static fromInt(value) {\n    var intValue = value | 0;\n    asserts.assert(value === intValue, 'value should be a 32-bit integer');\n\n    if (-128 <= intValue && intValue < 128) {\n      return getCachedIntValue_(intValue);\n    } else {\n      return new Long(intValue, intValue < 0 ? -1 : 0);\n    }\n  }\n\n  /**\n   * Returns a Long representing the given value.\n   * NaN will be returned as zero. Infinity is converted to max value and\n   * -Infinity to min value.\n   * @param {number} value The number in question.\n   * @return {!Long} The corresponding Long value.\n   */\n  static fromNumber(value) {\n    if (value > 0) {\n      if (value >= TWO_PWR_63_DBL_) {\n        return Long.getMaxValue();\n      }\n      return new Long(value, value / TWO_PWR_32_DBL_);\n    } else if (value < 0) {\n      if (value <= -TWO_PWR_63_DBL_) {\n        return Long.getMinValue();\n      }\n      return new Long(-value, -value / TWO_PWR_32_DBL_).negate();\n    } else {\n      // NaN or 0.\n      return Long.getZero();\n    }\n  }\n\n  /**\n   * Returns a Long representing the 64-bit integer that comes by concatenating\n   * the given high and low bits.  Each is assumed to use 32 bits.\n   * @param {number} lowBits The low 32-bits.\n   * @param {number} highBits The high 32-bits.\n   * @return {!Long} The corresponding Long value.\n   */\n  static fromBits(lowBits, highBits) {\n    return new Long(lowBits, highBits);\n  }\n\n  /**\n   * Returns a Long representation of the given string, written using the given\n   * radix.\n   * @param {string} str The textual representation of the Long.\n   * @param {number=} opt_radix The radix in which the text is written.\n   * @return {!Long} The corresponding Long value.\n   */\n  static fromString(str, opt_radix) {\n    if (str.charAt(0) == '-') {\n      return Long.fromString(str.substring(1), opt_radix).negate();\n    }\n\n    // We can avoid very expensive multiply based code path for some common\n    // cases.\n    var numberValue = parseInt(str, opt_radix || 10);\n    if (numberValue <= MAX_SAFE_INTEGER_) {\n      return new Long(\n          (numberValue % TWO_PWR_32_DBL_) | 0,\n          (numberValue / TWO_PWR_32_DBL_) | 0);\n    }\n\n    if (str.length == 0) {\n      throw new Error('number format error: empty string');\n    }\n    if (str.indexOf('-') >= 0) {\n      throw new Error('number format error: interior \"-\" character: ' + str);\n    }\n\n    var radix = opt_radix || 10;\n    if (radix < 2 || 36 < radix) {\n      throw new Error('radix out of range: ' + radix);\n    }\n\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated multiply.\n    var radixToPower = Long.fromNumber(Math.pow(radix, 8));\n\n    var result = Long.getZero();\n    for (var i = 0; i < str.length; i += 8) {\n      var size = Math.min(8, str.length - i);\n      var value = parseInt(str.substring(i, i + size), radix);\n      if (size < 8) {\n        var power = Long.fromNumber(Math.pow(radix, size));\n        result = result.multiply(power).add(Long.fromNumber(value));\n      } else {\n        result = result.multiply(radixToPower);\n        result = result.add(Long.fromNumber(value));\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Returns the boolean value of whether the input string is within a Long's\n   * range. Assumes an input string containing only numeric characters with an\n   * optional preceding '-'.\n   * @param {string} str The textual representation of the Long.\n   * @param {number=} opt_radix The radix in which the text is written.\n   * @return {boolean} Whether the string is within the range of a Long.\n   */\n  static isStringInRange(str, opt_radix) {\n    var radix = opt_radix || 10;\n    if (radix < 2 || 36 < radix) {\n      throw new Error('radix out of range: ' + radix);\n    }\n\n    var extremeValue = (str.charAt(0) == '-') ? MIN_VALUE_FOR_RADIX_[radix] :\n                                                MAX_VALUE_FOR_RADIX_[radix];\n\n    if (str.length < extremeValue.length) {\n      return true;\n    } else if (str.length == extremeValue.length && str <= extremeValue) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @return {!Long}\n   * @public\n   */\n  static getZero() {\n    return ZERO_;\n  }\n\n  /**\n   * @return {!Long}\n   * @public\n   */\n  static getOne() {\n    return ONE_;\n  }\n\n  /**\n   * @return {!Long}\n   * @public\n   */\n  static getNegOne() {\n    return NEG_ONE_;\n  }\n\n  /**\n   * @return {!Long}\n   * @public\n   */\n  static getMaxValue() {\n    return MAX_VALUE_;\n  }\n\n  /**\n   * @return {!Long}\n   * @public\n   */\n  static getMinValue() {\n    return MIN_VALUE_;\n  }\n\n  /**\n   * @return {!Long}\n   * @public\n   */\n  static getTwoPwr24() {\n    return TWO_PWR_24_;\n  }\n}\n\nexports = Long;\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object<number, !Long>}\n * @private @const\n */\nconst IntCache_ = {};\n\n\n/**\n * Returns a cached long number representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Long} The corresponding Long value.\n * @private\n */\nfunction getCachedIntValue_(value) {\n  return reflect.cache(IntCache_, value, function(val) {\n    return new Long(val, val < 0 ? -1 : 0);\n  });\n}\n\n/**\n * The array of maximum values of a Long in string representation for a given\n * radix between 2 and 36, inclusive.\n * @private @const {!Array<string>}\n */\nconst MAX_VALUE_FOR_RADIX_ = [\n  '', '',  // unused\n  '111111111111111111111111111111111111111111111111111111111111111',\n  // base 2\n  '2021110011022210012102010021220101220221',  // base 3\n  '13333333333333333333333333333333',          // base 4\n  '1104332401304422434310311212',              // base 5\n  '1540241003031030222122211',                 // base 6\n  '22341010611245052052300',                   // base 7\n  '777777777777777777777',                     // base 8\n  '67404283172107811827',                      // base 9\n  '9223372036854775807',                       // base 10\n  '1728002635214590697',                       // base 11\n  '41a792678515120367',                        // base 12\n  '10b269549075433c37',                        // base 13\n  '4340724c6c71dc7a7',                         // base 14\n  '160e2ad3246366807',                         // base 15\n  '7fffffffffffffff',                          // base 16\n  '33d3d8307b214008',                          // base 17\n  '16agh595df825fa7',                          // base 18\n  'ba643dci0ffeehh',                           // base 19\n  '5cbfjia3fh26ja7',                           // base 20\n  '2heiciiie82dh97',                           // base 21\n  '1adaibb21dckfa7',                           // base 22\n  'i6k448cf4192c2',                            // base 23\n  'acd772jnc9l0l7',                            // base 24\n  '64ie1focnn5g77',                            // base 25\n  '3igoecjbmca687',                            // base 26\n  '27c48l5b37oaop',                            // base 27\n  '1bk39f3ah3dmq7',                            // base 28\n  'q1se8f0m04isb',                             // base 29\n  'hajppbc1fc207',                             // base 30\n  'bm03i95hia437',                             // base 31\n  '7vvvvvvvvvvvv',                             // base 32\n  '5hg4ck9jd4u37',                             // base 33\n  '3tdtk1v8j6tpp',                             // base 34\n  '2pijmikexrxp7',                             // base 35\n  '1y2p0ij32e8e7'                              // base 36\n];\n\n\n/**\n * The array of minimum values of a Long in string representation for a given\n * radix between 2 and 36, inclusive.\n * @private @const {!Array<string>}\n */\nconst MIN_VALUE_FOR_RADIX_ = [\n  '', '',  // unused\n  '-1000000000000000000000000000000000000000000000000000000000000000',\n  // base 2\n  '-2021110011022210012102010021220101220222',  // base 3\n  '-20000000000000000000000000000000',          // base 4\n  '-1104332401304422434310311213',              // base 5\n  '-1540241003031030222122212',                 // base 6\n  '-22341010611245052052301',                   // base 7\n  '-1000000000000000000000',                    // base 8\n  '-67404283172107811828',                      // base 9\n  '-9223372036854775808',                       // base 10\n  '-1728002635214590698',                       // base 11\n  '-41a792678515120368',                        // base 12\n  '-10b269549075433c38',                        // base 13\n  '-4340724c6c71dc7a8',                         // base 14\n  '-160e2ad3246366808',                         // base 15\n  '-8000000000000000',                          // base 16\n  '-33d3d8307b214009',                          // base 17\n  '-16agh595df825fa8',                          // base 18\n  '-ba643dci0ffeehi',                           // base 19\n  '-5cbfjia3fh26ja8',                           // base 20\n  '-2heiciiie82dh98',                           // base 21\n  '-1adaibb21dckfa8',                           // base 22\n  '-i6k448cf4192c3',                            // base 23\n  '-acd772jnc9l0l8',                            // base 24\n  '-64ie1focnn5g78',                            // base 25\n  '-3igoecjbmca688',                            // base 26\n  '-27c48l5b37oaoq',                            // base 27\n  '-1bk39f3ah3dmq8',                            // base 28\n  '-q1se8f0m04isc',                             // base 29\n  '-hajppbc1fc208',                             // base 30\n  '-bm03i95hia438',                             // base 31\n  '-8000000000000',                             // base 32\n  '-5hg4ck9jd4u38',                             // base 33\n  '-3tdtk1v8j6tpq',                             // base 34\n  '-2pijmikexrxp8',                             // base 35\n  '-1y2p0ij32e8e8'                              // base 36\n];\n\n/**\n * TODO(goktug): Replace with Number.MAX_SAFE_INTEGER when polyfil is guaranteed\n * to be removed.\n * @type {number}\n * @private @const\n */\nconst MAX_SAFE_INTEGER_ = 0x1fffffffffffff;\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function above.\n * @const {number}\n * @private\n */\nconst TWO_PWR_32_DBL_ = 0x100000000;\n\n\n/**\n * @const {number}\n * @private\n */\nconst TWO_PWR_63_DBL_ = 0x8000000000000000;\n\n\n/**\n * @private @const {!Long}\n */\nconst ZERO_ = Long.fromBits(0, 0);\n\n\n/**\n * @private @const {!Long}\n */\nconst ONE_ = Long.fromBits(1, 0);\n\n/**\n * @private @const {!Long}\n */\nconst NEG_ONE_ = Long.fromBits(-1, -1);\n\n/**\n * @private @const {!Long}\n */\nconst MAX_VALUE_ = Long.fromBits(0xFFFFFFFF, 0x7FFFFFFF);\n\n/**\n * @private @const {!Long}\n */\nconst MIN_VALUE_ = Long.fromBits(0, 0x80000000);\n\n/**\n * @private @const {!Long}\n */\nconst TWO_PWR_24_ = Long.fromBits(1 << 24, 0);\n","~:compiled-at",1623605884836,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.math.long.js\",\n\"lineCount\":411,\n\"mappings\":\"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\",\n\"sources\":[\"goog/math/long.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n/**\\n * @fileoverview Defines a Long class for representing a 64-bit two's-complement\\n * integer value, which faithfully simulates the behavior of a Java \\\"long\\\". This\\n * implementation is derived from LongLib in GWT.\\n */\\n\\ngoog.module('goog.math.Long');\\ngoog.module.declareLegacyNamespace();\\n\\nconst asserts = goog.require('goog.asserts');\\nconst reflect = goog.require('goog.reflect');\\n\\n/**\\n * Represents a 64-bit two's-complement integer, given its low and high 32-bit\\n * values as *signed* integers.  See the from* functions below for more\\n * convenient ways of constructing Longs.\\n *\\n * The internal representation of a long is the two given signed, 32-bit values.\\n * We use 32-bit pieces because these are the size of integers on which\\n * JavaScript performs bit-operations.  For operations like addition and\\n * multiplication, we split each number into 16-bit pieces, which can easily be\\n * multiplied within JavaScript's floating-point representation without overflow\\n * or change in sign.\\n *\\n * In the algorithms below, we frequently reduce the negative case to the\\n * positive case by negating the input(s) and then post-processing the result.\\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\\n * a positive number, it overflows back into a negative).  Not handling this\\n * case would often result in infinite recursion.\\n * @final\\n */\\nclass Long {\\n  /**\\n   * @param {number} low  The low (signed) 32 bits of the long.\\n   * @param {number} high  The high (signed) 32 bits of the long.\\n   */\\n  constructor(low, high) {\\n    /**\\n     * @const {number}\\n     * @private\\n     */\\n    this.low_ = low | 0;  // force into 32 signed bits.\\n\\n    /**\\n     * @const {number}\\n     * @private\\n     */\\n    this.high_ = high | 0;  // force into 32 signed bits.\\n  }\\n\\n  /** @return {number} The value, assuming it is a 32-bit integer. */\\n  toInt() {\\n    return this.low_;\\n  }\\n\\n  /**\\n   * @return {number} The closest floating-point representation to this value.\\n   */\\n  toNumber() {\\n    return this.high_ * TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();\\n  }\\n\\n  /**\\n   * @return {boolean} if can be exactly represented using number (i.e.\\n   *     abs(value) < 2^53).\\n   */\\n  isSafeInteger() {\\n    var top11Bits = this.high_ >> 21;\\n    // If top11Bits are all 0s, then the number is between [0, 2^53-1]\\n    return top11Bits == 0\\n        // If top11Bits are all 1s, then the number is between [-1, -2^53]\\n        || (top11Bits == -1\\n            // and exclude -2^53\\n            && !(this.low_ == 0 && this.high_ == (0xffe00000 | 0)));\\n  }\\n\\n  /**\\n   * @param {number=} opt_radix The radix in which the text should be written.\\n   * @return {string} The textual representation of this value.\\n   * @override\\n   */\\n  toString(opt_radix) {\\n    var radix = opt_radix || 10;\\n    if (radix < 2 || 36 < radix) {\\n      throw new Error('radix out of range: ' + radix);\\n    }\\n\\n    // We can avoid very expensive division based code path for some common\\n    // cases.\\n    if (this.isSafeInteger()) {\\n      var asNumber = this.toNumber();\\n      // Shortcutting for radix 10 (common case) to avoid boxing via toString:\\n      // https://jsperf.com/tostring-vs-vs-if\\n      return radix == 10 ? ('' + asNumber) : asNumber.toString(radix);\\n    }\\n\\n    // We need to split 64bit integer into: `a * radix**safeDigits + b` where\\n    // neither `a` nor `b` exceeds 53 bits, meaning that safeDigits can be any\\n    // number in a range: [(63 - 53) / log2(radix); 53 / log2(radix)].\\n\\n    // Other options that need to be benchmarked:\\n    //   11..16 - (radix >> 2);\\n    //   10..13 - (radix >> 3);\\n    //   10..11 - (radix >> 4);\\n    var safeDigits = 14 - (radix >> 2);\\n\\n    var radixPowSafeDigits = Math.pow(radix, safeDigits);\\n    var radixToPower =\\n        Long.fromBits(radixPowSafeDigits, radixPowSafeDigits / TWO_PWR_32_DBL_);\\n\\n    var remDiv = this.div(radixToPower);\\n    var val = Math.abs(this.subtract(remDiv.multiply(radixToPower)).toNumber());\\n    var digits = radix == 10 ? ('' + val) : val.toString(radix);\\n\\n    if (digits.length < safeDigits) {\\n      // Up to 13 leading 0s we might need to insert as the greatest safeDigits\\n      // value is 14 (for radix 2).\\n      digits = '0000000000000'.substr(digits.length - safeDigits) + digits;\\n    }\\n\\n    val = remDiv.toNumber();\\n    return (radix == 10 ? val : val.toString(radix)) + digits;\\n  }\\n\\n  /** @return {number} The high 32-bits as a signed value. */\\n  getHighBits() {\\n    return this.high_;\\n  }\\n\\n  /** @return {number} The low 32-bits as a signed value. */\\n  getLowBits() {\\n    return this.low_;\\n  }\\n\\n  /** @return {number} The low 32-bits as an unsigned value. */\\n  getLowBitsUnsigned() {\\n    // The right shifting fixes negative values in the case when\\n    // intval >= 2^31; for more details see\\n    // https://github.com/google/closure-library/pull/498\\n    return this.low_ >>> 0;\\n  }\\n\\n  /**\\n   * @return {number} Returns the number of bits needed to represent the\\n   *     absolute value of this Long.\\n   */\\n  getNumBitsAbs() {\\n    if (this.isNegative()) {\\n      if (this.equals(Long.getMinValue())) {\\n        return 64;\\n      } else {\\n        return this.negate().getNumBitsAbs();\\n      }\\n    } else {\\n      var val = this.high_ != 0 ? this.high_ : this.low_;\\n      for (var bit = 31; bit > 0; bit--) {\\n        if ((val & (1 << bit)) != 0) {\\n          break;\\n        }\\n      }\\n      return this.high_ != 0 ? bit + 33 : bit + 1;\\n    }\\n  }\\n\\n  /** @return {boolean} Whether this value is zero. */\\n  isZero() {\\n    // Check low part first as there is high chance it's not 0.\\n    return this.low_ == 0 && this.high_ == 0;\\n  }\\n\\n  /** @return {boolean} Whether this value is negative. */\\n  isNegative() {\\n    return this.high_ < 0;\\n  }\\n\\n  /** @return {boolean} Whether this value is odd. */\\n  isOdd() {\\n    return (this.low_ & 1) == 1;\\n  }\\n\\n  /**\\n   * @param {?Long} other Long to compare against.\\n   * @return {boolean} Whether this Long equals the other.\\n   */\\n  equals(other) {\\n    // Compare low parts first as there is higher chance they are different.\\n    return (this.low_ == other.low_) && (this.high_ == other.high_);\\n  }\\n\\n  /**\\n   * @param {?Long} other Long to compare against.\\n   * @return {boolean} Whether this Long does not equal the other.\\n   */\\n  notEquals(other) {\\n    return !this.equals(other);\\n  }\\n\\n  /**\\n   * @param {?Long} other Long to compare against.\\n   * @return {boolean} Whether this Long is less than the other.\\n   */\\n  lessThan(other) {\\n    return this.compare(other) < 0;\\n  }\\n\\n  /**\\n   * @param {?Long} other Long to compare against.\\n   * @return {boolean} Whether this Long is less than or equal to the other.\\n   */\\n  lessThanOrEqual(other) {\\n    return this.compare(other) <= 0;\\n  }\\n\\n  /**\\n   * @param {?Long} other Long to compare against.\\n   * @return {boolean} Whether this Long is greater than the other.\\n   */\\n  greaterThan(other) {\\n    return this.compare(other) > 0;\\n  }\\n\\n  /**\\n   * @param {?Long} other Long to compare against.\\n   * @return {boolean} Whether this Long is greater than or equal to the other.\\n   */\\n  greaterThanOrEqual(other) {\\n    return this.compare(other) >= 0;\\n  }\\n\\n  /**\\n   * Compares this Long with the given one.\\n   * @param {?Long} other Long to compare against.\\n   * @return {number} 0 if they are the same, 1 if the this is greater, and -1\\n   *     if the given one is greater.\\n   */\\n  compare(other) {\\n    if (this.high_ == other.high_) {\\n      if (this.low_ == other.low_) {\\n        return 0;\\n      }\\n      return this.getLowBitsUnsigned() > other.getLowBitsUnsigned() ? 1 : -1;\\n    }\\n    return this.high_ > other.high_ ? 1 : -1;\\n  }\\n\\n  /** @return {!Long} The negation of this value. */\\n  negate() {\\n    var negLow = (~this.low_ + 1) | 0;\\n    var overflowFromLow = !negLow;\\n    var negHigh = (~this.high_ + overflowFromLow) | 0;\\n    return Long.fromBits(negLow, negHigh);\\n  }\\n\\n  /**\\n   * Returns the sum of this and the given Long.\\n   * @param {?Long} other Long to add to this one.\\n   * @return {!Long} The sum of this and the given Long.\\n   */\\n  add(other) {\\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\\n\\n    var a48 = this.high_ >>> 16;\\n    var a32 = this.high_ & 0xFFFF;\\n    var a16 = this.low_ >>> 16;\\n    var a00 = this.low_ & 0xFFFF;\\n\\n    var b48 = other.high_ >>> 16;\\n    var b32 = other.high_ & 0xFFFF;\\n    var b16 = other.low_ >>> 16;\\n    var b00 = other.low_ & 0xFFFF;\\n\\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\\n    c00 += a00 + b00;\\n    c16 += c00 >>> 16;\\n    c00 &= 0xFFFF;\\n    c16 += a16 + b16;\\n    c32 += c16 >>> 16;\\n    c16 &= 0xFFFF;\\n    c32 += a32 + b32;\\n    c48 += c32 >>> 16;\\n    c32 &= 0xFFFF;\\n    c48 += a48 + b48;\\n    c48 &= 0xFFFF;\\n    return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\\n  }\\n\\n  /**\\n   * Returns the difference of this and the given Long.\\n   * @param {?Long} other Long to subtract from this.\\n   * @return {!Long} The difference of this and the given Long.\\n   */\\n  subtract(other) {\\n    return this.add(other.negate());\\n  }\\n\\n  /**\\n   * Returns the product of this and the given long.\\n   * @param {?Long} other Long to multiply with this.\\n   * @return {!Long} The product of this and the other.\\n   */\\n  multiply(other) {\\n    if (this.isZero()) {\\n      return this;\\n    }\\n    if (other.isZero()) {\\n      return other;\\n    }\\n\\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\\n    // We can skip products that would overflow.\\n\\n    var a48 = this.high_ >>> 16;\\n    var a32 = this.high_ & 0xFFFF;\\n    var a16 = this.low_ >>> 16;\\n    var a00 = this.low_ & 0xFFFF;\\n\\n    var b48 = other.high_ >>> 16;\\n    var b32 = other.high_ & 0xFFFF;\\n    var b16 = other.low_ >>> 16;\\n    var b00 = other.low_ & 0xFFFF;\\n\\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\\n    c00 += a00 * b00;\\n    c16 += c00 >>> 16;\\n    c00 &= 0xFFFF;\\n    c16 += a16 * b00;\\n    c32 += c16 >>> 16;\\n    c16 &= 0xFFFF;\\n    c16 += a00 * b16;\\n    c32 += c16 >>> 16;\\n    c16 &= 0xFFFF;\\n    c32 += a32 * b00;\\n    c48 += c32 >>> 16;\\n    c32 &= 0xFFFF;\\n    c32 += a16 * b16;\\n    c48 += c32 >>> 16;\\n    c32 &= 0xFFFF;\\n    c32 += a00 * b32;\\n    c48 += c32 >>> 16;\\n    c32 &= 0xFFFF;\\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\\n    c48 &= 0xFFFF;\\n    return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\\n  }\\n\\n  /**\\n   * Returns this Long divided by the given one.\\n   * @param {?Long} other Long by which to divide.\\n   * @return {!Long} This Long divided by the given one.\\n   */\\n  div(other) {\\n    if (other.isZero()) {\\n      throw new Error('division by zero');\\n    }\\n    if (this.isNegative()) {\\n      if (this.equals(Long.getMinValue())) {\\n        if (other.equals(Long.getOne()) || other.equals(Long.getNegOne())) {\\n          return Long.getMinValue();  // recall -MIN_VALUE == MIN_VALUE\\n        }\\n        if (other.equals(Long.getMinValue())) {\\n          return Long.getOne();\\n        }\\n        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\\n        var halfThis = this.shiftRight(1);\\n        var approx = halfThis.div(other).shiftLeft(1);\\n        if (approx.equals(Long.getZero())) {\\n          return other.isNegative() ? Long.getOne() : Long.getNegOne();\\n        }\\n        var rem = this.subtract(other.multiply(approx));\\n        var result = approx.add(rem.div(other));\\n        return result;\\n      }\\n      if (other.isNegative()) {\\n        return this.negate().div(other.negate());\\n      }\\n      return this.negate().div(other).negate();\\n    }\\n    if (this.isZero()) {\\n      return Long.getZero();\\n    }\\n    if (other.isNegative()) {\\n      if (other.equals(Long.getMinValue())) {\\n        return Long.getZero();\\n      }\\n      return this.div(other.negate()).negate();\\n    }\\n\\n    // Repeat the following until the remainder is less than other:  find a\\n    // floating-point that approximates remainder / other *from below*, add this\\n    // into the result, and subtract it from the remainder.  It is critical that\\n    // the approximate value is less than or equal to the real value so that the\\n    // remainder never becomes negative.\\n    var res = Long.getZero();\\n    var rem = this;\\n    while (rem.greaterThanOrEqual(other)) {\\n      // Approximate the result of division. This may be a little greater or\\n      // smaller than the actual value.\\n      var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\\n\\n      // We will tweak the approximate result by changing it in the 48-th digit\\n      // or the smallest non-fractional digit, whichever is larger.\\n      var log2 = Math.ceil(Math.log(approx) / Math.LN2);\\n      var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\\n\\n      // Decrease the approximation until it is smaller than the remainder. Note\\n      // that if it is too large, the product overflows and is negative.\\n      var approxRes = Long.fromNumber(approx);\\n      var approxRem = approxRes.multiply(other);\\n      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\\n        approx -= delta;\\n        approxRes = Long.fromNumber(approx);\\n        approxRem = approxRes.multiply(other);\\n      }\\n\\n      // We know the answer can't be zero... and actually, zero would cause\\n      // infinite recursion since we would make no progress.\\n      if (approxRes.isZero()) {\\n        approxRes = Long.getOne();\\n      }\\n\\n      res = res.add(approxRes);\\n      rem = rem.subtract(approxRem);\\n    }\\n    return res;\\n  }\\n\\n  /**\\n   * Returns this Long modulo the given one.\\n   * @param {?Long} other Long by which to mod.\\n   * @return {!Long} This Long modulo the given one.\\n   */\\n  modulo(other) {\\n    return this.subtract(this.div(other).multiply(other));\\n  }\\n\\n  /** @return {!Long} The bitwise-NOT of this value. */\\n  not() {\\n    return Long.fromBits(~this.low_, ~this.high_);\\n  }\\n\\n  /**\\n   * Returns the bitwise-AND of this Long and the given one.\\n   * @param {?Long} other The Long with which to AND.\\n   * @return {!Long} The bitwise-AND of this and the other.\\n   */\\n  and(other) {\\n    return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);\\n  }\\n\\n  /**\\n   * Returns the bitwise-OR of this Long and the given one.\\n   * @param {?Long} other The Long with which to OR.\\n   * @return {!Long} The bitwise-OR of this and the other.\\n   */\\n  or(other) {\\n    return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);\\n  }\\n\\n  /**\\n   * Returns the bitwise-XOR of this Long and the given one.\\n   * @param {?Long} other The Long with which to XOR.\\n   * @return {!Long} The bitwise-XOR of this and the other.\\n   */\\n  xor(other) {\\n    return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);\\n  }\\n\\n  /**\\n   * Returns this Long with bits shifted to the left by the given amount.\\n   * @param {number} numBits The number of bits by which to shift.\\n   * @return {!Long} This shifted to the left by the given amount.\\n   */\\n  shiftLeft(numBits) {\\n    numBits &= 63;\\n    if (numBits == 0) {\\n      return this;\\n    } else {\\n      var low = this.low_;\\n      if (numBits < 32) {\\n        var high = this.high_;\\n        return Long.fromBits(\\n            low << numBits, (high << numBits) | (low >>> (32 - numBits)));\\n      } else {\\n        return Long.fromBits(0, low << (numBits - 32));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Returns this Long with bits shifted to the right by the given amount.\\n   * The new leading bits match the current sign bit.\\n   * @param {number} numBits The number of bits by which to shift.\\n   * @return {!Long} This shifted to the right by the given amount.\\n   */\\n  shiftRight(numBits) {\\n    numBits &= 63;\\n    if (numBits == 0) {\\n      return this;\\n    } else {\\n      var high = this.high_;\\n      if (numBits < 32) {\\n        var low = this.low_;\\n        return Long.fromBits(\\n            (low >>> numBits) | (high << (32 - numBits)), high >> numBits);\\n      } else {\\n        return Long.fromBits(high >> (numBits - 32), high >= 0 ? 0 : -1);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Returns this Long with bits shifted to the right by the given amount, with\\n   * zeros placed into the new leading bits.\\n   * @param {number} numBits The number of bits by which to shift.\\n   * @return {!Long} This shifted to the right by the given amount,\\n   *     with zeros placed into the new leading bits.\\n   */\\n  shiftRightUnsigned(numBits) {\\n    numBits &= 63;\\n    if (numBits == 0) {\\n      return this;\\n    } else {\\n      var high = this.high_;\\n      if (numBits < 32) {\\n        var low = this.low_;\\n        return Long.fromBits(\\n            (low >>> numBits) | (high << (32 - numBits)), high >>> numBits);\\n      } else if (numBits == 32) {\\n        return Long.fromBits(high, 0);\\n      } else {\\n        return Long.fromBits(high >>> (numBits - 32), 0);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Returns a Long representing the given (32-bit) integer value.\\n   * @param {number} value The 32-bit integer in question.\\n   * @return {!Long} The corresponding Long value.\\n   */\\n  static fromInt(value) {\\n    var intValue = value | 0;\\n    asserts.assert(value === intValue, 'value should be a 32-bit integer');\\n\\n    if (-128 <= intValue && intValue < 128) {\\n      return getCachedIntValue_(intValue);\\n    } else {\\n      return new Long(intValue, intValue < 0 ? -1 : 0);\\n    }\\n  }\\n\\n  /**\\n   * Returns a Long representing the given value.\\n   * NaN will be returned as zero. Infinity is converted to max value and\\n   * -Infinity to min value.\\n   * @param {number} value The number in question.\\n   * @return {!Long} The corresponding Long value.\\n   */\\n  static fromNumber(value) {\\n    if (value > 0) {\\n      if (value >= TWO_PWR_63_DBL_) {\\n        return Long.getMaxValue();\\n      }\\n      return new Long(value, value / TWO_PWR_32_DBL_);\\n    } else if (value < 0) {\\n      if (value <= -TWO_PWR_63_DBL_) {\\n        return Long.getMinValue();\\n      }\\n      return new Long(-value, -value / TWO_PWR_32_DBL_).negate();\\n    } else {\\n      // NaN or 0.\\n      return Long.getZero();\\n    }\\n  }\\n\\n  /**\\n   * Returns a Long representing the 64-bit integer that comes by concatenating\\n   * the given high and low bits.  Each is assumed to use 32 bits.\\n   * @param {number} lowBits The low 32-bits.\\n   * @param {number} highBits The high 32-bits.\\n   * @return {!Long} The corresponding Long value.\\n   */\\n  static fromBits(lowBits, highBits) {\\n    return new Long(lowBits, highBits);\\n  }\\n\\n  /**\\n   * Returns a Long representation of the given string, written using the given\\n   * radix.\\n   * @param {string} str The textual representation of the Long.\\n   * @param {number=} opt_radix The radix in which the text is written.\\n   * @return {!Long} The corresponding Long value.\\n   */\\n  static fromString(str, opt_radix) {\\n    if (str.charAt(0) == '-') {\\n      return Long.fromString(str.substring(1), opt_radix).negate();\\n    }\\n\\n    // We can avoid very expensive multiply based code path for some common\\n    // cases.\\n    var numberValue = parseInt(str, opt_radix || 10);\\n    if (numberValue <= MAX_SAFE_INTEGER_) {\\n      return new Long(\\n          (numberValue % TWO_PWR_32_DBL_) | 0,\\n          (numberValue / TWO_PWR_32_DBL_) | 0);\\n    }\\n\\n    if (str.length == 0) {\\n      throw new Error('number format error: empty string');\\n    }\\n    if (str.indexOf('-') >= 0) {\\n      throw new Error('number format error: interior \\\"-\\\" character: ' + str);\\n    }\\n\\n    var radix = opt_radix || 10;\\n    if (radix < 2 || 36 < radix) {\\n      throw new Error('radix out of range: ' + radix);\\n    }\\n\\n    // Do several (8) digits each time through the loop, so as to\\n    // minimize the calls to the very expensive emulated multiply.\\n    var radixToPower = Long.fromNumber(Math.pow(radix, 8));\\n\\n    var result = Long.getZero();\\n    for (var i = 0; i < str.length; i += 8) {\\n      var size = Math.min(8, str.length - i);\\n      var value = parseInt(str.substring(i, i + size), radix);\\n      if (size < 8) {\\n        var power = Long.fromNumber(Math.pow(radix, size));\\n        result = result.multiply(power).add(Long.fromNumber(value));\\n      } else {\\n        result = result.multiply(radixToPower);\\n        result = result.add(Long.fromNumber(value));\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * Returns the boolean value of whether the input string is within a Long's\\n   * range. Assumes an input string containing only numeric characters with an\\n   * optional preceding '-'.\\n   * @param {string} str The textual representation of the Long.\\n   * @param {number=} opt_radix The radix in which the text is written.\\n   * @return {boolean} Whether the string is within the range of a Long.\\n   */\\n  static isStringInRange(str, opt_radix) {\\n    var radix = opt_radix || 10;\\n    if (radix < 2 || 36 < radix) {\\n      throw new Error('radix out of range: ' + radix);\\n    }\\n\\n    var extremeValue = (str.charAt(0) == '-') ? MIN_VALUE_FOR_RADIX_[radix] :\\n                                                MAX_VALUE_FOR_RADIX_[radix];\\n\\n    if (str.length < extremeValue.length) {\\n      return true;\\n    } else if (str.length == extremeValue.length && str <= extremeValue) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @return {!Long}\\n   * @public\\n   */\\n  static getZero() {\\n    return ZERO_;\\n  }\\n\\n  /**\\n   * @return {!Long}\\n   * @public\\n   */\\n  static getOne() {\\n    return ONE_;\\n  }\\n\\n  /**\\n   * @return {!Long}\\n   * @public\\n   */\\n  static getNegOne() {\\n    return NEG_ONE_;\\n  }\\n\\n  /**\\n   * @return {!Long}\\n   * @public\\n   */\\n  static getMaxValue() {\\n    return MAX_VALUE_;\\n  }\\n\\n  /**\\n   * @return {!Long}\\n   * @public\\n   */\\n  static getMinValue() {\\n    return MIN_VALUE_;\\n  }\\n\\n  /**\\n   * @return {!Long}\\n   * @public\\n   */\\n  static getTwoPwr24() {\\n    return TWO_PWR_24_;\\n  }\\n}\\n\\nexports = Long;\\n\\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\\n// from* methods on which they depend.\\n\\n\\n/**\\n * A cache of the Long representations of small integer values.\\n * @type {!Object<number, !Long>}\\n * @private @const\\n */\\nconst IntCache_ = {};\\n\\n\\n/**\\n * Returns a cached long number representing the given (32-bit) integer value.\\n * @param {number} value The 32-bit integer in question.\\n * @return {!Long} The corresponding Long value.\\n * @private\\n */\\nfunction getCachedIntValue_(value) {\\n  return reflect.cache(IntCache_, value, function(val) {\\n    return new Long(val, val < 0 ? -1 : 0);\\n  });\\n}\\n\\n/**\\n * The array of maximum values of a Long in string representation for a given\\n * radix between 2 and 36, inclusive.\\n * @private @const {!Array<string>}\\n */\\nconst MAX_VALUE_FOR_RADIX_ = [\\n  '', '',  // unused\\n  '111111111111111111111111111111111111111111111111111111111111111',\\n  // base 2\\n  '2021110011022210012102010021220101220221',  // base 3\\n  '13333333333333333333333333333333',          // base 4\\n  '1104332401304422434310311212',              // base 5\\n  '1540241003031030222122211',                 // base 6\\n  '22341010611245052052300',                   // base 7\\n  '777777777777777777777',                     // base 8\\n  '67404283172107811827',                      // base 9\\n  '9223372036854775807',                       // base 10\\n  '1728002635214590697',                       // base 11\\n  '41a792678515120367',                        // base 12\\n  '10b269549075433c37',                        // base 13\\n  '4340724c6c71dc7a7',                         // base 14\\n  '160e2ad3246366807',                         // base 15\\n  '7fffffffffffffff',                          // base 16\\n  '33d3d8307b214008',                          // base 17\\n  '16agh595df825fa7',                          // base 18\\n  'ba643dci0ffeehh',                           // base 19\\n  '5cbfjia3fh26ja7',                           // base 20\\n  '2heiciiie82dh97',                           // base 21\\n  '1adaibb21dckfa7',                           // base 22\\n  'i6k448cf4192c2',                            // base 23\\n  'acd772jnc9l0l7',                            // base 24\\n  '64ie1focnn5g77',                            // base 25\\n  '3igoecjbmca687',                            // base 26\\n  '27c48l5b37oaop',                            // base 27\\n  '1bk39f3ah3dmq7',                            // base 28\\n  'q1se8f0m04isb',                             // base 29\\n  'hajppbc1fc207',                             // base 30\\n  'bm03i95hia437',                             // base 31\\n  '7vvvvvvvvvvvv',                             // base 32\\n  '5hg4ck9jd4u37',                             // base 33\\n  '3tdtk1v8j6tpp',                             // base 34\\n  '2pijmikexrxp7',                             // base 35\\n  '1y2p0ij32e8e7'                              // base 36\\n];\\n\\n\\n/**\\n * The array of minimum values of a Long in string representation for a given\\n * radix between 2 and 36, inclusive.\\n * @private @const {!Array<string>}\\n */\\nconst MIN_VALUE_FOR_RADIX_ = [\\n  '', '',  // unused\\n  '-1000000000000000000000000000000000000000000000000000000000000000',\\n  // base 2\\n  '-2021110011022210012102010021220101220222',  // base 3\\n  '-20000000000000000000000000000000',          // base 4\\n  '-1104332401304422434310311213',              // base 5\\n  '-1540241003031030222122212',                 // base 6\\n  '-22341010611245052052301',                   // base 7\\n  '-1000000000000000000000',                    // base 8\\n  '-67404283172107811828',                      // base 9\\n  '-9223372036854775808',                       // base 10\\n  '-1728002635214590698',                       // base 11\\n  '-41a792678515120368',                        // base 12\\n  '-10b269549075433c38',                        // base 13\\n  '-4340724c6c71dc7a8',                         // base 14\\n  '-160e2ad3246366808',                         // base 15\\n  '-8000000000000000',                          // base 16\\n  '-33d3d8307b214009',                          // base 17\\n  '-16agh595df825fa8',                          // base 18\\n  '-ba643dci0ffeehi',                           // base 19\\n  '-5cbfjia3fh26ja8',                           // base 20\\n  '-2heiciiie82dh98',                           // base 21\\n  '-1adaibb21dckfa8',                           // base 22\\n  '-i6k448cf4192c3',                            // base 23\\n  '-acd772jnc9l0l8',                            // base 24\\n  '-64ie1focnn5g78',                            // base 25\\n  '-3igoecjbmca688',                            // base 26\\n  '-27c48l5b37oaoq',                            // base 27\\n  '-1bk39f3ah3dmq8',                            // base 28\\n  '-q1se8f0m04isc',                             // base 29\\n  '-hajppbc1fc208',                             // base 30\\n  '-bm03i95hia438',                             // base 31\\n  '-8000000000000',                             // base 32\\n  '-5hg4ck9jd4u38',                             // base 33\\n  '-3tdtk1v8j6tpq',                             // base 34\\n  '-2pijmikexrxp8',                             // base 35\\n  '-1y2p0ij32e8e8'                              // base 36\\n];\\n\\n/**\\n * TODO(goktug): Replace with Number.MAX_SAFE_INTEGER when polyfil is guaranteed\\n * to be removed.\\n * @type {number}\\n * @private @const\\n */\\nconst MAX_SAFE_INTEGER_ = 0x1fffffffffffff;\\n\\n// NOTE: the compiler should inline these constant values below and then remove\\n// these variables, so there should be no runtime penalty for these.\\n\\n/**\\n * Number used repeated below in calculations.  This must appear before the\\n * first call to any from* function above.\\n * @const {number}\\n * @private\\n */\\nconst TWO_PWR_32_DBL_ = 0x100000000;\\n\\n\\n/**\\n * @const {number}\\n * @private\\n */\\nconst TWO_PWR_63_DBL_ = 0x8000000000000000;\\n\\n\\n/**\\n * @private @const {!Long}\\n */\\nconst ZERO_ = Long.fromBits(0, 0);\\n\\n\\n/**\\n * @private @const {!Long}\\n */\\nconst ONE_ = Long.fromBits(1, 0);\\n\\n/**\\n * @private @const {!Long}\\n */\\nconst NEG_ONE_ = Long.fromBits(-1, -1);\\n\\n/**\\n * @private @const {!Long}\\n */\\nconst MAX_VALUE_ = Long.fromBits(0xFFFFFFFF, 0x7FFFFFFF);\\n\\n/**\\n * @private @const {!Long}\\n */\\nconst MIN_VALUE_ = Long.fromBits(0, 0x80000000);\\n\\n/**\\n * @private @const {!Long}\\n */\\nconst TWO_PWR_24_ = Long.fromBits(1 << 24, 0);\\n\"],\n\"names\":[\"goog\",\"module\",\"declareLegacyNamespace\",\"asserts\",\"require\",\"reflect\",\"Long\",\"constructor\",\"low\",\"high\",\"low_\",\"high_\",\"toInt\",\"toNumber\",\"TWO_PWR_32_DBL_\",\"getLowBitsUnsigned\",\"isSafeInteger\",\"top11Bits\",\"toString\",\"opt_radix\",\"radix\",\"Error\",\"asNumber\",\"safeDigits\",\"radixPowSafeDigits\",\"Math\",\"pow\",\"radixToPower\",\"fromBits\",\"remDiv\",\"div\",\"val\",\"abs\",\"subtract\",\"multiply\",\"digits\",\"length\",\"substr\",\"getHighBits\",\"getLowBits\",\"getNumBitsAbs\",\"isNegative\",\"equals\",\"getMinValue\",\"negate\",\"bit\",\"isZero\",\"isOdd\",\"other\",\"notEquals\",\"lessThan\",\"compare\",\"lessThanOrEqual\",\"greaterThan\",\"greaterThanOrEqual\",\"negLow\",\"overflowFromLow\",\"negHigh\",\"add\",\"a48\",\"a32\",\"a16\",\"a00\",\"b48\",\"b32\",\"b16\",\"b00\",\"c48\",\"c32\",\"c16\",\"c00\",\"getOne\",\"getNegOne\",\"halfThis\",\"shiftRight\",\"approx\",\"shiftLeft\",\"getZero\",\"rem\",\"result\",\"res\",\"max\",\"floor\",\"log2\",\"ceil\",\"log\",\"LN2\",\"delta\",\"approxRes\",\"fromNumber\",\"approxRem\",\"modulo\",\"not\",\"and\",\"or\",\"xor\",\"numBits\",\"shiftRightUnsigned\",\"fromInt\",\"value\",\"intValue\",\"assert\",\"getCachedIntValue_\",\"TWO_PWR_63_DBL_\",\"getMaxValue\",\"lowBits\",\"highBits\",\"fromString\",\"str\",\"charAt\",\"substring\",\"numberValue\",\"parseInt\",\"MAX_SAFE_INTEGER_\",\"indexOf\",\"i\",\"size\",\"min\",\"power\",\"isStringInRange\",\"extremeValue\",\"MIN_VALUE_FOR_RADIX_\",\"MAX_VALUE_FOR_RADIX_\",\"ZERO_\",\"ONE_\",\"NEG_ONE_\",\"MAX_VALUE_\",\"MIN_VALUE_\",\"getTwoPwr24\",\"TWO_PWR_24_\",\"exports\",\"IntCache_\",\"cache\"]\n}\n"]