["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/dom/dom.js"],"~:js","goog.provide(\"goog.dom\");\ngoog.provide(\"goog.dom.Appendable\");\ngoog.provide(\"goog.dom.DomHelper\");\ngoog.require(\"goog.array\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.dom.BrowserFeature\");\ngoog.require(\"goog.dom.NodeType\");\ngoog.require(\"goog.dom.TagName\");\ngoog.require(\"goog.dom.safe\");\ngoog.require(\"goog.html.SafeHtml\");\ngoog.require(\"goog.html.uncheckedconversions\");\ngoog.require(\"goog.math.Coordinate\");\ngoog.require(\"goog.math.Size\");\ngoog.require(\"goog.object\");\ngoog.require(\"goog.string\");\ngoog.require(\"goog.string.Const\");\ngoog.require(\"goog.string.Unicode\");\ngoog.require(\"goog.userAgent\");\ngoog.dom.ASSUME_QUIRKS_MODE = goog.define(\"goog.dom.ASSUME_QUIRKS_MODE\", false);\ngoog.dom.ASSUME_STANDARDS_MODE = goog.define(\"goog.dom.ASSUME_STANDARDS_MODE\", false);\ngoog.dom.COMPAT_MODE_KNOWN_ = goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;\ngoog.dom.getDomHelper = function(opt_element) {\n  return opt_element ? new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) : goog.dom.defaultDomHelper_ || (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper);\n};\ngoog.dom.defaultDomHelper_;\ngoog.dom.getDocument = function() {\n  return document;\n};\ngoog.dom.getElement = function(element) {\n  return goog.dom.getElementHelper_(document, element);\n};\ngoog.dom.getElementHelper_ = function(doc, element) {\n  return typeof element === \"string\" ? doc.getElementById(element) : element;\n};\ngoog.dom.getRequiredElement = function(id) {\n  return goog.dom.getRequiredElementHelper_(document, id);\n};\ngoog.dom.getRequiredElementHelper_ = function(doc, id) {\n  goog.asserts.assertString(id);\n  var element = goog.dom.getElementHelper_(doc, id);\n  element = goog.asserts.assertElement(element, \"No element found with id: \" + id);\n  return element;\n};\ngoog.dom.$ = goog.dom.getElement;\ngoog.dom.getElementsByTagName = function(tagName, opt_parent) {\n  var parent = opt_parent || document;\n  return parent.getElementsByTagName(String(tagName));\n};\ngoog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\n  return goog.dom.getElementsByTagNameAndClass_(document, opt_tag, opt_class, opt_el);\n};\ngoog.dom.getElementByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\n  return goog.dom.getElementByTagNameAndClass_(document, opt_tag, opt_class, opt_el);\n};\ngoog.dom.getElementsByClass = function(className, opt_el) {\n  var parent = opt_el || document;\n  if (goog.dom.canUseQuerySelector_(parent)) {\n    return parent.querySelectorAll(\".\" + className);\n  }\n  return goog.dom.getElementsByTagNameAndClass_(document, \"*\", className, opt_el);\n};\ngoog.dom.getElementByClass = function(className, opt_el) {\n  var parent = opt_el || document;\n  var retVal = null;\n  if (parent.getElementsByClassName) {\n    retVal = parent.getElementsByClassName(className)[0];\n  } else {\n    retVal = goog.dom.getElementByTagNameAndClass_(document, \"*\", className, opt_el);\n  }\n  return retVal || null;\n};\ngoog.dom.getRequiredElementByClass = function(className, opt_root) {\n  var retValue = goog.dom.getElementByClass(className, opt_root);\n  return goog.asserts.assert(retValue, \"No element found with className: \" + className);\n};\ngoog.dom.canUseQuerySelector_ = function(parent) {\n  return !!(parent.querySelectorAll && parent.querySelector);\n};\ngoog.dom.getElementsByTagNameAndClass_ = function(doc, opt_tag, opt_class, opt_el) {\n  var parent = opt_el || doc;\n  var tagName = opt_tag && opt_tag != \"*\" ? String(opt_tag).toUpperCase() : \"\";\n  if (goog.dom.canUseQuerySelector_(parent) && (tagName || opt_class)) {\n    var query = tagName + (opt_class ? \".\" + opt_class : \"\");\n    return parent.querySelectorAll(query);\n  }\n  if (opt_class && parent.getElementsByClassName) {\n    var els = parent.getElementsByClassName(opt_class);\n    if (tagName) {\n      var arrayLike = {};\n      var len = 0;\n      for (var i = 0, el; el = els[i]; i++) {\n        if (tagName == el.nodeName) {\n          arrayLike[len++] = el;\n        }\n      }\n      arrayLike.length = len;\n      return arrayLike;\n    } else {\n      return els;\n    }\n  }\n  var els = parent.getElementsByTagName(tagName || \"*\");\n  if (opt_class) {\n    var arrayLike = {};\n    var len = 0;\n    for (var i = 0, el; el = els[i]; i++) {\n      var className = el.className;\n      if (typeof className.split == \"function\" && goog.array.contains(className.split(/\\s+/), opt_class)) {\n        arrayLike[len++] = el;\n      }\n    }\n    arrayLike.length = len;\n    return arrayLike;\n  } else {\n    return els;\n  }\n};\ngoog.dom.getElementByTagNameAndClass_ = function(doc, opt_tag, opt_class, opt_el) {\n  var parent = opt_el || doc;\n  var tag = opt_tag && opt_tag != \"*\" ? String(opt_tag).toUpperCase() : \"\";\n  if (goog.dom.canUseQuerySelector_(parent) && (tag || opt_class)) {\n    return parent.querySelector(tag + (opt_class ? \".\" + opt_class : \"\"));\n  }\n  var elements = goog.dom.getElementsByTagNameAndClass_(doc, opt_tag, opt_class, opt_el);\n  return elements[0] || null;\n};\ngoog.dom.$$ = goog.dom.getElementsByTagNameAndClass;\ngoog.dom.setProperties = function(element, properties) {\n  goog.object.forEach(properties, function(val, key) {\n    if (val && typeof val == \"object\" && val.implementsGoogStringTypedString) {\n      val = val.getTypedStringValue();\n    }\n    if (key == \"style\") {\n      element.style.cssText = val;\n    } else {\n      if (key == \"class\") {\n        element.className = val;\n      } else {\n        if (key == \"for\") {\n          element.htmlFor = val;\n        } else {\n          if (goog.dom.DIRECT_ATTRIBUTE_MAP_.hasOwnProperty(key)) {\n            element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);\n          } else {\n            if (goog.string.startsWith(key, \"aria-\") || goog.string.startsWith(key, \"data-\")) {\n              element.setAttribute(key, val);\n            } else {\n              element[key] = val;\n            }\n          }\n        }\n      }\n    }\n  });\n};\ngoog.dom.DIRECT_ATTRIBUTE_MAP_ = {\"cellpadding\":\"cellPadding\", \"cellspacing\":\"cellSpacing\", \"colspan\":\"colSpan\", \"frameborder\":\"frameBorder\", \"height\":\"height\", \"maxlength\":\"maxLength\", \"nonce\":\"nonce\", \"role\":\"role\", \"rowspan\":\"rowSpan\", \"type\":\"type\", \"usemap\":\"useMap\", \"valign\":\"vAlign\", \"width\":\"width\"};\ngoog.dom.getViewportSize = function(opt_window) {\n  return goog.dom.getViewportSize_(opt_window || window);\n};\ngoog.dom.getViewportSize_ = function(win) {\n  var doc = win.document;\n  var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;\n  return new goog.math.Size(el.clientWidth, el.clientHeight);\n};\ngoog.dom.getDocumentHeight = function() {\n  return goog.dom.getDocumentHeight_(window);\n};\ngoog.dom.getDocumentHeightForWindow = function(win) {\n  return goog.dom.getDocumentHeight_(win);\n};\ngoog.dom.getDocumentHeight_ = function(win) {\n  var doc = win.document;\n  var height = 0;\n  if (doc) {\n    var body = doc.body;\n    var docEl = doc.documentElement;\n    if (!(docEl && body)) {\n      return 0;\n    }\n    var vh = goog.dom.getViewportSize_(win).height;\n    if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {\n      height = docEl.scrollHeight != vh ? docEl.scrollHeight : docEl.offsetHeight;\n    } else {\n      var sh = docEl.scrollHeight;\n      var oh = docEl.offsetHeight;\n      if (docEl.clientHeight != oh) {\n        sh = body.scrollHeight;\n        oh = body.offsetHeight;\n      }\n      if (sh > vh) {\n        height = sh > oh ? sh : oh;\n      } else {\n        height = sh < oh ? sh : oh;\n      }\n    }\n  }\n  return height;\n};\ngoog.dom.getPageScroll = function(opt_window) {\n  var win = opt_window || goog.global || window;\n  return goog.dom.getDomHelper(win.document).getDocumentScroll();\n};\ngoog.dom.getDocumentScroll = function() {\n  return goog.dom.getDocumentScroll_(document);\n};\ngoog.dom.getDocumentScroll_ = function(doc) {\n  var el = goog.dom.getDocumentScrollElement_(doc);\n  var win = goog.dom.getWindow_(doc);\n  if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher(\"10\") && win.pageYOffset != el.scrollTop) {\n    return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);\n  }\n  return new goog.math.Coordinate(win.pageXOffset || el.scrollLeft, win.pageYOffset || el.scrollTop);\n};\ngoog.dom.getDocumentScrollElement = function() {\n  return goog.dom.getDocumentScrollElement_(document);\n};\ngoog.dom.getDocumentScrollElement_ = function(doc) {\n  if (doc.scrollingElement) {\n    return doc.scrollingElement;\n  }\n  if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) {\n    return doc.documentElement;\n  }\n  return doc.body || doc.documentElement;\n};\ngoog.dom.getWindow = function(opt_doc) {\n  return opt_doc ? goog.dom.getWindow_(opt_doc) : window;\n};\ngoog.dom.getWindow_ = function(doc) {\n  return doc.parentWindow || doc.defaultView;\n};\ngoog.dom.createDom = function(tagName, opt_attributes, var_args) {\n  return goog.dom.createDom_(document, arguments);\n};\ngoog.dom.createDom_ = function(doc, args) {\n  var tagName = String(args[0]);\n  var attributes = args[1];\n  if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes && (attributes.name || attributes.type)) {\n    var tagNameArr = [\"\\x3c\", tagName];\n    if (attributes.name) {\n      tagNameArr.push(' name\\x3d\"', goog.string.htmlEscape(attributes.name), '\"');\n    }\n    if (attributes.type) {\n      tagNameArr.push(' type\\x3d\"', goog.string.htmlEscape(attributes.type), '\"');\n      var clone = {};\n      goog.object.extend(clone, attributes);\n      delete clone[\"type\"];\n      attributes = clone;\n    }\n    tagNameArr.push(\"\\x3e\");\n    tagName = tagNameArr.join(\"\");\n  }\n  var element = goog.dom.createElement_(doc, tagName);\n  if (attributes) {\n    if (typeof attributes === \"string\") {\n      element.className = attributes;\n    } else {\n      if (Array.isArray(attributes)) {\n        element.className = attributes.join(\" \");\n      } else {\n        goog.dom.setProperties(element, attributes);\n      }\n    }\n  }\n  if (args.length > 2) {\n    goog.dom.append_(doc, element, args, 2);\n  }\n  return element;\n};\ngoog.dom.append_ = function(doc, parent, args, startIndex) {\n  function childHandler(child) {\n    if (child) {\n      parent.appendChild(typeof child === \"string\" ? doc.createTextNode(child) : child);\n    }\n  }\n  for (var i = startIndex; i < args.length; i++) {\n    var arg = args[i];\n    if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {\n      goog.array.forEach(goog.dom.isNodeList(arg) ? goog.array.toArray(arg) : arg, childHandler);\n    } else {\n      childHandler(arg);\n    }\n  }\n};\ngoog.dom.$dom = goog.dom.createDom;\ngoog.dom.createElement = function(name) {\n  return goog.dom.createElement_(document, name);\n};\ngoog.dom.createElement_ = function(doc, name) {\n  name = String(name);\n  if (doc.contentType === \"application/xhtml+xml\") {\n    name = name.toLowerCase();\n  }\n  return doc.createElement(name);\n};\ngoog.dom.createTextNode = function(content) {\n  return document.createTextNode(String(content));\n};\ngoog.dom.createTable = function(rows, columns, opt_fillWithNbsp) {\n  return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);\n};\ngoog.dom.createTable_ = function(doc, rows, columns, fillWithNbsp) {\n  var table = goog.dom.createElement_(doc, goog.dom.TagName.TABLE);\n  var tbody = table.appendChild(goog.dom.createElement_(doc, goog.dom.TagName.TBODY));\n  for (var i = 0; i < rows; i++) {\n    var tr = goog.dom.createElement_(doc, goog.dom.TagName.TR);\n    for (var j = 0; j < columns; j++) {\n      var td = goog.dom.createElement_(doc, goog.dom.TagName.TD);\n      if (fillWithNbsp) {\n        goog.dom.setTextContent(td, goog.string.Unicode.NBSP);\n      }\n      tr.appendChild(td);\n    }\n    tbody.appendChild(tr);\n  }\n  return table;\n};\ngoog.dom.constHtmlToNode = function(var_args) {\n  var stringArray = goog.array.map(arguments, goog.string.Const.unwrap);\n  var safeHtml = goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from(\"Constant HTML string, that gets turned into a \" + \"Node later, so it will be automatically balanced.\"), stringArray.join(\"\"));\n  return goog.dom.safeHtmlToNode(safeHtml);\n};\ngoog.dom.safeHtmlToNode = function(html) {\n  return goog.dom.safeHtmlToNode_(document, html);\n};\ngoog.dom.safeHtmlToNode_ = function(doc, html) {\n  var tempDiv = goog.dom.createElement_(doc, goog.dom.TagName.DIV);\n  if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {\n    goog.dom.safe.setInnerHtml(tempDiv, goog.html.SafeHtml.concat(goog.html.SafeHtml.BR, html));\n    tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));\n  } else {\n    goog.dom.safe.setInnerHtml(tempDiv, html);\n  }\n  return goog.dom.childrenToNode_(doc, tempDiv);\n};\ngoog.dom.childrenToNode_ = function(doc, tempDiv) {\n  if (tempDiv.childNodes.length == 1) {\n    return tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));\n  } else {\n    var fragment = doc.createDocumentFragment();\n    while (tempDiv.firstChild) {\n      fragment.appendChild(tempDiv.firstChild);\n    }\n    return fragment;\n  }\n};\ngoog.dom.isCss1CompatMode = function() {\n  return goog.dom.isCss1CompatMode_(document);\n};\ngoog.dom.isCss1CompatMode_ = function(doc) {\n  if (goog.dom.COMPAT_MODE_KNOWN_) {\n    return goog.dom.ASSUME_STANDARDS_MODE;\n  }\n  return doc.compatMode == \"CSS1Compat\";\n};\ngoog.dom.canHaveChildren = function(node) {\n  if (node.nodeType != goog.dom.NodeType.ELEMENT) {\n    return false;\n  }\n  switch(node.tagName) {\n    case String(goog.dom.TagName.APPLET):\n    case String(goog.dom.TagName.AREA):\n    case String(goog.dom.TagName.BASE):\n    case String(goog.dom.TagName.BR):\n    case String(goog.dom.TagName.COL):\n    case String(goog.dom.TagName.COMMAND):\n    case String(goog.dom.TagName.EMBED):\n    case String(goog.dom.TagName.FRAME):\n    case String(goog.dom.TagName.HR):\n    case String(goog.dom.TagName.IMG):\n    case String(goog.dom.TagName.INPUT):\n    case String(goog.dom.TagName.IFRAME):\n    case String(goog.dom.TagName.ISINDEX):\n    case String(goog.dom.TagName.KEYGEN):\n    case String(goog.dom.TagName.LINK):\n    case String(goog.dom.TagName.NOFRAMES):\n    case String(goog.dom.TagName.NOSCRIPT):\n    case String(goog.dom.TagName.META):\n    case String(goog.dom.TagName.OBJECT):\n    case String(goog.dom.TagName.PARAM):\n    case String(goog.dom.TagName.SCRIPT):\n    case String(goog.dom.TagName.SOURCE):\n    case String(goog.dom.TagName.STYLE):\n    case String(goog.dom.TagName.TRACK):\n    case String(goog.dom.TagName.WBR):\n      return false;\n  }\n  return true;\n};\ngoog.dom.appendChild = function(parent, child) {\n  goog.asserts.assert(parent != null && child != null, \"goog.dom.appendChild expects non-null arguments\");\n  parent.appendChild(child);\n};\ngoog.dom.append = function(parent, var_args) {\n  goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);\n};\ngoog.dom.removeChildren = function(node) {\n  var child;\n  while (child = node.firstChild) {\n    node.removeChild(child);\n  }\n};\ngoog.dom.insertSiblingBefore = function(newNode, refNode) {\n  goog.asserts.assert(newNode != null && refNode != null, \"goog.dom.insertSiblingBefore expects non-null arguments\");\n  if (refNode.parentNode) {\n    refNode.parentNode.insertBefore(newNode, refNode);\n  }\n};\ngoog.dom.insertSiblingAfter = function(newNode, refNode) {\n  goog.asserts.assert(newNode != null && refNode != null, \"goog.dom.insertSiblingAfter expects non-null arguments\");\n  if (refNode.parentNode) {\n    refNode.parentNode.insertBefore(newNode, refNode.nextSibling);\n  }\n};\ngoog.dom.insertChildAt = function(parent, child, index) {\n  goog.asserts.assert(parent != null, \"goog.dom.insertChildAt expects a non-null parent\");\n  parent.insertBefore(child, parent.childNodes[index] || null);\n};\ngoog.dom.removeNode = function(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n};\ngoog.dom.replaceNode = function(newNode, oldNode) {\n  goog.asserts.assert(newNode != null && oldNode != null, \"goog.dom.replaceNode expects non-null arguments\");\n  var parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n};\ngoog.dom.copyContents = function(target, source) {\n  goog.asserts.assert(target != null && source != null, \"goog.dom.copyContents expects non-null arguments\");\n  var childNodes = source.cloneNode(true).childNodes;\n  goog.dom.removeChildren(target);\n  while (childNodes.length) {\n    target.appendChild(childNodes[0]);\n  }\n};\ngoog.dom.flattenElement = function(element) {\n  var child, parent = element.parentNode;\n  if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {\n    if (element.removeNode) {\n      return element.removeNode(false);\n    } else {\n      while (child = element.firstChild) {\n        parent.insertBefore(child, element);\n      }\n      return goog.dom.removeNode(element);\n    }\n  }\n};\ngoog.dom.getChildren = function(element) {\n  if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE && element.children != undefined) {\n    return element.children;\n  }\n  return goog.array.filter(element.childNodes, function(node) {\n    return node.nodeType == goog.dom.NodeType.ELEMENT;\n  });\n};\ngoog.dom.getFirstElementChild = function(node) {\n  if (node.firstElementChild !== undefined) {\n    return node.firstElementChild;\n  }\n  return goog.dom.getNextElementNode_(node.firstChild, true);\n};\ngoog.dom.getLastElementChild = function(node) {\n  if (node.lastElementChild !== undefined) {\n    return node.lastElementChild;\n  }\n  return goog.dom.getNextElementNode_(node.lastChild, false);\n};\ngoog.dom.getNextElementSibling = function(node) {\n  if (node.nextElementSibling !== undefined) {\n    return node.nextElementSibling;\n  }\n  return goog.dom.getNextElementNode_(node.nextSibling, true);\n};\ngoog.dom.getPreviousElementSibling = function(node) {\n  if (node.previousElementSibling !== undefined) {\n    return node.previousElementSibling;\n  }\n  return goog.dom.getNextElementNode_(node.previousSibling, false);\n};\ngoog.dom.getNextElementNode_ = function(node, forward) {\n  while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {\n    node = forward ? node.nextSibling : node.previousSibling;\n  }\n  return node;\n};\ngoog.dom.getNextNode = function(node) {\n  if (!node) {\n    return null;\n  }\n  if (node.firstChild) {\n    return node.firstChild;\n  }\n  while (node && !node.nextSibling) {\n    node = node.parentNode;\n  }\n  return node ? node.nextSibling : null;\n};\ngoog.dom.getPreviousNode = function(node) {\n  if (!node) {\n    return null;\n  }\n  if (!node.previousSibling) {\n    return node.parentNode;\n  }\n  node = node.previousSibling;\n  while (node && node.lastChild) {\n    node = node.lastChild;\n  }\n  return node;\n};\ngoog.dom.isNodeLike = function(obj) {\n  return goog.isObject(obj) && obj.nodeType > 0;\n};\ngoog.dom.isElement = function(obj) {\n  return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;\n};\ngoog.dom.isWindow = function(obj) {\n  return goog.isObject(obj) && obj[\"window\"] == obj;\n};\ngoog.dom.getParentElement = function(element) {\n  var parent;\n  if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {\n    var isIe9 = goog.userAgent.IE && goog.userAgent.isVersionOrHigher(\"9\") && !goog.userAgent.isVersionOrHigher(\"10\");\n    if (!(isIe9 && goog.global[\"SVGElement\"] && element instanceof goog.global[\"SVGElement\"])) {\n      parent = element.parentElement;\n      if (parent) {\n        return parent;\n      }\n    }\n  }\n  parent = element.parentNode;\n  return goog.dom.isElement(parent) ? parent : null;\n};\ngoog.dom.contains = function(parent, descendant) {\n  if (!parent || !descendant) {\n    return false;\n  }\n  if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {\n    return parent == descendant || parent.contains(descendant);\n  }\n  if (typeof parent.compareDocumentPosition != \"undefined\") {\n    return parent == descendant || Boolean(parent.compareDocumentPosition(descendant) & 16);\n  }\n  while (descendant && parent != descendant) {\n    descendant = descendant.parentNode;\n  }\n  return descendant == parent;\n};\ngoog.dom.compareNodeOrder = function(node1, node2) {\n  if (node1 == node2) {\n    return 0;\n  }\n  if (node1.compareDocumentPosition) {\n    return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;\n  }\n  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {\n    if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {\n      return -1;\n    }\n    if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {\n      return 1;\n    }\n  }\n  if (\"sourceIndex\" in node1 || node1.parentNode && \"sourceIndex\" in node1.parentNode) {\n    var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;\n    var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;\n    if (isElement1 && isElement2) {\n      return node1.sourceIndex - node2.sourceIndex;\n    } else {\n      var parent1 = node1.parentNode;\n      var parent2 = node2.parentNode;\n      if (parent1 == parent2) {\n        return goog.dom.compareSiblingOrder_(node1, node2);\n      }\n      if (!isElement1 && goog.dom.contains(parent1, node2)) {\n        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);\n      }\n      if (!isElement2 && goog.dom.contains(parent2, node1)) {\n        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);\n      }\n      return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) - (isElement2 ? node2.sourceIndex : parent2.sourceIndex);\n    }\n  }\n  var doc = goog.dom.getOwnerDocument(node1);\n  var range1, range2;\n  range1 = doc.createRange();\n  range1.selectNode(node1);\n  range1.collapse(true);\n  range2 = doc.createRange();\n  range2.selectNode(node2);\n  range2.collapse(true);\n  return range1.compareBoundaryPoints(goog.global[\"Range\"].START_TO_END, range2);\n};\ngoog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {\n  var parent = textNode.parentNode;\n  if (parent == node) {\n    return -1;\n  }\n  var sibling = node;\n  while (sibling.parentNode != parent) {\n    sibling = sibling.parentNode;\n  }\n  return goog.dom.compareSiblingOrder_(sibling, textNode);\n};\ngoog.dom.compareSiblingOrder_ = function(node1, node2) {\n  var s = node2;\n  while (s = s.previousSibling) {\n    if (s == node1) {\n      return -1;\n    }\n  }\n  return 1;\n};\ngoog.dom.findCommonAncestor = function(var_args) {\n  var i, count = arguments.length;\n  if (!count) {\n    return null;\n  } else {\n    if (count == 1) {\n      return arguments[0];\n    }\n  }\n  var paths = [];\n  var minLength = Infinity;\n  for (i = 0; i < count; i++) {\n    var ancestors = [];\n    var node = arguments[i];\n    while (node) {\n      ancestors.unshift(node);\n      node = node.parentNode;\n    }\n    paths.push(ancestors);\n    minLength = Math.min(minLength, ancestors.length);\n  }\n  var output = null;\n  for (i = 0; i < minLength; i++) {\n    var first = paths[0][i];\n    for (var j = 1; j < count; j++) {\n      if (first != paths[j][i]) {\n        return output;\n      }\n    }\n    output = first;\n  }\n  return output;\n};\ngoog.dom.isInDocument = function(node) {\n  return (node.ownerDocument.compareDocumentPosition(node) & 16) == 16;\n};\ngoog.dom.getOwnerDocument = function(node) {\n  goog.asserts.assert(node, \"Node cannot be null or undefined.\");\n  return node.nodeType == goog.dom.NodeType.DOCUMENT ? node : node.ownerDocument || node.document;\n};\ngoog.dom.getFrameContentDocument = function(frame) {\n  return frame.contentDocument || frame.contentWindow.document;\n};\ngoog.dom.getFrameContentWindow = function(frame) {\n  try {\n    return frame.contentWindow || (frame.contentDocument ? goog.dom.getWindow(frame.contentDocument) : null);\n  } catch (e) {\n  }\n  return null;\n};\ngoog.dom.setTextContent = function(node, text) {\n  goog.asserts.assert(node != null, \"goog.dom.setTextContent expects a non-null value for node\");\n  if (\"textContent\" in node) {\n    node.textContent = text;\n  } else {\n    if (node.nodeType == goog.dom.NodeType.TEXT) {\n      node.data = String(text);\n    } else {\n      if (node.firstChild && node.firstChild.nodeType == goog.dom.NodeType.TEXT) {\n        while (node.lastChild != node.firstChild) {\n          node.removeChild(goog.asserts.assert(node.lastChild));\n        }\n        node.firstChild.data = String(text);\n      } else {\n        goog.dom.removeChildren(node);\n        var doc = goog.dom.getOwnerDocument(node);\n        node.appendChild(doc.createTextNode(String(text)));\n      }\n    }\n  }\n};\ngoog.dom.getOuterHtml = function(element) {\n  goog.asserts.assert(element !== null, \"goog.dom.getOuterHtml expects a non-null value for element\");\n  if (\"outerHTML\" in element) {\n    return element.outerHTML;\n  } else {\n    var doc = goog.dom.getOwnerDocument(element);\n    var div = goog.dom.createElement_(doc, goog.dom.TagName.DIV);\n    div.appendChild(element.cloneNode(true));\n    return div.innerHTML;\n  }\n};\ngoog.dom.findNode = function(root, p) {\n  var rv = [];\n  var found = goog.dom.findNodes_(root, p, rv, true);\n  return found ? rv[0] : undefined;\n};\ngoog.dom.findNodes = function(root, p) {\n  var rv = [];\n  goog.dom.findNodes_(root, p, rv, false);\n  return rv;\n};\ngoog.dom.findNodes_ = function(root, p, rv, findOne) {\n  if (root != null) {\n    var child = root.firstChild;\n    while (child) {\n      if (p(child)) {\n        rv.push(child);\n        if (findOne) {\n          return true;\n        }\n      }\n      if (goog.dom.findNodes_(child, p, rv, findOne)) {\n        return true;\n      }\n      child = child.nextSibling;\n    }\n  }\n  return false;\n};\ngoog.dom.findElement = function(root, pred) {\n  var stack = goog.dom.getChildrenReverse_(root);\n  while (stack.length > 0) {\n    var next = stack.pop();\n    if (pred(next)) {\n      return next;\n    }\n    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {\n      stack.push(c);\n    }\n  }\n  return null;\n};\ngoog.dom.findElements = function(root, pred) {\n  var result = [], stack = goog.dom.getChildrenReverse_(root);\n  while (stack.length > 0) {\n    var next = stack.pop();\n    if (pred(next)) {\n      result.push(next);\n    }\n    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {\n      stack.push(c);\n    }\n  }\n  return result;\n};\ngoog.dom.getChildrenReverse_ = function(node) {\n  if (node.nodeType == goog.dom.NodeType.DOCUMENT) {\n    return [node.documentElement];\n  } else {\n    var children = [];\n    for (var c = node.lastElementChild; c; c = c.previousElementSibling) {\n      children.push(c);\n    }\n    return children;\n  }\n};\ngoog.dom.TAGS_TO_IGNORE_ = {\"SCRIPT\":1, \"STYLE\":1, \"HEAD\":1, \"IFRAME\":1, \"OBJECT\":1};\ngoog.dom.PREDEFINED_TAG_VALUES_ = {\"IMG\":\" \", \"BR\":\"\\n\"};\ngoog.dom.isFocusableTabIndex = function(element) {\n  return goog.dom.hasSpecifiedTabIndex_(element) && goog.dom.isTabIndexFocusable_(element);\n};\ngoog.dom.setFocusableTabIndex = function(element, enable) {\n  if (enable) {\n    element.tabIndex = 0;\n  } else {\n    element.tabIndex = -1;\n    element.removeAttribute(\"tabIndex\");\n  }\n};\ngoog.dom.isFocusable = function(element) {\n  var focusable;\n  if (goog.dom.nativelySupportsFocus_(element)) {\n    focusable = !element.disabled && (!goog.dom.hasSpecifiedTabIndex_(element) || goog.dom.isTabIndexFocusable_(element));\n  } else {\n    focusable = goog.dom.isFocusableTabIndex(element);\n  }\n  return focusable && goog.userAgent.IE ? goog.dom.hasNonZeroBoundingRect_(element) : focusable;\n};\ngoog.dom.hasSpecifiedTabIndex_ = function(element) {\n  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher(\"9\")) {\n    var attrNode = element.getAttributeNode(\"tabindex\");\n    return attrNode != null && attrNode.specified;\n  } else {\n    return element.hasAttribute(\"tabindex\");\n  }\n};\ngoog.dom.isTabIndexFocusable_ = function(element) {\n  var index = element.tabIndex;\n  return typeof index === \"number\" && index >= 0 && index < 32768;\n};\ngoog.dom.nativelySupportsFocus_ = function(element) {\n  return element.tagName == goog.dom.TagName.A && element.hasAttribute(\"href\") || element.tagName == goog.dom.TagName.INPUT || element.tagName == goog.dom.TagName.TEXTAREA || element.tagName == goog.dom.TagName.SELECT || element.tagName == goog.dom.TagName.BUTTON;\n};\ngoog.dom.hasNonZeroBoundingRect_ = function(element) {\n  var rect;\n  if (typeof element[\"getBoundingClientRect\"] !== \"function\" || goog.userAgent.IE && element.parentElement == null) {\n    rect = {\"height\":element.offsetHeight, \"width\":element.offsetWidth};\n  } else {\n    rect = element.getBoundingClientRect();\n  }\n  return rect != null && rect.height > 0 && rect.width > 0;\n};\ngoog.dom.getTextContent = function(node) {\n  var textContent;\n  if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && node !== null && \"innerText\" in node) {\n    textContent = goog.string.canonicalizeNewlines(node.innerText);\n  } else {\n    var buf = [];\n    goog.dom.getTextContent_(node, buf, true);\n    textContent = buf.join(\"\");\n  }\n  textContent = textContent.replace(/ \\xAD /g, \" \").replace(/\\xAD/g, \"\");\n  textContent = textContent.replace(/\\u200B/g, \"\");\n  if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) {\n    textContent = textContent.replace(/ +/g, \" \");\n  }\n  if (textContent != \" \") {\n    textContent = textContent.replace(/^\\s*/, \"\");\n  }\n  return textContent;\n};\ngoog.dom.getRawTextContent = function(node) {\n  var buf = [];\n  goog.dom.getTextContent_(node, buf, false);\n  return buf.join(\"\");\n};\ngoog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {\n  if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {\n  } else {\n    if (node.nodeType == goog.dom.NodeType.TEXT) {\n      if (normalizeWhitespace) {\n        buf.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, \"\"));\n      } else {\n        buf.push(node.nodeValue);\n      }\n    } else {\n      if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {\n        buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);\n      } else {\n        var child = node.firstChild;\n        while (child) {\n          goog.dom.getTextContent_(child, buf, normalizeWhitespace);\n          child = child.nextSibling;\n        }\n      }\n    }\n  }\n};\ngoog.dom.getNodeTextLength = function(node) {\n  return goog.dom.getTextContent(node).length;\n};\ngoog.dom.getNodeTextOffset = function(node, opt_offsetParent) {\n  var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;\n  var buf = [];\n  while (node && node != root) {\n    var cur = node;\n    while (cur = cur.previousSibling) {\n      buf.unshift(goog.dom.getTextContent(cur));\n    }\n    node = node.parentNode;\n  }\n  return goog.string.trimLeft(buf.join(\"\")).replace(/ +/g, \" \").length;\n};\ngoog.dom.getNodeAtOffset = function(parent, offset, opt_result) {\n  var stack = [parent], pos = 0, cur = null;\n  while (stack.length > 0 && pos < offset) {\n    cur = stack.pop();\n    if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {\n    } else {\n      if (cur.nodeType == goog.dom.NodeType.TEXT) {\n        var text = cur.nodeValue.replace(/(\\r\\n|\\r|\\n)/g, \"\").replace(/ +/g, \" \");\n        pos += text.length;\n      } else {\n        if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {\n          pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;\n        } else {\n          for (var i = cur.childNodes.length - 1; i >= 0; i--) {\n            stack.push(cur.childNodes[i]);\n          }\n        }\n      }\n    }\n  }\n  if (goog.isObject(opt_result)) {\n    opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;\n    opt_result.node = cur;\n  }\n  return cur;\n};\ngoog.dom.isNodeList = function(val) {\n  if (val && typeof val.length == \"number\") {\n    if (goog.isObject(val)) {\n      return typeof val.item == \"function\" || typeof val.item == \"string\";\n    } else {\n      if (typeof val === \"function\") {\n        return typeof val.item == \"function\";\n      }\n    }\n  }\n  return false;\n};\ngoog.dom.getAncestorByTagNameAndClass = function(element, opt_tag, opt_class, opt_maxSearchSteps) {\n  if (!opt_tag && !opt_class) {\n    return null;\n  }\n  var tagName = opt_tag ? String(opt_tag).toUpperCase() : null;\n  return goog.dom.getAncestor(element, function(node) {\n    return (!tagName || node.nodeName == tagName) && (!opt_class || typeof node.className === \"string\" && goog.array.contains(node.className.split(/\\s+/), opt_class));\n  }, true, opt_maxSearchSteps);\n};\ngoog.dom.getAncestorByClass = function(element, className, opt_maxSearchSteps) {\n  return goog.dom.getAncestorByTagNameAndClass(element, null, className, opt_maxSearchSteps);\n};\ngoog.dom.getAncestor = function(element, matcher, opt_includeNode, opt_maxSearchSteps) {\n  if (element && !opt_includeNode) {\n    element = element.parentNode;\n  }\n  var steps = 0;\n  while (element && (opt_maxSearchSteps == null || steps <= opt_maxSearchSteps)) {\n    goog.asserts.assert(element.name != \"parentNode\");\n    if (matcher(element)) {\n      return element;\n    }\n    element = element.parentNode;\n    steps++;\n  }\n  return null;\n};\ngoog.dom.getActiveElement = function(doc) {\n  try {\n    var activeElement = doc && doc.activeElement;\n    return activeElement && activeElement.nodeName ? activeElement : null;\n  } catch (e) {\n    return null;\n  }\n};\ngoog.dom.getPixelRatio = function() {\n  var win = goog.dom.getWindow();\n  if (win.devicePixelRatio !== undefined) {\n    return win.devicePixelRatio;\n  } else {\n    if (win.matchMedia) {\n      return goog.dom.matchesPixelRatio_(3) || goog.dom.matchesPixelRatio_(2) || goog.dom.matchesPixelRatio_(1.5) || goog.dom.matchesPixelRatio_(1) || .75;\n    }\n  }\n  return 1;\n};\ngoog.dom.matchesPixelRatio_ = function(pixelRatio) {\n  var win = goog.dom.getWindow();\n  var dpiPerDppx = 96;\n  var query = \"(min-resolution: \" + pixelRatio + \"dppx),\" + \"(min--moz-device-pixel-ratio: \" + pixelRatio + \"),\" + \"(min-resolution: \" + pixelRatio * dpiPerDppx + \"dpi)\";\n  return win.matchMedia(query).matches ? pixelRatio : 0;\n};\ngoog.dom.getCanvasContext2D = function(canvas) {\n  return canvas.getContext(\"2d\");\n};\ngoog.dom.DomHelper = function(opt_document) {\n  this.document_ = opt_document || goog.global.document || document;\n};\ngoog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;\ngoog.dom.DomHelper.prototype.setDocument = function(document) {\n  this.document_ = document;\n};\ngoog.dom.DomHelper.prototype.getDocument = function() {\n  return this.document_;\n};\ngoog.dom.DomHelper.prototype.getElement = function(element) {\n  return goog.dom.getElementHelper_(this.document_, element);\n};\ngoog.dom.DomHelper.prototype.getRequiredElement = function(id) {\n  return goog.dom.getRequiredElementHelper_(this.document_, id);\n};\ngoog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;\ngoog.dom.DomHelper.prototype.getElementsByTagName = function(tagName, opt_parent) {\n  var parent = opt_parent || this.document_;\n  return parent.getElementsByTagName(String(tagName));\n};\ngoog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\n  return goog.dom.getElementsByTagNameAndClass_(this.document_, opt_tag, opt_class, opt_el);\n};\ngoog.dom.DomHelper.prototype.getElementByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\n  return goog.dom.getElementByTagNameAndClass_(this.document_, opt_tag, opt_class, opt_el);\n};\ngoog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {\n  var doc = opt_el || this.document_;\n  return goog.dom.getElementsByClass(className, doc);\n};\ngoog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {\n  var doc = opt_el || this.document_;\n  return goog.dom.getElementByClass(className, doc);\n};\ngoog.dom.DomHelper.prototype.getRequiredElementByClass = function(className, opt_root) {\n  var root = opt_root || this.document_;\n  return goog.dom.getRequiredElementByClass(className, root);\n};\ngoog.dom.DomHelper.prototype.$$ = goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;\ngoog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;\ngoog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {\n  return goog.dom.getViewportSize(opt_window || this.getWindow());\n};\ngoog.dom.DomHelper.prototype.getDocumentHeight = function() {\n  return goog.dom.getDocumentHeight_(this.getWindow());\n};\ngoog.dom.Appendable;\ngoog.dom.DomHelper.prototype.createDom = function(tagName, opt_attributes, var_args) {\n  return goog.dom.createDom_(this.document_, arguments);\n};\ngoog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;\ngoog.dom.DomHelper.prototype.createElement = function(name) {\n  return goog.dom.createElement_(this.document_, name);\n};\ngoog.dom.DomHelper.prototype.createTextNode = function(content) {\n  return this.document_.createTextNode(String(content));\n};\ngoog.dom.DomHelper.prototype.createTable = function(rows, columns, opt_fillWithNbsp) {\n  return goog.dom.createTable_(this.document_, rows, columns, !!opt_fillWithNbsp);\n};\ngoog.dom.DomHelper.prototype.safeHtmlToNode = function(html) {\n  return goog.dom.safeHtmlToNode_(this.document_, html);\n};\ngoog.dom.DomHelper.prototype.isCss1CompatMode = function() {\n  return goog.dom.isCss1CompatMode_(this.document_);\n};\ngoog.dom.DomHelper.prototype.getWindow = function() {\n  return goog.dom.getWindow_(this.document_);\n};\ngoog.dom.DomHelper.prototype.getDocumentScrollElement = function() {\n  return goog.dom.getDocumentScrollElement_(this.document_);\n};\ngoog.dom.DomHelper.prototype.getDocumentScroll = function() {\n  return goog.dom.getDocumentScroll_(this.document_);\n};\ngoog.dom.DomHelper.prototype.getActiveElement = function(opt_doc) {\n  return goog.dom.getActiveElement(opt_doc || this.document_);\n};\ngoog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;\ngoog.dom.DomHelper.prototype.append = goog.dom.append;\ngoog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;\ngoog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;\ngoog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;\ngoog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;\ngoog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;\ngoog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;\ngoog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;\ngoog.dom.DomHelper.prototype.copyContents = goog.dom.copyContents;\ngoog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;\ngoog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;\ngoog.dom.DomHelper.prototype.getFirstElementChild = goog.dom.getFirstElementChild;\ngoog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;\ngoog.dom.DomHelper.prototype.getNextElementSibling = goog.dom.getNextElementSibling;\ngoog.dom.DomHelper.prototype.getPreviousElementSibling = goog.dom.getPreviousElementSibling;\ngoog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;\ngoog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;\ngoog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;\ngoog.dom.DomHelper.prototype.isElement = goog.dom.isElement;\ngoog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;\ngoog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;\ngoog.dom.DomHelper.prototype.contains = goog.dom.contains;\ngoog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;\ngoog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;\ngoog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;\ngoog.dom.DomHelper.prototype.getFrameContentDocument = goog.dom.getFrameContentDocument;\ngoog.dom.DomHelper.prototype.getFrameContentWindow = goog.dom.getFrameContentWindow;\ngoog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;\ngoog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;\ngoog.dom.DomHelper.prototype.findNode = goog.dom.findNode;\ngoog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;\ngoog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;\ngoog.dom.DomHelper.prototype.setFocusableTabIndex = goog.dom.setFocusableTabIndex;\ngoog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;\ngoog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;\ngoog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;\ngoog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;\ngoog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;\ngoog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;\ngoog.dom.DomHelper.prototype.getAncestorByTagNameAndClass = goog.dom.getAncestorByTagNameAndClass;\ngoog.dom.DomHelper.prototype.getAncestorByClass = goog.dom.getAncestorByClass;\ngoog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;\ngoog.dom.DomHelper.prototype.getCanvasContext2D = goog.dom.getCanvasContext2D;\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utilities for manipulating the browser's Document Object Model\n * Inspiration taken *heavily* from mochikit (http://mochikit.com/).\n *\n * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer\n * to a different document object.  This is useful if you are working with\n * frames or multiple windows.\n *\n * @suppress {strictMissingProperties}\n */\n\n\n// TODO(arv): Rename/refactor getTextContent and getRawTextContent. The problem\n// is that getTextContent should mimic the DOM3 textContent. We should add a\n// getInnerText (or getText) which tries to return the visible text, innerText.\n\n\ngoog.provide('goog.dom');\ngoog.provide('goog.dom.Appendable');\ngoog.provide('goog.dom.DomHelper');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.dom.BrowserFeature');\ngoog.require('goog.dom.NodeType');\ngoog.require('goog.dom.TagName');\ngoog.require('goog.dom.safe');\ngoog.require('goog.html.SafeHtml');\ngoog.require('goog.html.uncheckedconversions');\ngoog.require('goog.math.Coordinate');\ngoog.require('goog.math.Size');\ngoog.require('goog.object');\ngoog.require('goog.string');\ngoog.require('goog.string.Const');\ngoog.require('goog.string.Unicode');\ngoog.require('goog.userAgent');\n\n\n/**\n * @define {boolean} Whether we know at compile time that the browser is in\n * quirks mode.\n */\ngoog.dom.ASSUME_QUIRKS_MODE = goog.define('goog.dom.ASSUME_QUIRKS_MODE', false);\n\n\n/**\n * @define {boolean} Whether we know at compile time that the browser is in\n * standards compliance mode.\n */\ngoog.dom.ASSUME_STANDARDS_MODE =\n    goog.define('goog.dom.ASSUME_STANDARDS_MODE', false);\n\n\n/**\n * Whether we know the compatibility mode at compile time.\n * @type {boolean}\n * @private\n */\ngoog.dom.COMPAT_MODE_KNOWN_ =\n    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;\n\n\n/**\n * Gets the DomHelper object for the document where the element resides.\n * @param {(Node|Window)=} opt_element If present, gets the DomHelper for this\n *     element.\n * @return {!goog.dom.DomHelper} The DomHelper.\n */\ngoog.dom.getDomHelper = function(opt_element) {\n  'use strict';\n  return opt_element ?\n      new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :\n      (goog.dom.defaultDomHelper_ ||\n       (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));\n};\n\n\n/**\n * Cached default DOM helper.\n * @type {!goog.dom.DomHelper|undefined}\n * @private\n */\ngoog.dom.defaultDomHelper_;\n\n\n/**\n * Gets the document object being used by the dom library.\n * @return {!Document} Document object.\n */\ngoog.dom.getDocument = function() {\n  'use strict';\n  return document;\n};\n\n\n/**\n * Gets an element from the current document by element id.\n *\n * If an Element is passed in, it is returned.\n *\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The element with the given ID, or the node passed in.\n */\ngoog.dom.getElement = function(element) {\n  'use strict';\n  return goog.dom.getElementHelper_(document, element);\n};\n\n\n/**\n * Gets an element by id from the given document (if present).\n * If an element is given, it is returned.\n * @param {!Document} doc\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The resulting element.\n * @private\n */\ngoog.dom.getElementHelper_ = function(doc, element) {\n  'use strict';\n  return typeof element === 'string' ? doc.getElementById(element) : element;\n};\n\n\n/**\n * Gets an element by id, asserting that the element is found.\n *\n * This is used when an element is expected to exist, and should fail with\n * an assertion error if it does not (if assertions are enabled).\n *\n * @param {string} id Element ID.\n * @return {!Element} The element with the given ID, if it exists.\n */\ngoog.dom.getRequiredElement = function(id) {\n  'use strict';\n  return goog.dom.getRequiredElementHelper_(document, id);\n};\n\n\n/**\n * Helper function for getRequiredElementHelper functions, both static and\n * on DomHelper.  Asserts the element with the given id exists.\n * @param {!Document} doc\n * @param {string} id\n * @return {!Element} The element with the given ID, if it exists.\n * @private\n */\ngoog.dom.getRequiredElementHelper_ = function(doc, id) {\n  'use strict';\n  // To prevent users passing in Elements as is permitted in getElement().\n  goog.asserts.assertString(id);\n  var element = goog.dom.getElementHelper_(doc, id);\n  element =\n      goog.asserts.assertElement(element, 'No element found with id: ' + id);\n  return element;\n};\n\n\n/**\n * Alias for getElement.\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The element with the given ID, or the node passed in.\n * @deprecated Use {@link goog.dom.getElement} instead.\n */\ngoog.dom.$ = goog.dom.getElement;\n\n\n/**\n * Gets elements by tag name.\n * @param {!goog.dom.TagName<T>} tagName\n * @param {(!Document|!Element)=} opt_parent Parent element or document where to\n *     look for elements. Defaults to document.\n * @return {!NodeList<R>} List of elements. The members of the list are\n *     {!Element} if tagName is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.getElementsByTagName = function(tagName, opt_parent) {\n  'use strict';\n  var parent = opt_parent || document;\n  return parent.getElementsByTagName(String(tagName));\n};\n\n\n/**\n * Looks up elements by both tag and class name, using browser native functions\n * (`querySelectorAll`, `getElementsByTagName` or\n * `getElementsByClassName`) where possible. This function\n * is a useful, if limited, way of collecting a list of DOM elements\n * with certain characteristics.  `querySelectorAll` offers a\n * more powerful and general solution which allows matching on CSS3\n * selector expressions.\n *\n * Note that tag names are case sensitive in the SVG namespace, and this\n * function converts opt_tag to uppercase for comparisons. For queries in the\n * SVG namespace you should use querySelector or querySelectorAll instead.\n * https://bugzilla.mozilla.org/show_bug.cgi?id=963870\n * https://bugs.webkit.org/show_bug.cgi?id=83438\n *\n * @see {https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll}\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\n  'use strict';\n  return goog.dom.getElementsByTagNameAndClass_(\n      document, opt_tag, opt_class, opt_el);\n};\n\n\n/**\n * Gets the first element matching the tag and the class.\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {?R} Reference to a DOM node. The return type is {?Element} if\n *     tagName is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.getElementByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\n  'use strict';\n  return goog.dom.getElementByTagNameAndClass_(\n      document, opt_tag, opt_class, opt_el);\n};\n\n\n/**\n * Returns a static, array-like list of the elements with the provided\n * className.\n *\n * @param {string} className the name of the class to look for.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {!IArrayLike<!Element>} The items found with the class name provided.\n */\ngoog.dom.getElementsByClass = function(className, opt_el) {\n  'use strict';\n  var parent = opt_el || document;\n  if (goog.dom.canUseQuerySelector_(parent)) {\n    return parent.querySelectorAll('.' + className);\n  }\n  return goog.dom.getElementsByTagNameAndClass_(\n      document, '*', className, opt_el);\n};\n\n\n/**\n * Returns the first element with the provided className.\n *\n * @param {string} className the name of the class to look for.\n * @param {Element|Document=} opt_el Optional element to look in.\n * @return {Element} The first item with the class name provided.\n */\ngoog.dom.getElementByClass = function(className, opt_el) {\n  'use strict';\n  var parent = opt_el || document;\n  var retVal = null;\n  if (parent.getElementsByClassName) {\n    retVal = parent.getElementsByClassName(className)[0];\n  } else {\n    retVal =\n        goog.dom.getElementByTagNameAndClass_(document, '*', className, opt_el);\n  }\n  return retVal || null;\n};\n\n\n/**\n * Ensures an element with the given className exists, and then returns the\n * first element with the provided className.\n *\n * @param {string} className the name of the class to look for.\n * @param {!Element|!Document=} opt_root Optional element or document to look\n *     in.\n * @return {!Element} The first item with the class name provided.\n * @throws {goog.asserts.AssertionError} Thrown if no element is found.\n */\ngoog.dom.getRequiredElementByClass = function(className, opt_root) {\n  'use strict';\n  var retValue = goog.dom.getElementByClass(className, opt_root);\n  return goog.asserts.assert(\n      retValue, 'No element found with className: ' + className);\n};\n\n\n/**\n * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and\n * fast W3C Selectors API.\n * @param {!(Element|Document)} parent The parent document object.\n * @return {boolean} whether or not we can use parent.querySelector* APIs.\n * @private\n */\ngoog.dom.canUseQuerySelector_ = function(parent) {\n  'use strict';\n  return !!(parent.querySelectorAll && parent.querySelector);\n};\n\n\n/**\n * Helper for `getElementsByTagNameAndClass`.\n * @param {!Document} doc The document to get the elements in.\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @private\n */\ngoog.dom.getElementsByTagNameAndClass_ = function(\n    doc, opt_tag, opt_class, opt_el) {\n  'use strict';\n  var parent = opt_el || doc;\n  var tagName =\n      (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';\n\n  if (goog.dom.canUseQuerySelector_(parent) && (tagName || opt_class)) {\n    var query = tagName + (opt_class ? '.' + opt_class : '');\n    return parent.querySelectorAll(query);\n  }\n\n  // Use the native getElementsByClassName if available, under the assumption\n  // that even when the tag name is specified, there will be fewer elements to\n  // filter through when going by class than by tag name\n  if (opt_class && parent.getElementsByClassName) {\n    var els = parent.getElementsByClassName(opt_class);\n\n    if (tagName) {\n      var arrayLike = {};\n      var len = 0;\n\n      // Filter for specific tags if requested.\n      for (var i = 0, el; el = els[i]; i++) {\n        if (tagName == el.nodeName) {\n          arrayLike[len++] = el;\n        }\n      }\n      arrayLike.length = len;\n\n      return /** @type {!IArrayLike<!Element>} */ (arrayLike);\n    } else {\n      return els;\n    }\n  }\n\n  var els = parent.getElementsByTagName(tagName || '*');\n\n  if (opt_class) {\n    var arrayLike = {};\n    var len = 0;\n    for (var i = 0, el; el = els[i]; i++) {\n      var className = el.className;\n      // Check if className has a split function since SVG className does not.\n      if (typeof className.split == 'function' &&\n          goog.array.contains(className.split(/\\s+/), opt_class)) {\n        arrayLike[len++] = el;\n      }\n    }\n    arrayLike.length = len;\n    return /** @type {!IArrayLike<!Element>} */ (arrayLike);\n  } else {\n    return els;\n  }\n};\n\n\n/**\n * Helper for goog.dom.getElementByTagNameAndClass.\n *\n * @param {!Document} doc The document to get the elements in.\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {?R} Reference to a DOM node. The return type is {?Element} if\n *     tagName is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @private\n */\ngoog.dom.getElementByTagNameAndClass_ = function(\n    doc, opt_tag, opt_class, opt_el) {\n  'use strict';\n  var parent = opt_el || doc;\n  var tag = (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';\n  if (goog.dom.canUseQuerySelector_(parent) && (tag || opt_class)) {\n    return parent.querySelector(tag + (opt_class ? '.' + opt_class : ''));\n  }\n  var elements =\n      goog.dom.getElementsByTagNameAndClass_(doc, opt_tag, opt_class, opt_el);\n  return elements[0] || null;\n};\n\n\n\n/**\n * Alias for `getElementsByTagNameAndClass`.\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {Element=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.\n */\ngoog.dom.$$ = goog.dom.getElementsByTagNameAndClass;\n\n\n/**\n * Sets multiple properties, and sometimes attributes, on an element. Note that\n * properties are simply object properties on the element instance, while\n * attributes are visible in the DOM. Many properties map to attributes with the\n * same names, some with different names, and there are also unmappable cases.\n *\n * This method sets properties by default (which means that custom attributes\n * are not supported). These are the exeptions (some of which is legacy):\n * - \"style\": Even though this is an attribute name, it is translated to a\n *   property, \"style.cssText\". Note that this property sanitizes and formats\n *   its value, unlike the attribute.\n * - \"class\": This is an attribute name, it is translated to the \"className\"\n *   property.\n * - \"for\": This is an attribute name, it is translated to the \"htmlFor\"\n *   property.\n * - Entries in {@see goog.dom.DIRECT_ATTRIBUTE_MAP_} are set as attributes,\n *   this is probably due to browser quirks.\n * - \"aria-*\", \"data-*\": Always set as attributes, they have no property\n *   counterparts.\n *\n * @param {Element} element DOM node to set properties on.\n * @param {Object} properties Hash of property:value pairs.\n *     Property values can be strings or goog.string.TypedString values (such as\n *     goog.html.SafeUrl).\n */\ngoog.dom.setProperties = function(element, properties) {\n  'use strict';\n  goog.object.forEach(properties, function(val, key) {\n    'use strict';\n    if (val && typeof val == 'object' && val.implementsGoogStringTypedString) {\n      val = val.getTypedStringValue();\n    }\n    if (key == 'style') {\n      element.style.cssText = val;\n    } else if (key == 'class') {\n      element.className = val;\n    } else if (key == 'for') {\n      element.htmlFor = val;\n    } else if (goog.dom.DIRECT_ATTRIBUTE_MAP_.hasOwnProperty(key)) {\n      element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);\n    } else if (\n        goog.string.startsWith(key, 'aria-') ||\n        goog.string.startsWith(key, 'data-')) {\n      element.setAttribute(key, val);\n    } else {\n      element[key] = val;\n    }\n  });\n};\n\n\n/**\n * Map of attributes that should be set using\n * element.setAttribute(key, val) instead of element[key] = val.  Used\n * by goog.dom.setProperties.\n *\n * @private {!Object<string, string>}\n * @const\n */\ngoog.dom.DIRECT_ATTRIBUTE_MAP_ = {\n  'cellpadding': 'cellPadding',\n  'cellspacing': 'cellSpacing',\n  'colspan': 'colSpan',\n  'frameborder': 'frameBorder',\n  'height': 'height',\n  'maxlength': 'maxLength',\n  'nonce': 'nonce',\n  'role': 'role',\n  'rowspan': 'rowSpan',\n  'type': 'type',\n  'usemap': 'useMap',\n  'valign': 'vAlign',\n  'width': 'width'\n};\n\n\n/**\n * Gets the dimensions of the viewport.\n *\n * Gecko Standards mode:\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * win.innerWidth     Width of viewport including scrollbar.\n * body.clientWidth   Width of body element.\n *\n * docEl.clientHeight Height of viewport excluding scrollbar.\n * win.innerHeight    Height of viewport including scrollbar.\n * body.clientHeight  Height of document.\n *\n * Gecko Backwards compatible mode:\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * win.innerWidth     Width of viewport including scrollbar.\n * body.clientWidth   Width of viewport excluding scrollbar.\n *\n * docEl.clientHeight Height of document.\n * win.innerHeight    Height of viewport including scrollbar.\n * body.clientHeight  Height of viewport excluding scrollbar.\n *\n * IE6/7 Standards mode:\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * win.innerWidth     Undefined.\n * body.clientWidth   Width of body element.\n *\n * docEl.clientHeight Height of viewport excluding scrollbar.\n * win.innerHeight    Undefined.\n * body.clientHeight  Height of document element.\n *\n * IE5 + IE6/7 Backwards compatible mode:\n * docEl.clientWidth  0.\n * win.innerWidth     Undefined.\n * body.clientWidth   Width of viewport excluding scrollbar.\n *\n * docEl.clientHeight 0.\n * win.innerHeight    Undefined.\n * body.clientHeight  Height of viewport excluding scrollbar.\n *\n * Opera 9 Standards and backwards compatible mode:\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * win.innerWidth     Width of viewport including scrollbar.\n * body.clientWidth   Width of viewport excluding scrollbar.\n *\n * docEl.clientHeight Height of document.\n * win.innerHeight    Height of viewport including scrollbar.\n * body.clientHeight  Height of viewport excluding scrollbar.\n *\n * WebKit:\n * Safari 2\n * docEl.clientHeight Same as scrollHeight.\n * docEl.clientWidth  Same as innerWidth.\n * win.innerWidth     Width of viewport excluding scrollbar.\n * win.innerHeight    Height of the viewport including scrollbar.\n * frame.innerHeight  Height of the viewport exluding scrollbar.\n *\n * Safari 3 (tested in 522)\n *\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.\n * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.\n *\n * @param {Window=} opt_window Optional window element to test.\n * @return {!goog.math.Size} Object with values 'width' and 'height'.\n */\ngoog.dom.getViewportSize = function(opt_window) {\n  'use strict';\n  // TODO(arv): This should not take an argument\n  return goog.dom.getViewportSize_(opt_window || window);\n};\n\n\n/**\n * Helper for `getViewportSize`.\n * @param {Window} win The window to get the view port size for.\n * @return {!goog.math.Size} Object with values 'width' and 'height'.\n * @private\n */\ngoog.dom.getViewportSize_ = function(win) {\n  'use strict';\n  var doc = win.document;\n  var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;\n  return new goog.math.Size(el.clientWidth, el.clientHeight);\n};\n\n\n/**\n * Calculates the height of the document.\n *\n * @return {number} The height of the current document.\n */\ngoog.dom.getDocumentHeight = function() {\n  'use strict';\n  return goog.dom.getDocumentHeight_(window);\n};\n\n/**\n * Calculates the height of the document of the given window.\n *\n * @param {!Window} win The window whose document height to retrieve.\n * @return {number} The height of the document of the given window.\n */\ngoog.dom.getDocumentHeightForWindow = function(win) {\n  'use strict';\n  return goog.dom.getDocumentHeight_(win);\n};\n\n/**\n * Calculates the height of the document of the given window.\n *\n * Function code copied from the opensocial gadget api:\n *   gadgets.window.adjustHeight(opt_height)\n *\n * @private\n * @param {!Window} win The window whose document height to retrieve.\n * @return {number} The height of the document of the given window.\n */\ngoog.dom.getDocumentHeight_ = function(win) {\n  'use strict';\n  // NOTE(eae): This method will return the window size rather than the document\n  // size in webkit quirks mode.\n  var doc = win.document;\n  var height = 0;\n\n  if (doc) {\n    // Calculating inner content height is hard and different between\n    // browsers rendering in Strict vs. Quirks mode.  We use a combination of\n    // three properties within document.body and document.documentElement:\n    // - scrollHeight\n    // - offsetHeight\n    // - clientHeight\n    // These values differ significantly between browsers and rendering modes.\n    // But there are patterns.  It just takes a lot of time and persistence\n    // to figure out.\n\n    var body = doc.body;\n    var docEl = /** @type {!HTMLElement} */ (doc.documentElement);\n    if (!(docEl && body)) {\n      return 0;\n    }\n\n    // Get the height of the viewport\n    var vh = goog.dom.getViewportSize_(win).height;\n    if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {\n      // In Strict mode:\n      // The inner content height is contained in either:\n      //    document.documentElement.scrollHeight\n      //    document.documentElement.offsetHeight\n      // Based on studying the values output by different browsers,\n      // use the value that's NOT equal to the viewport height found above.\n      height =\n          docEl.scrollHeight != vh ? docEl.scrollHeight : docEl.offsetHeight;\n    } else {\n      // In Quirks mode:\n      // documentElement.clientHeight is equal to documentElement.offsetHeight\n      // except in IE.  In most browsers, document.documentElement can be used\n      // to calculate the inner content height.\n      // However, in other browsers (e.g. IE), document.body must be used\n      // instead.  How do we know which one to use?\n      // If document.documentElement.clientHeight does NOT equal\n      // document.documentElement.offsetHeight, then use document.body.\n      var sh = docEl.scrollHeight;\n      var oh = docEl.offsetHeight;\n      if (docEl.clientHeight != oh) {\n        sh = body.scrollHeight;\n        oh = body.offsetHeight;\n      }\n\n      // Detect whether the inner content height is bigger or smaller\n      // than the bounding box (viewport).  If bigger, take the larger\n      // value.  If smaller, take the smaller value.\n      if (sh > vh) {\n        // Content is larger\n        height = sh > oh ? sh : oh;\n      } else {\n        // Content is smaller\n        height = sh < oh ? sh : oh;\n      }\n    }\n  }\n\n  return height;\n};\n\n\n/**\n * Gets the page scroll distance as a coordinate object.\n *\n * @param {Window=} opt_window Optional window element to test.\n * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.\n * @deprecated Use {@link goog.dom.getDocumentScroll} instead.\n */\ngoog.dom.getPageScroll = function(opt_window) {\n  'use strict';\n  var win = opt_window || goog.global || window;\n  return goog.dom.getDomHelper(win.document).getDocumentScroll();\n};\n\n\n/**\n * Gets the document scroll distance as a coordinate object.\n *\n * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.\n */\ngoog.dom.getDocumentScroll = function() {\n  'use strict';\n  return goog.dom.getDocumentScroll_(document);\n};\n\n\n/**\n * Helper for `getDocumentScroll`.\n *\n * @param {!Document} doc The document to get the scroll for.\n * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.\n * @private\n */\ngoog.dom.getDocumentScroll_ = function(doc) {\n  'use strict';\n  var el = goog.dom.getDocumentScrollElement_(doc);\n  var win = goog.dom.getWindow_(doc);\n  if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher('10') &&\n      win.pageYOffset != el.scrollTop) {\n    // The keyboard on IE10 touch devices shifts the page using the pageYOffset\n    // without modifying scrollTop. For this case, we want the body scroll\n    // offsets.\n    return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);\n  }\n  return new goog.math.Coordinate(\n      win.pageXOffset || el.scrollLeft, win.pageYOffset || el.scrollTop);\n};\n\n\n/**\n * Gets the document scroll element.\n * @return {!Element} Scrolling element.\n */\ngoog.dom.getDocumentScrollElement = function() {\n  'use strict';\n  return goog.dom.getDocumentScrollElement_(document);\n};\n\n\n/**\n * Helper for `getDocumentScrollElement`.\n * @param {!Document} doc The document to get the scroll element for.\n * @return {!Element} Scrolling element.\n * @private\n */\ngoog.dom.getDocumentScrollElement_ = function(doc) {\n  'use strict';\n  // Old WebKit needs body.scrollLeft in both quirks mode and strict mode. We\n  // also default to the documentElement if the document does not have a body\n  // (e.g. a SVG document).\n  // Uses http://dev.w3.org/csswg/cssom-view/#dom-document-scrollingelement to\n  // avoid trying to guess about browser behavior from the UA string.\n  if (doc.scrollingElement) {\n    return doc.scrollingElement;\n  }\n  if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) {\n    return doc.documentElement;\n  }\n  return doc.body || doc.documentElement;\n};\n\n\n/**\n * Gets the window object associated with the given document.\n *\n * @param {Document=} opt_doc  Document object to get window for.\n * @return {!Window} The window associated with the given document.\n */\ngoog.dom.getWindow = function(opt_doc) {\n  'use strict';\n  // TODO(arv): This should not take an argument.\n  return opt_doc ? goog.dom.getWindow_(opt_doc) : window;\n};\n\n\n/**\n * Helper for `getWindow`.\n *\n * @param {!Document} doc  Document object to get window for.\n * @return {!Window} The window associated with the given document.\n * @private\n */\ngoog.dom.getWindow_ = function(doc) {\n  'use strict';\n  return /** @type {!Window} */ (doc.parentWindow || doc.defaultView);\n};\n\n\n/**\n * Returns a dom node with a set of attributes.  This function accepts varargs\n * for subsequent nodes to be added.  Subsequent nodes will be added to the\n * first node as childNodes.\n *\n * So:\n * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),\n * createDom(goog.dom.TagName.P));</code> would return a div with two child\n * paragraphs\n *\n * This function uses {@link goog.dom.setProperties} to set attributes: the\n * `opt_attributes` parameter follows the same rules.\n *\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\n *     of name-value pairs for attributes. If a string, then this is the\n *     className of the new element. If an array, the elements will be joined\n *     together as the className of the new element.\n * @param {...(Object|string|Array|NodeList|null|undefined)} var_args Further\n *     DOM nodes or strings for text nodes. If one of the var_args is an array\n *     or NodeList, its elements will be added as childNodes instead.\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\n *     is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.createDom = function(tagName, opt_attributes, var_args) {\n  'use strict';\n  return goog.dom.createDom_(document, arguments);\n};\n\n\n/**\n * Helper for `createDom`.\n * @param {!Document} doc The document to create the DOM in.\n * @param {!Arguments} args Argument object passed from the callers. See\n *     `goog.dom.createDom` for details.\n * @return {!Element} Reference to a DOM node.\n * @private\n */\ngoog.dom.createDom_ = function(doc, args) {\n  'use strict';\n  var tagName = String(args[0]);\n  var attributes = args[1];\n\n  // Internet Explorer is dumb:\n  // name: https://msdn.microsoft.com/en-us/library/ms534184(v=vs.85).aspx\n  // type: https://msdn.microsoft.com/en-us/library/ms534700(v=vs.85).aspx\n  // Also does not allow setting of 'type' attribute on 'input' or 'button'.\n  if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes &&\n      (attributes.name || attributes.type)) {\n    var tagNameArr = ['<', tagName];\n    if (attributes.name) {\n      tagNameArr.push(' name=\"', goog.string.htmlEscape(attributes.name), '\"');\n    }\n    if (attributes.type) {\n      tagNameArr.push(' type=\"', goog.string.htmlEscape(attributes.type), '\"');\n\n      // Clone attributes map to remove 'type' without mutating the input.\n      var clone = {};\n      goog.object.extend(clone, attributes);\n\n      // JSCompiler can't see how goog.object.extend added this property,\n      // because it was essentially added by reflection.\n      // So it needs to be quoted.\n      delete clone['type'];\n\n      attributes = clone;\n    }\n    tagNameArr.push('>');\n    tagName = tagNameArr.join('');\n  }\n\n  var element = goog.dom.createElement_(doc, tagName);\n\n  if (attributes) {\n    if (typeof attributes === 'string') {\n      element.className = attributes;\n    } else if (Array.isArray(attributes)) {\n      element.className = attributes.join(' ');\n    } else {\n      goog.dom.setProperties(element, attributes);\n    }\n  }\n\n  if (args.length > 2) {\n    goog.dom.append_(doc, element, args, 2);\n  }\n\n  return element;\n};\n\n\n/**\n * Appends a node with text or other nodes.\n * @param {!Document} doc The document to create new nodes in.\n * @param {!Node} parent The node to append nodes to.\n * @param {!Arguments} args The values to add. See `goog.dom.append`.\n * @param {number} startIndex The index of the array to start from.\n * @private\n */\ngoog.dom.append_ = function(doc, parent, args, startIndex) {\n  'use strict';\n  function childHandler(child) {\n    // TODO(user): More coercion, ala MochiKit?\n    if (child) {\n      parent.appendChild(\n          typeof child === 'string' ? doc.createTextNode(child) : child);\n    }\n  }\n\n  for (var i = startIndex; i < args.length; i++) {\n    var arg = args[i];\n    // TODO(attila): Fix isArrayLike to return false for a text node.\n    if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {\n      // If the argument is a node list, not a real array, use a clone,\n      // because forEach can't be used to mutate a NodeList.\n      goog.array.forEach(\n          goog.dom.isNodeList(arg) ? goog.array.toArray(arg) : arg,\n          childHandler);\n    } else {\n      childHandler(arg);\n    }\n  }\n};\n\n\n/**\n * Alias for `createDom`.\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\n *     of name-value pairs for attributes. If a string, then this is the\n *     className of the new element. If an array, the elements will be joined\n *     together as the className of the new element.\n * @param {...(Object|string|Array|NodeList|null|undefined)} var_args Further\n *     DOM nodes or strings for text nodes. If one of the var_args is an array,\n *     its children will be added as childNodes instead.\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\n *     is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @deprecated Use {@link goog.dom.createDom} instead.\n */\ngoog.dom.$dom = goog.dom.createDom;\n\n\n/**\n * Creates a new element.\n * @param {string|!goog.dom.TagName<T>} name Tag to create.\n * @return {R} The new element. The return type is {!Element} if name is\n *     a string or a more specific type if it is a member of goog.dom.TagName\n *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.createElement = function(name) {\n  'use strict';\n  return goog.dom.createElement_(document, name);\n};\n\n\n/**\n * Creates a new element.\n * @param {!Document} doc The document to create the element in.\n * @param {string|!goog.dom.TagName<T>} name Tag to create.\n * @return {R} The new element. The return type is {!Element} if name is\n *     a string or a more specific type if it is a member of goog.dom.TagName\n *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @private\n */\ngoog.dom.createElement_ = function(doc, name) {\n  'use strict';\n  name = String(name);\n  if (doc.contentType === 'application/xhtml+xml') name = name.toLowerCase();\n  return doc.createElement(name);\n};\n\n\n/**\n * Creates a new text node.\n * @param {number|string} content Content.\n * @return {!Text} The new text node.\n */\ngoog.dom.createTextNode = function(content) {\n  'use strict';\n  return document.createTextNode(String(content));\n};\n\n\n/**\n * Create a table.\n * @param {number} rows The number of rows in the table.  Must be >= 1.\n * @param {number} columns The number of columns in the table.  Must be >= 1.\n * @param {boolean=} opt_fillWithNbsp If true, fills table entries with\n *     `goog.string.Unicode.NBSP` characters.\n * @return {!Element} The created table.\n */\ngoog.dom.createTable = function(rows, columns, opt_fillWithNbsp) {\n  'use strict';\n  // TODO(mlourenco): Return HTMLTableElement, also in prototype function.\n  // Callers need to be updated to e.g. not assign numbers to table.cellSpacing.\n  return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);\n};\n\n\n/**\n * Create a table.\n * @param {!Document} doc Document object to use to create the table.\n * @param {number} rows The number of rows in the table.  Must be >= 1.\n * @param {number} columns The number of columns in the table.  Must be >= 1.\n * @param {boolean} fillWithNbsp If true, fills table entries with\n *     `goog.string.Unicode.NBSP` characters.\n * @return {!HTMLTableElement} The created table.\n * @private\n */\ngoog.dom.createTable_ = function(doc, rows, columns, fillWithNbsp) {\n  'use strict';\n  var table = goog.dom.createElement_(doc, goog.dom.TagName.TABLE);\n  var tbody =\n      table.appendChild(goog.dom.createElement_(doc, goog.dom.TagName.TBODY));\n  for (var i = 0; i < rows; i++) {\n    var tr = goog.dom.createElement_(doc, goog.dom.TagName.TR);\n    for (var j = 0; j < columns; j++) {\n      var td = goog.dom.createElement_(doc, goog.dom.TagName.TD);\n      // IE <= 9 will create a text node if we set text content to the empty\n      // string, so we avoid doing it unless necessary. This ensures that the\n      // same DOM tree is returned on all browsers.\n      if (fillWithNbsp) {\n        goog.dom.setTextContent(td, goog.string.Unicode.NBSP);\n      }\n      tr.appendChild(td);\n    }\n    tbody.appendChild(tr);\n  }\n  return table;\n};\n\n\n\n/**\n * Creates a new Node from constant strings of HTML markup.\n * @param {...!goog.string.Const} var_args The HTML strings to concatenate then\n *     convert into a node.\n * @return {!Node}\n */\ngoog.dom.constHtmlToNode = function(var_args) {\n  'use strict';\n  var stringArray = goog.array.map(arguments, goog.string.Const.unwrap);\n  var safeHtml =\n      goog.html.uncheckedconversions\n          .safeHtmlFromStringKnownToSatisfyTypeContract(\n              goog.string.Const.from(\n                  'Constant HTML string, that gets turned into a ' +\n                  'Node later, so it will be automatically balanced.'),\n              stringArray.join(''));\n  return goog.dom.safeHtmlToNode(safeHtml);\n};\n\n\n/**\n * Converts HTML markup into a node. This is a safe version of\n * `goog.dom.htmlToDocumentFragment` which is now deleted.\n * @param {!goog.html.SafeHtml} html The HTML markup to convert.\n * @return {!Node} The resulting node.\n */\ngoog.dom.safeHtmlToNode = function(html) {\n  'use strict';\n  return goog.dom.safeHtmlToNode_(document, html);\n};\n\n\n/**\n * Helper for `safeHtmlToNode`.\n * @param {!Document} doc The document.\n * @param {!goog.html.SafeHtml} html The HTML markup to convert.\n * @return {!Node} The resulting node.\n * @private\n */\ngoog.dom.safeHtmlToNode_ = function(doc, html) {\n  'use strict';\n  var tempDiv = goog.dom.createElement_(doc, goog.dom.TagName.DIV);\n  if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {\n    goog.dom.safe.setInnerHtml(\n        tempDiv, goog.html.SafeHtml.concat(goog.html.SafeHtml.BR, html));\n    tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));\n  } else {\n    goog.dom.safe.setInnerHtml(tempDiv, html);\n  }\n  return goog.dom.childrenToNode_(doc, tempDiv);\n};\n\n\n/**\n * Helper for `safeHtmlToNode_`.\n * @param {!Document} doc The document.\n * @param {!Node} tempDiv The input node.\n * @return {!Node} The resulting node.\n * @private\n */\ngoog.dom.childrenToNode_ = function(doc, tempDiv) {\n  'use strict';\n  if (tempDiv.childNodes.length == 1) {\n    return tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));\n  } else {\n    var fragment = doc.createDocumentFragment();\n    while (tempDiv.firstChild) {\n      fragment.appendChild(tempDiv.firstChild);\n    }\n    return fragment;\n  }\n};\n\n\n/**\n * Returns true if the browser is in \"CSS1-compatible\" (standards-compliant)\n * mode, false otherwise.\n * @return {boolean} True if in CSS1-compatible mode.\n */\ngoog.dom.isCss1CompatMode = function() {\n  'use strict';\n  return goog.dom.isCss1CompatMode_(document);\n};\n\n\n/**\n * Returns true if the browser is in \"CSS1-compatible\" (standards-compliant)\n * mode, false otherwise.\n * @param {!Document} doc The document to check.\n * @return {boolean} True if in CSS1-compatible mode.\n * @private\n */\ngoog.dom.isCss1CompatMode_ = function(doc) {\n  'use strict';\n  if (goog.dom.COMPAT_MODE_KNOWN_) {\n    return goog.dom.ASSUME_STANDARDS_MODE;\n  }\n\n  return doc.compatMode == 'CSS1Compat';\n};\n\n\n/**\n * Determines if the given node can contain children, intended to be used for\n * HTML generation.\n *\n * IE natively supports node.canHaveChildren but has inconsistent behavior.\n * Prior to IE8 the base tag allows children and in IE9 all nodes return true\n * for canHaveChildren.\n *\n * In practice all non-IE browsers allow you to add children to any node, but\n * the behavior is inconsistent:\n *\n * <pre>\n *   var a = goog.dom.createElement(goog.dom.TagName.BR);\n *   a.appendChild(document.createTextNode('foo'));\n *   a.appendChild(document.createTextNode('bar'));\n *   console.log(a.childNodes.length);  // 2\n *   console.log(a.innerHTML);  // Chrome: \"\", IE9: \"foobar\", FF3.5: \"foobar\"\n * </pre>\n *\n * For more information, see:\n * http://dev.w3.org/html5/markup/syntax.html#syntax-elements\n *\n * TODO(user): Rename shouldAllowChildren() ?\n *\n * @param {Node} node The node to check.\n * @return {boolean} Whether the node can contain children.\n */\ngoog.dom.canHaveChildren = function(node) {\n  'use strict';\n  if (node.nodeType != goog.dom.NodeType.ELEMENT) {\n    return false;\n  }\n  switch (/** @type {!Element} */ (node).tagName) {\n    case String(goog.dom.TagName.APPLET):\n    case String(goog.dom.TagName.AREA):\n    case String(goog.dom.TagName.BASE):\n    case String(goog.dom.TagName.BR):\n    case String(goog.dom.TagName.COL):\n    case String(goog.dom.TagName.COMMAND):\n    case String(goog.dom.TagName.EMBED):\n    case String(goog.dom.TagName.FRAME):\n    case String(goog.dom.TagName.HR):\n    case String(goog.dom.TagName.IMG):\n    case String(goog.dom.TagName.INPUT):\n    case String(goog.dom.TagName.IFRAME):\n    case String(goog.dom.TagName.ISINDEX):\n    case String(goog.dom.TagName.KEYGEN):\n    case String(goog.dom.TagName.LINK):\n    case String(goog.dom.TagName.NOFRAMES):\n    case String(goog.dom.TagName.NOSCRIPT):\n    case String(goog.dom.TagName.META):\n    case String(goog.dom.TagName.OBJECT):\n    case String(goog.dom.TagName.PARAM):\n    case String(goog.dom.TagName.SCRIPT):\n    case String(goog.dom.TagName.SOURCE):\n    case String(goog.dom.TagName.STYLE):\n    case String(goog.dom.TagName.TRACK):\n    case String(goog.dom.TagName.WBR):\n      return false;\n  }\n  return true;\n};\n\n\n/**\n * Appends a child to a node.\n * @param {Node} parent Parent.\n * @param {Node} child Child.\n */\ngoog.dom.appendChild = function(parent, child) {\n  'use strict';\n  goog.asserts.assert(\n      parent != null && child != null,\n      'goog.dom.appendChild expects non-null arguments');\n  parent.appendChild(child);\n};\n\n\n/**\n * Appends a node with text or other nodes.\n * @param {!Node} parent The node to append nodes to.\n * @param {...goog.dom.Appendable} var_args The things to append to the node.\n *     If this is a Node it is appended as is.\n *     If this is a string then a text node is appended.\n *     If this is an array like object then fields 0 to length - 1 are appended.\n */\ngoog.dom.append = function(parent, var_args) {\n  'use strict';\n  goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);\n};\n\n\n/**\n * Removes all the child nodes on a DOM node.\n * @param {Node} node Node to remove children from.\n */\ngoog.dom.removeChildren = function(node) {\n  'use strict';\n  // Note: Iterations over live collections can be slow, this is the fastest\n  // we could find. The double parenthesis are used to prevent JsCompiler and\n  // strict warnings.\n  var child;\n  while ((child = node.firstChild)) {\n    node.removeChild(child);\n  }\n};\n\n\n/**\n * Inserts a new node before an existing reference node (i.e. as the previous\n * sibling). If the reference node has no parent, then does nothing.\n * @param {Node} newNode Node to insert.\n * @param {Node} refNode Reference node to insert before.\n */\ngoog.dom.insertSiblingBefore = function(newNode, refNode) {\n  'use strict';\n  goog.asserts.assert(\n      newNode != null && refNode != null,\n      'goog.dom.insertSiblingBefore expects non-null arguments');\n  if (refNode.parentNode) {\n    refNode.parentNode.insertBefore(newNode, refNode);\n  }\n};\n\n\n/**\n * Inserts a new node after an existing reference node (i.e. as the next\n * sibling). If the reference node has no parent, then does nothing.\n * @param {Node} newNode Node to insert.\n * @param {Node} refNode Reference node to insert after.\n */\ngoog.dom.insertSiblingAfter = function(newNode, refNode) {\n  'use strict';\n  goog.asserts.assert(\n      newNode != null && refNode != null,\n      'goog.dom.insertSiblingAfter expects non-null arguments');\n  if (refNode.parentNode) {\n    refNode.parentNode.insertBefore(newNode, refNode.nextSibling);\n  }\n};\n\n\n/**\n * Insert a child at a given index. If index is larger than the number of child\n * nodes that the parent currently has, the node is inserted as the last child\n * node.\n * @param {Element} parent The element into which to insert the child.\n * @param {Node} child The element to insert.\n * @param {number} index The index at which to insert the new child node. Must\n *     not be negative.\n */\ngoog.dom.insertChildAt = function(parent, child, index) {\n  'use strict';\n  // Note that if the second argument is null, insertBefore\n  // will append the child at the end of the list of children.\n  goog.asserts.assert(\n      parent != null, 'goog.dom.insertChildAt expects a non-null parent');\n  parent.insertBefore(\n      /** @type {!Node} */ (child), parent.childNodes[index] || null);\n};\n\n\n/**\n * Removes a node from its parent.\n * @param {Node} node The node to remove.\n * @return {Node} The node removed if removed; else, null.\n */\ngoog.dom.removeNode = function(node) {\n  'use strict';\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n};\n\n\n/**\n * Replaces a node in the DOM tree. Will do nothing if `oldNode` has no\n * parent.\n * @param {Node} newNode Node to insert.\n * @param {Node} oldNode Node to replace.\n */\ngoog.dom.replaceNode = function(newNode, oldNode) {\n  'use strict';\n  goog.asserts.assert(\n      newNode != null && oldNode != null,\n      'goog.dom.replaceNode expects non-null arguments');\n  var parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n};\n\n\n/**\n * Replaces child nodes of `target` with child nodes of `source`. This is\n * roughly equivalent to `target.innerHTML = source.innerHTML` which is not\n * compatible with Trusted Types.\n * @param {?Node} target Node to clean and replace its children.\n * @param {?Node} source Node to get the children from. The nodes will be cloned\n *     so they will stay in source.\n */\ngoog.dom.copyContents = function(target, source) {\n  'use strict';\n  goog.asserts.assert(\n      target != null && source != null,\n      'goog.dom.copyContents expects non-null arguments');\n  var childNodes = source.cloneNode(/* deep= */ true).childNodes;\n  goog.dom.removeChildren(target);\n  while (childNodes.length) {\n    target.appendChild(childNodes[0]);\n  }\n};\n\n\n/**\n * Flattens an element. That is, removes it and replace it with its children.\n * Does nothing if the element is not in the document.\n * @param {Element} element The element to flatten.\n * @return {Element|undefined} The original element, detached from the document\n *     tree, sans children; or undefined, if the element was not in the document\n *     to begin with.\n */\ngoog.dom.flattenElement = function(element) {\n  'use strict';\n  var child, parent = element.parentNode;\n  if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {\n    // Use IE DOM method (supported by Opera too) if available\n    if (element.removeNode) {\n      return /** @type {Element} */ (element.removeNode(false));\n    } else {\n      // Move all children of the original node up one level.\n      while ((child = element.firstChild)) {\n        parent.insertBefore(child, element);\n      }\n\n      // Detach the original element.\n      return /** @type {Element} */ (goog.dom.removeNode(element));\n    }\n  }\n};\n\n\n/**\n * Returns an array containing just the element children of the given element.\n * @param {Element} element The element whose element children we want.\n * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list\n *     of just the element children of the given element.\n */\ngoog.dom.getChildren = function(element) {\n  'use strict';\n  // We check if the children attribute is supported for child elements\n  // since IE8 misuses the attribute by also including comments.\n  if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE &&\n      element.children != undefined) {\n    return element.children;\n  }\n  // Fall back to manually filtering the element's child nodes.\n  return goog.array.filter(element.childNodes, function(node) {\n    'use strict';\n    return node.nodeType == goog.dom.NodeType.ELEMENT;\n  });\n};\n\n\n/**\n * Returns the first child node that is an element.\n * @param {Node} node The node to get the first child element of.\n * @return {Element} The first child node of `node` that is an element.\n */\ngoog.dom.getFirstElementChild = function(node) {\n  'use strict';\n  if (node.firstElementChild !== undefined) {\n    return /** @type {!Element} */ (node).firstElementChild;\n  }\n  return goog.dom.getNextElementNode_(node.firstChild, true);\n};\n\n\n/**\n * Returns the last child node that is an element.\n * @param {Node} node The node to get the last child element of.\n * @return {Element} The last child node of `node` that is an element.\n */\ngoog.dom.getLastElementChild = function(node) {\n  'use strict';\n  if (node.lastElementChild !== undefined) {\n    return /** @type {!Element} */ (node).lastElementChild;\n  }\n  return goog.dom.getNextElementNode_(node.lastChild, false);\n};\n\n\n/**\n * Returns the first next sibling that is an element.\n * @param {Node} node The node to get the next sibling element of.\n * @return {Element} The next sibling of `node` that is an element.\n */\ngoog.dom.getNextElementSibling = function(node) {\n  'use strict';\n  if (node.nextElementSibling !== undefined) {\n    return /** @type {!Element} */ (node).nextElementSibling;\n  }\n  return goog.dom.getNextElementNode_(node.nextSibling, true);\n};\n\n\n/**\n * Returns the first previous sibling that is an element.\n * @param {Node} node The node to get the previous sibling element of.\n * @return {Element} The first previous sibling of `node` that is\n *     an element.\n */\ngoog.dom.getPreviousElementSibling = function(node) {\n  'use strict';\n  if (node.previousElementSibling !== undefined) {\n    return /** @type {!Element} */ (node).previousElementSibling;\n  }\n  return goog.dom.getNextElementNode_(node.previousSibling, false);\n};\n\n\n/**\n * Returns the first node that is an element in the specified direction,\n * starting with `node`.\n * @param {Node} node The node to get the next element from.\n * @param {boolean} forward Whether to look forwards or backwards.\n * @return {Element} The first element.\n * @private\n */\ngoog.dom.getNextElementNode_ = function(node, forward) {\n  'use strict';\n  while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {\n    node = forward ? node.nextSibling : node.previousSibling;\n  }\n\n  return /** @type {Element} */ (node);\n};\n\n\n/**\n * Returns the next node in source order from the given node.\n * @param {Node} node The node.\n * @return {Node} The next node in the DOM tree, or null if this was the last\n *     node.\n */\ngoog.dom.getNextNode = function(node) {\n  'use strict';\n  if (!node) {\n    return null;\n  }\n\n  if (node.firstChild) {\n    return node.firstChild;\n  }\n\n  while (node && !node.nextSibling) {\n    node = node.parentNode;\n  }\n\n  return node ? node.nextSibling : null;\n};\n\n\n/**\n * Returns the previous node in source order from the given node.\n * @param {Node} node The node.\n * @return {Node} The previous node in the DOM tree, or null if this was the\n *     first node.\n */\ngoog.dom.getPreviousNode = function(node) {\n  'use strict';\n  if (!node) {\n    return null;\n  }\n\n  if (!node.previousSibling) {\n    return node.parentNode;\n  }\n\n  node = node.previousSibling;\n  while (node && node.lastChild) {\n    node = node.lastChild;\n  }\n\n  return node;\n};\n\n\n/**\n * Whether the object looks like a DOM node.\n * @param {?} obj The object being tested for node likeness.\n * @return {boolean} Whether the object looks like a DOM node.\n */\ngoog.dom.isNodeLike = function(obj) {\n  'use strict';\n  return goog.isObject(obj) && obj.nodeType > 0;\n};\n\n\n/**\n * Whether the object looks like an Element.\n * @param {?} obj The object being tested for Element likeness.\n * @return {boolean} Whether the object looks like an Element.\n */\ngoog.dom.isElement = function(obj) {\n  'use strict';\n  return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;\n};\n\n\n/**\n * Returns true if the specified value is a Window object. This includes the\n * global window for HTML pages, and iframe windows.\n * @param {?} obj Variable to test.\n * @return {boolean} Whether the variable is a window.\n */\ngoog.dom.isWindow = function(obj) {\n  'use strict';\n  return goog.isObject(obj) && obj['window'] == obj;\n};\n\n\n/**\n * Returns an element's parent, if it's an Element.\n * @param {Element} element The DOM element.\n * @return {Element} The parent, or null if not an Element.\n */\ngoog.dom.getParentElement = function(element) {\n  'use strict';\n  var parent;\n  if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {\n    var isIe9 = goog.userAgent.IE && goog.userAgent.isVersionOrHigher('9') &&\n        !goog.userAgent.isVersionOrHigher('10');\n    // SVG elements in IE9 can't use the parentElement property.\n    // goog.global['SVGElement'] is not defined in IE9 quirks mode.\n    if (!(isIe9 && goog.global['SVGElement'] &&\n          element instanceof goog.global['SVGElement'])) {\n      parent = element.parentElement;\n      if (parent) {\n        return parent;\n      }\n    }\n  }\n  parent = element.parentNode;\n  return goog.dom.isElement(parent) ? /** @type {!Element} */ (parent) : null;\n};\n\n\n/**\n * Whether a node contains another node.\n * @param {?Node|undefined} parent The node that should contain the other node.\n * @param {?Node|undefined} descendant The node to test presence of.\n * @return {boolean} Whether the parent node contains the descendant node.\n */\ngoog.dom.contains = function(parent, descendant) {\n  'use strict';\n  if (!parent || !descendant) {\n    return false;\n  }\n  // We use browser specific methods for this if available since it is faster\n  // that way.\n\n  // IE DOM\n  if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {\n    return parent == descendant || parent.contains(descendant);\n  }\n\n  // W3C DOM Level 3\n  if (typeof parent.compareDocumentPosition != 'undefined') {\n    return parent == descendant ||\n        Boolean(parent.compareDocumentPosition(descendant) & 16);\n  }\n\n  // W3C DOM Level 1\n  while (descendant && parent != descendant) {\n    descendant = descendant.parentNode;\n  }\n  return descendant == parent;\n};\n\n\n/**\n * Compares the document order of two nodes, returning 0 if they are the same\n * node, a negative number if node1 is before node2, and a positive number if\n * node2 is before node1.  Note that we compare the order the tags appear in the\n * document so in the tree <b><i>text</i></b> the B node is considered to be\n * before the I node.\n *\n * @param {Node} node1 The first node to compare.\n * @param {Node} node2 The second node to compare.\n * @return {number} 0 if the nodes are the same node, a negative number if node1\n *     is before node2, and a positive number if node2 is before node1.\n */\ngoog.dom.compareNodeOrder = function(node1, node2) {\n  'use strict';\n  // Fall out quickly for equality.\n  if (node1 == node2) {\n    return 0;\n  }\n\n  // Use compareDocumentPosition where available\n  if (node1.compareDocumentPosition) {\n    // 4 is the bitmask for FOLLOWS.\n    return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;\n  }\n\n  // Special case for document nodes on IE 7 and 8.\n  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {\n    if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {\n      return -1;\n    }\n    if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {\n      return 1;\n    }\n  }\n\n  // Process in IE using sourceIndex - we check to see if the first node has\n  // a source index or if its parent has one.\n  if ('sourceIndex' in node1 ||\n      (node1.parentNode && 'sourceIndex' in node1.parentNode)) {\n    var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;\n    var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;\n\n    if (isElement1 && isElement2) {\n      return node1.sourceIndex - node2.sourceIndex;\n    } else {\n      var parent1 = node1.parentNode;\n      var parent2 = node2.parentNode;\n\n      if (parent1 == parent2) {\n        return goog.dom.compareSiblingOrder_(node1, node2);\n      }\n\n      if (!isElement1 && goog.dom.contains(parent1, node2)) {\n        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);\n      }\n\n\n      if (!isElement2 && goog.dom.contains(parent2, node1)) {\n        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);\n      }\n\n      return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -\n          (isElement2 ? node2.sourceIndex : parent2.sourceIndex);\n    }\n  }\n\n  // For Safari, we compare ranges.\n  var doc = goog.dom.getOwnerDocument(node1);\n\n  var range1, range2;\n  range1 = doc.createRange();\n  range1.selectNode(node1);\n  range1.collapse(true);\n\n  range2 = doc.createRange();\n  range2.selectNode(node2);\n  range2.collapse(true);\n\n  return range1.compareBoundaryPoints(\n      goog.global['Range'].START_TO_END, range2);\n};\n\n\n/**\n * Utility function to compare the position of two nodes, when\n * `textNode`'s parent is an ancestor of `node`.  If this entry\n * condition is not met, this function will attempt to reference a null object.\n * @param {!Node} textNode The textNode to compare.\n * @param {Node} node The node to compare.\n * @return {number} -1 if node is before textNode, +1 otherwise.\n * @private\n */\ngoog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {\n  'use strict';\n  var parent = textNode.parentNode;\n  if (parent == node) {\n    // If textNode is a child of node, then node comes first.\n    return -1;\n  }\n  var sibling = node;\n  while (sibling.parentNode != parent) {\n    sibling = sibling.parentNode;\n  }\n  return goog.dom.compareSiblingOrder_(sibling, textNode);\n};\n\n\n/**\n * Utility function to compare the position of two nodes known to be non-equal\n * siblings.\n * @param {Node} node1 The first node to compare.\n * @param {!Node} node2 The second node to compare.\n * @return {number} -1 if node1 is before node2, +1 otherwise.\n * @private\n */\ngoog.dom.compareSiblingOrder_ = function(node1, node2) {\n  'use strict';\n  var s = node2;\n  while ((s = s.previousSibling)) {\n    if (s == node1) {\n      // We just found node1 before node2.\n      return -1;\n    }\n  }\n\n  // Since we didn't find it, node1 must be after node2.\n  return 1;\n};\n\n\n/**\n * Find the deepest common ancestor of the given nodes.\n * @param {...Node} var_args The nodes to find a common ancestor of.\n * @return {Node} The common ancestor of the nodes, or null if there is none.\n *     null will only be returned if two or more of the nodes are from different\n *     documents.\n */\ngoog.dom.findCommonAncestor = function(var_args) {\n  'use strict';\n  var i, count = arguments.length;\n  if (!count) {\n    return null;\n  } else if (count == 1) {\n    return arguments[0];\n  }\n\n  var paths = [];\n  var minLength = Infinity;\n  for (i = 0; i < count; i++) {\n    // Compute the list of ancestors.\n    var ancestors = [];\n    var node = arguments[i];\n    while (node) {\n      ancestors.unshift(node);\n      node = node.parentNode;\n    }\n\n    // Save the list for comparison.\n    paths.push(ancestors);\n    minLength = Math.min(minLength, ancestors.length);\n  }\n  var output = null;\n  for (i = 0; i < minLength; i++) {\n    var first = paths[0][i];\n    for (var j = 1; j < count; j++) {\n      if (first != paths[j][i]) {\n        return output;\n      }\n    }\n    output = first;\n  }\n  return output;\n};\n\n\n/**\n * Returns whether node is in a document or detached. Throws an error if node\n * itself is a document. This specifically handles two cases beyond naive use of\n * builtins: (1) it works correctly in IE, and (2) it works for elements from\n * different documents/iframes. If neither of these considerations are relevant\n * then a simple `document.contains(node)` may be used instead.\n * @param {!Node} node\n * @return {boolean}\n */\ngoog.dom.isInDocument = function(node) {\n  'use strict';\n  return (node.ownerDocument.compareDocumentPosition(node) & 16) == 16;\n};\n\n\n/**\n * Returns the owner document for a node.\n * @param {Node|Window} node The node to get the document for.\n * @return {!Document} The document owning the node.\n */\ngoog.dom.getOwnerDocument = function(node) {\n  'use strict';\n  // TODO(nnaze): Update param signature to be non-nullable.\n  goog.asserts.assert(node, 'Node cannot be null or undefined.');\n  return /** @type {!Document} */ (\n      node.nodeType == goog.dom.NodeType.DOCUMENT ? node : node.ownerDocument ||\n              node.document);\n};\n\n\n/**\n * Cross-browser function for getting the document element of a frame or iframe.\n * @param {Element} frame Frame element.\n * @return {!Document} The frame content document.\n */\ngoog.dom.getFrameContentDocument = function(frame) {\n  'use strict';\n  return frame.contentDocument ||\n      /** @type {!HTMLFrameElement} */ (frame).contentWindow.document;\n};\n\n\n/**\n * Cross-browser function for getting the window of a frame or iframe.\n * @param {Element} frame Frame element.\n * @return {Window} The window associated with the given frame, or null if none\n *     exists.\n */\ngoog.dom.getFrameContentWindow = function(frame) {\n  'use strict';\n  try {\n    return frame.contentWindow ||\n        (frame.contentDocument ? goog.dom.getWindow(frame.contentDocument) :\n                                 null);\n  } catch (e) {\n    // NOTE(user): In IE8, checking the contentWindow or contentDocument\n    // properties will throw a \"Unspecified Error\" exception if the iframe is\n    // not inserted in the DOM. If we get this we can be sure that no window\n    // exists, so return null.\n  }\n  return null;\n};\n\n\n/**\n * Sets the text content of a node, with cross-browser support.\n * @param {Node} node The node to change the text content of.\n * @param {string|number} text The value that should replace the node's content.\n */\ngoog.dom.setTextContent = function(node, text) {\n  'use strict';\n  goog.asserts.assert(\n      node != null,\n      'goog.dom.setTextContent expects a non-null value for node');\n\n  if ('textContent' in node) {\n    node.textContent = text;\n  } else if (node.nodeType == goog.dom.NodeType.TEXT) {\n    /** @type {!Text} */ (node).data = String(text);\n  } else if (\n      node.firstChild && node.firstChild.nodeType == goog.dom.NodeType.TEXT) {\n    // If the first child is a text node we just change its data and remove the\n    // rest of the children.\n    while (node.lastChild != node.firstChild) {\n      node.removeChild(goog.asserts.assert(node.lastChild));\n    }\n    /** @type {!Text} */ (node.firstChild).data = String(text);\n  } else {\n    goog.dom.removeChildren(node);\n    var doc = goog.dom.getOwnerDocument(node);\n    node.appendChild(doc.createTextNode(String(text)));\n  }\n};\n\n\n/**\n * Gets the outerHTML of a node, which is like innerHTML, except that it\n * actually contains the HTML of the node itself.\n * @param {Element} element The element to get the HTML of.\n * @return {string} The outerHTML of the given element.\n */\ngoog.dom.getOuterHtml = function(element) {\n  'use strict';\n  goog.asserts.assert(\n      element !== null,\n      'goog.dom.getOuterHtml expects a non-null value for element');\n  // IE, Opera and WebKit all have outerHTML.\n  if ('outerHTML' in element) {\n    return element.outerHTML;\n  } else {\n    var doc = goog.dom.getOwnerDocument(element);\n    var div = goog.dom.createElement_(doc, goog.dom.TagName.DIV);\n    div.appendChild(element.cloneNode(true));\n    return div.innerHTML;\n  }\n};\n\n\n/**\n * Finds the first descendant node that matches the filter function, using depth\n * first search. This function offers the most general purpose way of finding a\n * matching element.\n *\n * Prefer using `querySelector` if the matching criteria can be expressed as a\n * CSS selector, or `goog.dom.findElement` if you would filter for `nodeType ==\n * Node.ELEMENT_NODE`.\n *\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @return {Node|undefined} The found node or undefined if none is found.\n */\ngoog.dom.findNode = function(root, p) {\n  'use strict';\n  var rv = [];\n  var found = goog.dom.findNodes_(root, p, rv, true);\n  return found ? rv[0] : undefined;\n};\n\n\n/**\n * Finds all the descendant nodes that match the filter function, using depth\n * first search. This function offers the most general-purpose way\n * of finding a set of matching elements.\n *\n * Prefer using `querySelectorAll` if the matching criteria can be expressed as\n * a CSS selector, or `goog.dom.findElements` if you would filter for\n * `nodeType == Node.ELEMENT_NODE`.\n *\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @return {!Array<!Node>} The found nodes or an empty array if none are found.\n */\ngoog.dom.findNodes = function(root, p) {\n  'use strict';\n  var rv = [];\n  goog.dom.findNodes_(root, p, rv, false);\n  return rv;\n};\n\n\n/**\n * Finds the first or all the descendant nodes that match the filter function,\n * using a depth first search.\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @param {!Array<!Node>} rv The found nodes are added to this array.\n * @param {boolean} findOne If true we exit after the first found node.\n * @return {boolean} Whether the search is complete or not. True in case findOne\n *     is true and the node is found. False otherwise.\n * @private\n */\ngoog.dom.findNodes_ = function(root, p, rv, findOne) {\n  'use strict';\n  if (root != null) {\n    var child = root.firstChild;\n    while (child) {\n      if (p(child)) {\n        rv.push(child);\n        if (findOne) {\n          return true;\n        }\n      }\n      if (goog.dom.findNodes_(child, p, rv, findOne)) {\n        return true;\n      }\n      child = child.nextSibling;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Finds the first descendant element (excluding `root`) that matches the filter\n * function, using depth first search. Prefer using `querySelector` if the\n * matching criteria can be expressed as a CSS selector.\n *\n * @param {!Element | !Document} root\n * @param {function(!Element): boolean} pred Filter function.\n * @return {?Element} First matching element or null if there is none.\n */\ngoog.dom.findElement = function(root, pred) {\n  'use strict';\n  var stack = goog.dom.getChildrenReverse_(root);\n  while (stack.length > 0) {\n    var next = stack.pop();\n    if (pred(next)) return next;\n    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {\n      stack.push(c);\n    }\n  }\n  return null;\n};\n\n\n/**\n * Finds all the descendant elements (excluding `root`) that match the filter\n * function, using depth first search. Prefer using `querySelectorAll` if the\n * matching criteria can be expressed as a CSS selector.\n *\n * @param {!Element | !Document} root\n * @param {function(!Element): boolean} pred Filter function.\n * @return {!Array<!Element>}\n */\ngoog.dom.findElements = function(root, pred) {\n  'use strict';\n  var result = [], stack = goog.dom.getChildrenReverse_(root);\n  while (stack.length > 0) {\n    var next = stack.pop();\n    if (pred(next)) result.push(next);\n    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {\n      stack.push(c);\n    }\n  }\n  return result;\n};\n\n\n/**\n * @param {!Element | !Document} node\n * @return {!Array<!Element>} node's child elements in reverse order.\n * @private\n */\ngoog.dom.getChildrenReverse_ = function(node) {\n  'use strict';\n  // document.lastElementChild doesn't exist in IE9; fall back to\n  // documentElement.\n  if (node.nodeType == goog.dom.NodeType.DOCUMENT) {\n    return [node.documentElement];\n  } else {\n    var children = [];\n    for (var c = node.lastElementChild; c; c = c.previousElementSibling) {\n      children.push(c);\n    }\n    return children;\n  }\n};\n\n\n/**\n * Map of tags whose content to ignore when calculating text length.\n * @private {!Object<string, number>}\n * @const\n */\ngoog.dom.TAGS_TO_IGNORE_ = {\n  'SCRIPT': 1,\n  'STYLE': 1,\n  'HEAD': 1,\n  'IFRAME': 1,\n  'OBJECT': 1\n};\n\n\n/**\n * Map of tags which have predefined values with regard to whitespace.\n * @private {!Object<string, string>}\n * @const\n */\ngoog.dom.PREDEFINED_TAG_VALUES_ = {\n  'IMG': ' ',\n  'BR': '\\n'\n};\n\n\n/**\n * Returns true if the element has a tab index that allows it to receive\n * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements\n * natively support keyboard focus, even if they have no tab index.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element has a tab index that allows keyboard\n *     focus.\n */\ngoog.dom.isFocusableTabIndex = function(element) {\n  'use strict';\n  return goog.dom.hasSpecifiedTabIndex_(element) &&\n      goog.dom.isTabIndexFocusable_(element);\n};\n\n\n/**\n * Enables or disables keyboard focus support on the element via its tab index.\n * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true\n * (or elements that natively support keyboard focus, like form elements) can\n * receive keyboard focus.  See http://go/tabindex for more info.\n * @param {Element} element Element whose tab index is to be changed.\n * @param {boolean} enable Whether to set or remove a tab index on the element\n *     that supports keyboard focus.\n */\ngoog.dom.setFocusableTabIndex = function(element, enable) {\n  'use strict';\n  if (enable) {\n    element.tabIndex = 0;\n  } else {\n    // Set tabIndex to -1 first, then remove it. This is a workaround for\n    // Safari (confirmed in version 4 on Windows). When removing the attribute\n    // without setting it to -1 first, the element remains keyboard focusable\n    // despite not having a tabIndex attribute anymore.\n    element.tabIndex = -1;\n    element.removeAttribute('tabIndex');  // Must be camelCase!\n  }\n};\n\n\n/**\n * Returns true if the element can be focused, i.e. it has a tab index that\n * allows it to receive keyboard focus (tabIndex >= 0), or it is an element\n * that natively supports keyboard focus.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element allows keyboard focus.\n */\ngoog.dom.isFocusable = function(element) {\n  'use strict';\n  var focusable;\n  // Some elements can have unspecified tab index and still receive focus.\n  if (goog.dom.nativelySupportsFocus_(element)) {\n    // Make sure the element is not disabled ...\n    focusable = !element.disabled &&\n        // ... and if a tab index is specified, it allows focus.\n        (!goog.dom.hasSpecifiedTabIndex_(element) ||\n         goog.dom.isTabIndexFocusable_(element));\n  } else {\n    focusable = goog.dom.isFocusableTabIndex(element);\n  }\n\n  // IE requires elements to be visible in order to focus them.\n  return focusable && goog.userAgent.IE ?\n      goog.dom.hasNonZeroBoundingRect_(/** @type {!HTMLElement} */ (element)) :\n      focusable;\n};\n\n\n/**\n * Returns true if the element has a specified tab index.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element has a specified tab index.\n * @private\n */\ngoog.dom.hasSpecifiedTabIndex_ = function(element) {\n  'use strict';\n  // IE8 and below don't support hasAttribute(), instead check whether the\n  // 'tabindex' attributeNode is specified. Otherwise check hasAttribute().\n  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')) {\n    var attrNode = element.getAttributeNode('tabindex');  // Must be lowercase!\n    return attrNode != null && attrNode.specified;\n  } else {\n    return element.hasAttribute('tabindex');\n  }\n};\n\n\n/**\n * Returns true if the element's tab index allows the element to be focused.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element's tab index allows focus.\n * @private\n */\ngoog.dom.isTabIndexFocusable_ = function(element) {\n  'use strict';\n  var index = /** @type {!HTMLElement} */ (element).tabIndex;\n  // NOTE: IE9 puts tabIndex in 16-bit int, e.g. -2 is 65534.\n  return typeof (index) === 'number' && index >= 0 && index < 32768;\n};\n\n\n/**\n * Returns true if the element is focusable even when tabIndex is not set.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element natively supports focus.\n * @private\n */\ngoog.dom.nativelySupportsFocus_ = function(element) {\n  'use strict';\n  return (\n      element.tagName == goog.dom.TagName.A && element.hasAttribute('href') ||\n      element.tagName == goog.dom.TagName.INPUT ||\n      element.tagName == goog.dom.TagName.TEXTAREA ||\n      element.tagName == goog.dom.TagName.SELECT ||\n      element.tagName == goog.dom.TagName.BUTTON);\n};\n\n\n/**\n * Returns true if the element has a bounding rectangle that would be visible\n * (i.e. its width and height are greater than zero).\n * @param {!HTMLElement} element Element to check.\n * @return {boolean} Whether the element has a non-zero bounding rectangle.\n * @private\n */\ngoog.dom.hasNonZeroBoundingRect_ = function(element) {\n  'use strict';\n  var rect;\n  if (typeof element['getBoundingClientRect'] !== 'function' ||\n      // In IE, getBoundingClientRect throws on detached nodes.\n      (goog.userAgent.IE && element.parentElement == null)) {\n    rect = {'height': element.offsetHeight, 'width': element.offsetWidth};\n  } else {\n    rect = element.getBoundingClientRect();\n  }\n  return rect != null && rect.height > 0 && rect.width > 0;\n};\n\n\n/**\n * Returns the text content of the current node, without markup and invisible\n * symbols. New lines are stripped and whitespace is collapsed,\n * such that each character would be visible.\n *\n * In browsers that support it, innerText is used.  Other browsers attempt to\n * simulate it via node traversal.  Line breaks are canonicalized in IE.\n *\n * @param {Node} node The node from which we are getting content.\n * @return {string} The text content.\n */\ngoog.dom.getTextContent = function(node) {\n  'use strict';\n  var textContent;\n  // Note(arv): IE9, Opera, and Safari 3 support innerText but they include\n  // text nodes in script tags. So we revert to use a user agent test here.\n  if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && node !== null &&\n      ('innerText' in node)) {\n    textContent = goog.string.canonicalizeNewlines(node.innerText);\n    // Unfortunately .innerText() returns text with &shy; symbols\n    // We need to filter it out and then remove duplicate whitespaces\n  } else {\n    var buf = [];\n    goog.dom.getTextContent_(node, buf, true);\n    textContent = buf.join('');\n  }\n\n  // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.\n  textContent = textContent.replace(/ \\xAD /g, ' ').replace(/\\xAD/g, '');\n  // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.\n  textContent = textContent.replace(/\\u200B/g, '');\n\n  // Skip this replacement on old browsers with working innerText, which\n  // automatically turns &nbsp; into ' ' and / +/ into ' ' when reading\n  // innerText.\n  if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) {\n    textContent = textContent.replace(/ +/g, ' ');\n  }\n  if (textContent != ' ') {\n    textContent = textContent.replace(/^\\s*/, '');\n  }\n\n  return textContent;\n};\n\n\n/**\n * Returns the text content of the current node, without markup.\n *\n * Unlike `getTextContent` this method does not collapse whitespaces\n * or normalize lines breaks.\n *\n * @param {Node} node The node from which we are getting content.\n * @return {string} The raw text content.\n */\ngoog.dom.getRawTextContent = function(node) {\n  'use strict';\n  var buf = [];\n  goog.dom.getTextContent_(node, buf, false);\n\n  return buf.join('');\n};\n\n\n/**\n * Recursive support function for text content retrieval.\n *\n * @param {Node} node The node from which we are getting content.\n * @param {Array<string>} buf string buffer.\n * @param {boolean} normalizeWhitespace Whether to normalize whitespace.\n * @private\n */\ngoog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {\n  'use strict';\n  if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {\n    // ignore certain tags\n  } else if (node.nodeType == goog.dom.NodeType.TEXT) {\n    if (normalizeWhitespace) {\n      buf.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      buf.push(node.nodeValue);\n    }\n  } else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {\n    buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);\n  } else {\n    var child = node.firstChild;\n    while (child) {\n      goog.dom.getTextContent_(child, buf, normalizeWhitespace);\n      child = child.nextSibling;\n    }\n  }\n};\n\n\n/**\n * Returns the text length of the text contained in a node, without markup. This\n * is equivalent to the selection length if the node was selected, or the number\n * of cursor movements to traverse the node. Images & BRs take one space.  New\n * lines are ignored.\n *\n * @param {Node} node The node whose text content length is being calculated.\n * @return {number} The length of `node`'s text content.\n */\ngoog.dom.getNodeTextLength = function(node) {\n  'use strict';\n  return goog.dom.getTextContent(node).length;\n};\n\n\n/**\n * Returns the text offset of a node relative to one of its ancestors. The text\n * length is the same as the length calculated by goog.dom.getNodeTextLength.\n *\n * @param {Node} node The node whose offset is being calculated.\n * @param {Node=} opt_offsetParent The node relative to which the offset will\n *     be calculated. Defaults to the node's owner document's body.\n * @return {number} The text offset.\n */\ngoog.dom.getNodeTextOffset = function(node, opt_offsetParent) {\n  'use strict';\n  var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;\n  var buf = [];\n  while (node && node != root) {\n    var cur = node;\n    while ((cur = cur.previousSibling)) {\n      buf.unshift(goog.dom.getTextContent(cur));\n    }\n    node = node.parentNode;\n  }\n  // Trim left to deal with FF cases when there might be line breaks and empty\n  // nodes at the front of the text\n  return goog.string.trimLeft(buf.join('')).replace(/ +/g, ' ').length;\n};\n\n\n/**\n * Returns the node at a given offset in a parent node.  If an object is\n * provided for the optional third parameter, the node and the remainder of the\n * offset will stored as properties of this object.\n * @param {Node} parent The parent node.\n * @param {number} offset The offset into the parent node.\n * @param {Object=} opt_result Object to be used to store the return value. The\n *     return value will be stored in the form {node: Node, remainder: number}\n *     if this object is provided.\n * @return {Node} The node at the given offset.\n */\ngoog.dom.getNodeAtOffset = function(parent, offset, opt_result) {\n  'use strict';\n  var stack = [parent], pos = 0, cur = null;\n  while (stack.length > 0 && pos < offset) {\n    cur = stack.pop();\n    if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {\n      // ignore certain tags\n    } else if (cur.nodeType == goog.dom.NodeType.TEXT) {\n      var text = cur.nodeValue.replace(/(\\r\\n|\\r|\\n)/g, '').replace(/ +/g, ' ');\n      pos += text.length;\n    } else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {\n      pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;\n    } else {\n      for (var i = cur.childNodes.length - 1; i >= 0; i--) {\n        stack.push(cur.childNodes[i]);\n      }\n    }\n  }\n  if (goog.isObject(opt_result)) {\n    opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;\n    opt_result.node = cur;\n  }\n\n  return cur;\n};\n\n\n/**\n * Returns true if the object is a `NodeList`.  To qualify as a NodeList,\n * the object must have a numeric length property and an item function (which\n * has type 'string' on IE for some reason).\n * @param {Object} val Object to test.\n * @return {boolean} Whether the object is a NodeList.\n */\ngoog.dom.isNodeList = function(val) {\n  'use strict';\n  // TODO(attila): Now the isNodeList is part of goog.dom we can use\n  // goog.userAgent to make this simpler.\n  // A NodeList must have a length property of type 'number' on all platforms.\n  if (val && typeof val.length == 'number') {\n    // A NodeList is an object everywhere except Safari, where it's a function.\n    if (goog.isObject(val)) {\n      // A NodeList must have an item function (on non-IE platforms) or an item\n      // property of type 'string' (on IE).\n      return typeof val.item == 'function' || typeof val.item == 'string';\n    } else if (typeof val === 'function') {\n      // On Safari, a NodeList is a function with an item property that is also\n      // a function.\n      return typeof /** @type {?} */ (val.item) == 'function';\n    }\n  }\n\n  // Not a NodeList.\n  return false;\n};\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\n * tag name and/or class name. If the passed element matches the specified\n * criteria, the element itself is returned.\n * @param {Node} element The DOM node to start with.\n * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or\n *     null/undefined to match only based on class name).\n * @param {?string=} opt_class The class name to match (or null/undefined to\n *     match only based on tag name).\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {?R} The first ancestor that matches the passed criteria, or\n *     null if no match is found. The return type is {?Element} if opt_tag is\n *     not a member of goog.dom.TagName or a more specific type if it is (e.g.\n *     {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.getAncestorByTagNameAndClass = function(\n    element, opt_tag, opt_class, opt_maxSearchSteps) {\n  'use strict';\n  if (!opt_tag && !opt_class) {\n    return null;\n  }\n  var tagName = opt_tag ? String(opt_tag).toUpperCase() : null;\n  return /** @type {Element} */ (goog.dom.getAncestor(element, function(node) {\n    'use strict';\n    return (!tagName || node.nodeName == tagName) &&\n        (!opt_class ||\n         typeof node.className === 'string' &&\n             goog.array.contains(node.className.split(/\\s+/), opt_class));\n  }, true, opt_maxSearchSteps));\n};\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\n * class name. If the passed element matches the specified criteria, the\n * element itself is returned.\n * @param {Node} element The DOM node to start with.\n * @param {string} className The class name to match.\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {Element} The first ancestor that matches the passed criteria, or\n *     null if none match.\n */\ngoog.dom.getAncestorByClass = function(element, className, opt_maxSearchSteps) {\n  'use strict';\n  return goog.dom.getAncestorByTagNameAndClass(\n      element, null, className, opt_maxSearchSteps);\n};\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that passes the\n * matcher function.\n * @param {Node} element The DOM node to start with.\n * @param {function(!Node) : boolean} matcher A function that returns true if\n *     the passed node matches the desired criteria.\n * @param {boolean=} opt_includeNode If true, the node itself is included in\n *     the search (the first call to the matcher will pass startElement as\n *     the node to test).\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {Node} DOM node that matched the matcher, or null if there was\n *     no match.\n */\ngoog.dom.getAncestor = function(\n    element, matcher, opt_includeNode, opt_maxSearchSteps) {\n  'use strict';\n  if (element && !opt_includeNode) {\n    element = element.parentNode;\n  }\n  var steps = 0;\n  while (element &&\n         (opt_maxSearchSteps == null || steps <= opt_maxSearchSteps)) {\n    goog.asserts.assert(element.name != 'parentNode');\n    if (matcher(element)) {\n      return element;\n    }\n    element = element.parentNode;\n    steps++;\n  }\n  // Reached the root of the DOM without a match\n  return null;\n};\n\n\n/**\n * Determines the active element in the given document.\n * @param {Document} doc The document to look in.\n * @return {Element} The active element.\n */\ngoog.dom.getActiveElement = function(doc) {\n  'use strict';\n  // While in an iframe, IE9 will throw \"Unspecified error\" when accessing\n  // activeElement.\n  try {\n    var activeElement = doc && doc.activeElement;\n    // While not in an iframe, IE9-11 sometimes gives null.\n    // While in an iframe, IE11 sometimes returns an empty object.\n    return activeElement && activeElement.nodeName ? activeElement : null;\n  } catch (e) {\n    return null;\n  }\n};\n\n\n/**\n * Gives the current devicePixelRatio.\n *\n * By default, this is the value of window.devicePixelRatio (which should be\n * preferred if present).\n *\n * If window.devicePixelRatio is not present, the ratio is calculated with\n * window.matchMedia, if present. Otherwise, gives 1.0.\n *\n * Some browsers (including Chrome) consider the browser zoom level in the pixel\n * ratio, so the value may change across multiple calls.\n *\n * @return {number} The number of actual pixels per virtual pixel.\n */\ngoog.dom.getPixelRatio = function() {\n  'use strict';\n  var win = goog.dom.getWindow();\n  if (win.devicePixelRatio !== undefined) {\n    return win.devicePixelRatio;\n  } else if (win.matchMedia) {\n    // Should be for IE10 and FF6-17 (this basically clamps to lower)\n    // Note that the order of these statements is important\n    return goog.dom.matchesPixelRatio_(3) || goog.dom.matchesPixelRatio_(2) ||\n           goog.dom.matchesPixelRatio_(1.5) || goog.dom.matchesPixelRatio_(1) ||\n           .75;\n  }\n  return 1;\n};\n\n\n/**\n * Calculates a mediaQuery to check if the current device supports the\n * given actual to virtual pixel ratio.\n * @param {number} pixelRatio The ratio of actual pixels to virtual pixels.\n * @return {number} pixelRatio if applicable, otherwise 0.\n * @private\n */\ngoog.dom.matchesPixelRatio_ = function(pixelRatio) {\n  'use strict';\n  var win = goog.dom.getWindow();\n  /**\n   * Due to the 1:96 fixed ratio of CSS in to CSS px, 1dppx is equivalent to\n   * 96dpi.\n   * @const {number}\n   */\n  var dpiPerDppx = 96;\n  var query =\n      // FF16-17\n      '(min-resolution: ' + pixelRatio + 'dppx),' +\n      // FF6-15\n      '(min--moz-device-pixel-ratio: ' + pixelRatio + '),' +\n      // IE10 (this works for the two browsers above too but I don't want to\n      // trust the 1:96 fixed ratio magic)\n      '(min-resolution: ' + (pixelRatio * dpiPerDppx) + 'dpi)';\n  return win.matchMedia(query).matches ? pixelRatio : 0;\n};\n\n\n/**\n * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a\n * type information.\n * @param {!HTMLCanvasElement|!OffscreenCanvas} canvas\n * @return {!CanvasRenderingContext2D}\n */\ngoog.dom.getCanvasContext2D = function(canvas) {\n  'use strict';\n  return /** @type {!CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n};\n\n\n\n/**\n * Create an instance of a DOM helper with a new document object.\n * @param {Document=} opt_document Document object to associate with this\n *     DOM helper.\n * @constructor\n */\ngoog.dom.DomHelper = function(opt_document) {\n  'use strict';\n  /**\n   * Reference to the document object to use\n   * @type {!Document}\n   * @private\n   */\n  this.document_ = opt_document || goog.global.document || document;\n};\n\n\n/**\n * Gets the dom helper object for the document where the element resides.\n * @param {Node=} opt_node If present, gets the DomHelper for this node.\n * @return {!goog.dom.DomHelper} The DomHelper.\n */\ngoog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;\n\n\n/**\n * Sets the document object.\n * @param {!Document} document Document object.\n */\ngoog.dom.DomHelper.prototype.setDocument = function(document) {\n  'use strict';\n  this.document_ = document;\n};\n\n\n/**\n * Gets the document object being used by the dom library.\n * @return {!Document} Document object.\n */\ngoog.dom.DomHelper.prototype.getDocument = function() {\n  'use strict';\n  return this.document_;\n};\n\n\n/**\n * Alias for `getElementById`. If a DOM node is passed in then we just\n * return that.\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The element with the given ID, or the node passed in.\n */\ngoog.dom.DomHelper.prototype.getElement = function(element) {\n  'use strict';\n  return goog.dom.getElementHelper_(this.document_, element);\n};\n\n\n/**\n * Gets an element by id, asserting that the element is found.\n *\n * This is used when an element is expected to exist, and should fail with\n * an assertion error if it does not (if assertions are enabled).\n *\n * @param {string} id Element ID.\n * @return {!Element} The element with the given ID, if it exists.\n */\ngoog.dom.DomHelper.prototype.getRequiredElement = function(id) {\n  'use strict';\n  return goog.dom.getRequiredElementHelper_(this.document_, id);\n};\n\n\n/**\n * Alias for `getElement`.\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The element with the given ID, or the node passed in.\n * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.\n */\ngoog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;\n\n\n/**\n * Gets elements by tag name.\n * @param {!goog.dom.TagName<T>} tagName\n * @param {(!Document|!Element)=} opt_parent Parent element or document where to\n *     look for elements. Defaults to document of this DomHelper.\n * @return {!NodeList<R>} List of elements. The members of the list are\n *     {!Element} if tagName is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.getElementsByTagName = function(\n    tagName, opt_parent) {\n  'use strict';\n  var parent = opt_parent || this.document_;\n  return parent.getElementsByTagName(String(tagName));\n};\n\n\n/**\n * Looks up elements by both tag and class name, using browser native functions\n * (`querySelectorAll`, `getElementsByTagName` or\n * `getElementsByClassName`) where possible. The returned array is a live\n * NodeList or a static list depending on the code path taken.\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name or * for all\n *     tags.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(\n    opt_tag, opt_class, opt_el) {\n  'use strict';\n  return goog.dom.getElementsByTagNameAndClass_(\n      this.document_, opt_tag, opt_class, opt_el);\n};\n\n\n/**\n * Gets the first element matching the tag and the class.\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {?R} Reference to a DOM node. The return type is {?Element} if\n *     tagName is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.getElementByTagNameAndClass = function(\n    opt_tag, opt_class, opt_el) {\n  'use strict';\n  return goog.dom.getElementByTagNameAndClass_(\n      this.document_, opt_tag, opt_class, opt_el);\n};\n\n\n/**\n * Returns an array of all the elements with the provided className.\n * @param {string} className the name of the class to look for.\n * @param {Element|Document=} opt_el Optional element to look in.\n * @return {!IArrayLike<!Element>} The items found with the class name provided.\n */\ngoog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {\n  'use strict';\n  var doc = opt_el || this.document_;\n  return goog.dom.getElementsByClass(className, doc);\n};\n\n\n/**\n * Returns the first element we find matching the provided class name.\n * @param {string} className the name of the class to look for.\n * @param {(Element|Document)=} opt_el Optional element to look in.\n * @return {Element} The first item found with the class name provided.\n */\ngoog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {\n  'use strict';\n  var doc = opt_el || this.document_;\n  return goog.dom.getElementByClass(className, doc);\n};\n\n\n/**\n * Ensures an element with the given className exists, and then returns the\n * first element with the provided className.\n * @param {string} className the name of the class to look for.\n * @param {(!Element|!Document)=} opt_root Optional element or document to look\n *     in.\n * @return {!Element} The first item found with the class name provided.\n * @throws {goog.asserts.AssertionError} Thrown if no element is found.\n */\ngoog.dom.DomHelper.prototype.getRequiredElementByClass = function(\n    className, opt_root) {\n  'use strict';\n  var root = opt_root || this.document_;\n  return goog.dom.getRequiredElementByClass(className, root);\n};\n\n\n/**\n * Alias for `getElementsByTagNameAndClass`.\n * @deprecated Use DomHelper getElementsByTagNameAndClass.\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {Element=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is a string or more specific types if it is\n *     a member of goog.dom.TagName (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.$$ =\n    goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;\n\n\n/**\n * Sets a number of properties on a node.\n * @param {Element} element DOM node to set properties on.\n * @param {Object} properties Hash of property:value pairs.\n */\ngoog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;\n\n\n/**\n * Gets the dimensions of the viewport.\n * @param {Window=} opt_window Optional window element to test. Defaults to\n *     the window of the Dom Helper.\n * @return {!goog.math.Size} Object with values 'width' and 'height'.\n */\ngoog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {\n  'use strict';\n  // TODO(arv): This should not take an argument. That breaks the rule of a\n  // a DomHelper representing a single frame/window/document.\n  return goog.dom.getViewportSize(opt_window || this.getWindow());\n};\n\n\n/**\n * Calculates the height of the document.\n *\n * @return {number} The height of the document.\n */\ngoog.dom.DomHelper.prototype.getDocumentHeight = function() {\n  'use strict';\n  return goog.dom.getDocumentHeight_(this.getWindow());\n};\n\n\n/**\n * Typedef for use with goog.dom.createDom and goog.dom.append.\n * @typedef {Object|string|Array|NodeList}\n */\ngoog.dom.Appendable;\n\n\n/**\n * Returns a dom node with a set of attributes.  This function accepts varargs\n * for subsequent nodes to be added.  Subsequent nodes will be added to the\n * first node as childNodes.\n *\n * So:\n * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),\n * createDom(goog.dom.TagName.P));</code> would return a div with two child\n * paragraphs\n *\n * An easy way to move all child nodes of an existing element to a new parent\n * element is:\n * <code>createDom(goog.dom.TagName.DIV, null, oldElement.childNodes);</code>\n * which will remove all child nodes from the old element and add them as\n * child nodes of the new DIV.\n *\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\n *     of name-value pairs for attributes. If a string, then this is the\n *     className of the new element. If an array, the elements will be joined\n *     together as the className of the new element.\n * @param {...(goog.dom.Appendable|undefined)} var_args Further DOM nodes or\n *     strings for text nodes. If one of the var_args is an array or\n *     NodeList, its elements will be added as childNodes instead.\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\n *     is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.createDom = function(\n    tagName, opt_attributes, var_args) {\n  'use strict';\n  return goog.dom.createDom_(this.document_, arguments);\n};\n\n\n/**\n * Alias for `createDom`.\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\n *     of name-value pairs for attributes. If a string, then this is the\n *     className of the new element. If an array, the elements will be joined\n *     together as the className of the new element.\n * @param {...(goog.dom.Appendable|undefined)} var_args Further DOM nodes or\n *     strings for text nodes.  If one of the var_args is an array, its children\n *     will be added as childNodes instead.\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\n *     is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.\n */\ngoog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;\n\n\n/**\n * Creates a new element.\n * @param {string|!goog.dom.TagName<T>} name Tag to create.\n * @return {R} The new element. The return type is {!Element} if name is\n *     a string or a more specific type if it is a member of goog.dom.TagName\n *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.createElement = function(name) {\n  'use strict';\n  return goog.dom.createElement_(this.document_, name);\n};\n\n\n/**\n * Creates a new text node.\n * @param {number|string} content Content.\n * @return {!Text} The new text node.\n */\ngoog.dom.DomHelper.prototype.createTextNode = function(content) {\n  'use strict';\n  return this.document_.createTextNode(String(content));\n};\n\n\n/**\n * Create a table.\n * @param {number} rows The number of rows in the table.  Must be >= 1.\n * @param {number} columns The number of columns in the table.  Must be >= 1.\n * @param {boolean=} opt_fillWithNbsp If true, fills table entries with\n *     `goog.string.Unicode.NBSP` characters.\n * @return {!HTMLElement} The created table.\n */\ngoog.dom.DomHelper.prototype.createTable = function(\n    rows, columns, opt_fillWithNbsp) {\n  'use strict';\n  return goog.dom.createTable_(\n      this.document_, rows, columns, !!opt_fillWithNbsp);\n};\n\n\n/**\n * Converts an HTML into a node or a document fragment. A single Node is used if\n * `html` only generates a single node. If `html` generates multiple\n * nodes then these are put inside a `DocumentFragment`. This is a safe\n * version of `goog.dom.DomHelper#htmlToDocumentFragment` which is now\n * deleted.\n * @param {!goog.html.SafeHtml} html The HTML markup to convert.\n * @return {!Node} The resulting node.\n */\ngoog.dom.DomHelper.prototype.safeHtmlToNode = function(html) {\n  'use strict';\n  return goog.dom.safeHtmlToNode_(this.document_, html);\n};\n\n\n/**\n * Returns true if the browser is in \"CSS1-compatible\" (standards-compliant)\n * mode, false otherwise.\n * @return {boolean} True if in CSS1-compatible mode.\n */\ngoog.dom.DomHelper.prototype.isCss1CompatMode = function() {\n  'use strict';\n  return goog.dom.isCss1CompatMode_(this.document_);\n};\n\n\n/**\n * Gets the window object associated with the document.\n * @return {!Window} The window associated with the given document.\n */\ngoog.dom.DomHelper.prototype.getWindow = function() {\n  'use strict';\n  return goog.dom.getWindow_(this.document_);\n};\n\n\n/**\n * Gets the document scroll element.\n * @return {!Element} Scrolling element.\n */\ngoog.dom.DomHelper.prototype.getDocumentScrollElement = function() {\n  'use strict';\n  return goog.dom.getDocumentScrollElement_(this.document_);\n};\n\n\n/**\n * Gets the document scroll distance as a coordinate object.\n * @return {!goog.math.Coordinate} Object with properties 'x' and 'y'.\n */\ngoog.dom.DomHelper.prototype.getDocumentScroll = function() {\n  'use strict';\n  return goog.dom.getDocumentScroll_(this.document_);\n};\n\n\n/**\n * Determines the active element in the given document.\n * @param {Document=} opt_doc The document to look in.\n * @return {Element} The active element.\n */\ngoog.dom.DomHelper.prototype.getActiveElement = function(opt_doc) {\n  'use strict';\n  return goog.dom.getActiveElement(opt_doc || this.document_);\n};\n\n\n/**\n * Appends a child to a node.\n * @param {Node} parent Parent.\n * @param {Node} child Child.\n */\ngoog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;\n\n\n/**\n * Appends a node with text or other nodes.\n * @param {!Node} parent The node to append nodes to.\n * @param {...goog.dom.Appendable} var_args The things to append to the node.\n *     If this is a Node it is appended as is.\n *     If this is a string then a text node is appended.\n *     If this is an array like object then fields 0 to length - 1 are appended.\n */\ngoog.dom.DomHelper.prototype.append = goog.dom.append;\n\n\n/**\n * Determines if the given node can contain children, intended to be used for\n * HTML generation.\n *\n * @param {Node} node The node to check.\n * @return {boolean} Whether the node can contain children.\n */\ngoog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;\n\n\n/**\n * Removes all the child nodes on a DOM node.\n * @param {Node} node Node to remove children from.\n */\ngoog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;\n\n\n/**\n * Inserts a new node before an existing reference node (i.e., as the previous\n * sibling). If the reference node has no parent, then does nothing.\n * @param {Node} newNode Node to insert.\n * @param {Node} refNode Reference node to insert before.\n */\ngoog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;\n\n\n/**\n * Inserts a new node after an existing reference node (i.e., as the next\n * sibling). If the reference node has no parent, then does nothing.\n * @param {Node} newNode Node to insert.\n * @param {Node} refNode Reference node to insert after.\n */\ngoog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;\n\n\n/**\n * Insert a child at a given index. If index is larger than the number of child\n * nodes that the parent currently has, the node is inserted as the last child\n * node.\n * @param {Element} parent The element into which to insert the child.\n * @param {Node} child The element to insert.\n * @param {number} index The index at which to insert the new child node. Must\n *     not be negative.\n */\ngoog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;\n\n\n/**\n * Removes a node from its parent.\n * @param {Node} node The node to remove.\n * @return {Node} The node removed if removed; else, null.\n */\ngoog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;\n\n\n/**\n * Replaces a node in the DOM tree. Will do nothing if `oldNode` has no\n * parent.\n * @param {Node} newNode Node to insert.\n * @param {Node} oldNode Node to replace.\n */\ngoog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;\n\n\n/**\n * Replaces child nodes of `target` with child nodes of `source`. This is\n * roughly equivalent to `target.innerHTML = source.innerHTML` which is not\n * compatible with Trusted Types.\n * @param {?Node} target Node to clean and replace its children.\n * @param {?Node} source Node to get the children from. The nodes will be cloned\n *     so they will stay in source.\n */\ngoog.dom.DomHelper.prototype.copyContents = goog.dom.copyContents;\n\n\n/**\n * Flattens an element. That is, removes it and replace it with its children.\n * @param {Element} element The element to flatten.\n * @return {Element|undefined} The original element, detached from the document\n *     tree, sans children, or undefined if the element was already not in the\n *     document.\n */\ngoog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;\n\n\n/**\n * Returns an array containing just the element children of the given element.\n * @param {Element} element The element whose element children we want.\n * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list\n *     of just the element children of the given element.\n */\ngoog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;\n\n\n/**\n * Returns the first child node that is an element.\n * @param {Node} node The node to get the first child element of.\n * @return {Element} The first child node of `node` that is an element.\n */\ngoog.dom.DomHelper.prototype.getFirstElementChild =\n    goog.dom.getFirstElementChild;\n\n\n/**\n * Returns the last child node that is an element.\n * @param {Node} node The node to get the last child element of.\n * @return {Element} The last child node of `node` that is an element.\n */\ngoog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;\n\n\n/**\n * Returns the first next sibling that is an element.\n * @param {Node} node The node to get the next sibling element of.\n * @return {Element} The next sibling of `node` that is an element.\n */\ngoog.dom.DomHelper.prototype.getNextElementSibling =\n    goog.dom.getNextElementSibling;\n\n\n/**\n * Returns the first previous sibling that is an element.\n * @param {Node} node The node to get the previous sibling element of.\n * @return {Element} The first previous sibling of `node` that is\n *     an element.\n */\ngoog.dom.DomHelper.prototype.getPreviousElementSibling =\n    goog.dom.getPreviousElementSibling;\n\n\n/**\n * Returns the next node in source order from the given node.\n * @param {Node} node The node.\n * @return {Node} The next node in the DOM tree, or null if this was the last\n *     node.\n */\ngoog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;\n\n\n/**\n * Returns the previous node in source order from the given node.\n * @param {Node} node The node.\n * @return {Node} The previous node in the DOM tree, or null if this was the\n *     first node.\n */\ngoog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;\n\n\n/**\n * Whether the object looks like a DOM node.\n * @param {?} obj The object being tested for node likeness.\n * @return {boolean} Whether the object looks like a DOM node.\n */\ngoog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;\n\n\n/**\n * Whether the object looks like an Element.\n * @param {?} obj The object being tested for Element likeness.\n * @return {boolean} Whether the object looks like an Element.\n */\ngoog.dom.DomHelper.prototype.isElement = goog.dom.isElement;\n\n\n/**\n * Returns true if the specified value is a Window object. This includes the\n * global window for HTML pages, and iframe windows.\n * @param {?} obj Variable to test.\n * @return {boolean} Whether the variable is a window.\n */\ngoog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;\n\n\n/**\n * Returns an element's parent, if it's an Element.\n * @param {Element} element The DOM element.\n * @return {Element} The parent, or null if not an Element.\n */\ngoog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;\n\n\n/**\n * Whether a node contains another node.\n * @param {Node} parent The node that should contain the other node.\n * @param {Node} descendant The node to test presence of.\n * @return {boolean} Whether the parent node contains the descendant node.\n */\ngoog.dom.DomHelper.prototype.contains = goog.dom.contains;\n\n\n/**\n * Compares the document order of two nodes, returning 0 if they are the same\n * node, a negative number if node1 is before node2, and a positive number if\n * node2 is before node1.  Note that we compare the order the tags appear in the\n * document so in the tree <b><i>text</i></b> the B node is considered to be\n * before the I node.\n *\n * @param {Node} node1 The first node to compare.\n * @param {Node} node2 The second node to compare.\n * @return {number} 0 if the nodes are the same node, a negative number if node1\n *     is before node2, and a positive number if node2 is before node1.\n */\ngoog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;\n\n\n/**\n * Find the deepest common ancestor of the given nodes.\n * @param {...Node} var_args The nodes to find a common ancestor of.\n * @return {Node} The common ancestor of the nodes, or null if there is none.\n *     null will only be returned if two or more of the nodes are from different\n *     documents.\n */\ngoog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;\n\n\n/**\n * Returns the owner document for a node.\n * @param {Node} node The node to get the document for.\n * @return {!Document} The document owning the node.\n */\ngoog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;\n\n\n/**\n * Cross browser function for getting the document element of an iframe.\n * @param {Element} iframe Iframe element.\n * @return {!Document} The frame content document.\n */\ngoog.dom.DomHelper.prototype.getFrameContentDocument =\n    goog.dom.getFrameContentDocument;\n\n\n/**\n * Cross browser function for getting the window of a frame or iframe.\n * @param {Element} frame Frame element.\n * @return {Window} The window associated with the given frame.\n */\ngoog.dom.DomHelper.prototype.getFrameContentWindow =\n    goog.dom.getFrameContentWindow;\n\n\n/**\n * Sets the text content of a node, with cross-browser support.\n * @param {Node} node The node to change the text content of.\n * @param {string|number} text The value that should replace the node's content.\n */\ngoog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;\n\n\n/**\n * Gets the outerHTML of a node, which islike innerHTML, except that it\n * actually contains the HTML of the node itself.\n * @param {Element} element The element to get the HTML of.\n * @return {string} The outerHTML of the given element.\n */\ngoog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;\n\n\n/**\n * Finds the first descendant node that matches the filter function. This does\n * a depth first search.\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @return {Node|undefined} The found node or undefined if none is found.\n */\ngoog.dom.DomHelper.prototype.findNode = goog.dom.findNode;\n\n\n/**\n * Finds all the descendant nodes that matches the filter function. This does a\n * depth first search.\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @return {Array<Node>} The found nodes or an empty array if none are found.\n */\ngoog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;\n\n\n/**\n * Returns true if the element has a tab index that allows it to receive\n * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements\n * natively support keyboard focus, even if they have no tab index.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element has a tab index that allows keyboard\n *     focus.\n */\ngoog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;\n\n\n/**\n * Enables or disables keyboard focus support on the element via its tab index.\n * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true\n * (or elements that natively support keyboard focus, like form elements) can\n * receive keyboard focus.  See http://go/tabindex for more info.\n * @param {Element} element Element whose tab index is to be changed.\n * @param {boolean} enable Whether to set or remove a tab index on the element\n *     that supports keyboard focus.\n */\ngoog.dom.DomHelper.prototype.setFocusableTabIndex =\n    goog.dom.setFocusableTabIndex;\n\n\n/**\n * Returns true if the element can be focused, i.e. it has a tab index that\n * allows it to receive keyboard focus (tabIndex >= 0), or it is an element\n * that natively supports keyboard focus.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element allows keyboard focus.\n */\ngoog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;\n\n\n/**\n * Returns the text contents of the current node, without markup. New lines are\n * stripped and whitespace is collapsed, such that each character would be\n * visible.\n *\n * In browsers that support it, innerText is used.  Other browsers attempt to\n * simulate it via node traversal.  Line breaks are canonicalized in IE.\n *\n * @param {Node} node The node from which we are getting content.\n * @return {string} The text content.\n */\ngoog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;\n\n\n/**\n * Returns the text length of the text contained in a node, without markup. This\n * is equivalent to the selection length if the node was selected, or the number\n * of cursor movements to traverse the node. Images & BRs take one space.  New\n * lines are ignored.\n *\n * @param {Node} node The node whose text content length is being calculated.\n * @return {number} The length of `node`'s text content.\n */\ngoog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;\n\n\n/**\n * Returns the text offset of a node relative to one of its ancestors. The text\n * length is the same as the length calculated by\n * `goog.dom.getNodeTextLength`.\n *\n * @param {Node} node The node whose offset is being calculated.\n * @param {Node=} opt_offsetParent Defaults to the node's owner document's body.\n * @return {number} The text offset.\n */\ngoog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;\n\n\n/**\n * Returns the node at a given offset in a parent node.  If an object is\n * provided for the optional third parameter, the node and the remainder of the\n * offset will stored as properties of this object.\n * @param {Node} parent The parent node.\n * @param {number} offset The offset into the parent node.\n * @param {Object=} opt_result Object to be used to store the return value. The\n *     return value will be stored in the form {node: Node, remainder: number}\n *     if this object is provided.\n * @return {Node} The node at the given offset.\n */\ngoog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;\n\n\n/**\n * Returns true if the object is a `NodeList`.  To qualify as a NodeList,\n * the object must have a numeric length property and an item function (which\n * has type 'string' on IE for some reason).\n * @param {Object} val Object to test.\n * @return {boolean} Whether the object is a NodeList.\n */\ngoog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\n * tag name and/or class name. If the passed element matches the specified\n * criteria, the element itself is returned.\n * @param {Node} element The DOM node to start with.\n * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or\n *     null/undefined to match only based on class name).\n * @param {?string=} opt_class The class name to match (or null/undefined to\n *     match only based on tag name).\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {?R} The first ancestor that matches the passed criteria, or\n *     null if no match is found. The return type is {?Element} if opt_tag is\n *     not a member of goog.dom.TagName or a more specific type if it is (e.g.\n *     {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.getAncestorByTagNameAndClass =\n    goog.dom.getAncestorByTagNameAndClass;\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\n * class name. If the passed element matches the specified criteria, the\n * element itself is returned.\n * @param {Node} element The DOM node to start with.\n * @param {string} class The class name to match.\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {Element} The first ancestor that matches the passed criteria, or\n *     null if none match.\n */\ngoog.dom.DomHelper.prototype.getAncestorByClass = goog.dom.getAncestorByClass;\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that passes the\n * matcher function.\n * @param {Node} element The DOM node to start with.\n * @param {function(Node) : boolean} matcher A function that returns true if the\n *     passed node matches the desired criteria.\n * @param {boolean=} opt_includeNode If true, the node itself is included in\n *     the search (the first call to the matcher will pass startElement as\n *     the node to test).\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {Node} DOM node that matched the matcher, or null if there was\n *     no match.\n */\ngoog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;\n\n\n/**\n * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a\n * type information.\n * @param {!HTMLCanvasElement} canvas\n * @return {!CanvasRenderingContext2D}\n */\ngoog.dom.DomHelper.prototype.getCanvasContext2D = goog.dom.getCanvasContext2D;\n","~:compiled-at",1623605884932,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.dom.dom.js\",\n\"lineCount\":1086,\n\"mappings\":\"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\",\n\"sources\":[\"goog/dom/dom.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n/**\\n * @fileoverview Utilities for manipulating the browser's Document Object Model\\n * Inspiration taken *heavily* from mochikit (http://mochikit.com/).\\n *\\n * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer\\n * to a different document object.  This is useful if you are working with\\n * frames or multiple windows.\\n *\\n * @suppress {strictMissingProperties}\\n */\\n\\n\\n// TODO(arv): Rename/refactor getTextContent and getRawTextContent. The problem\\n// is that getTextContent should mimic the DOM3 textContent. We should add a\\n// getInnerText (or getText) which tries to return the visible text, innerText.\\n\\n\\ngoog.provide('goog.dom');\\ngoog.provide('goog.dom.Appendable');\\ngoog.provide('goog.dom.DomHelper');\\n\\ngoog.require('goog.array');\\ngoog.require('goog.asserts');\\ngoog.require('goog.dom.BrowserFeature');\\ngoog.require('goog.dom.NodeType');\\ngoog.require('goog.dom.TagName');\\ngoog.require('goog.dom.safe');\\ngoog.require('goog.html.SafeHtml');\\ngoog.require('goog.html.uncheckedconversions');\\ngoog.require('goog.math.Coordinate');\\ngoog.require('goog.math.Size');\\ngoog.require('goog.object');\\ngoog.require('goog.string');\\ngoog.require('goog.string.Const');\\ngoog.require('goog.string.Unicode');\\ngoog.require('goog.userAgent');\\n\\n\\n/**\\n * @define {boolean} Whether we know at compile time that the browser is in\\n * quirks mode.\\n */\\ngoog.dom.ASSUME_QUIRKS_MODE = goog.define('goog.dom.ASSUME_QUIRKS_MODE', false);\\n\\n\\n/**\\n * @define {boolean} Whether we know at compile time that the browser is in\\n * standards compliance mode.\\n */\\ngoog.dom.ASSUME_STANDARDS_MODE =\\n    goog.define('goog.dom.ASSUME_STANDARDS_MODE', false);\\n\\n\\n/**\\n * Whether we know the compatibility mode at compile time.\\n * @type {boolean}\\n * @private\\n */\\ngoog.dom.COMPAT_MODE_KNOWN_ =\\n    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;\\n\\n\\n/**\\n * Gets the DomHelper object for the document where the element resides.\\n * @param {(Node|Window)=} opt_element If present, gets the DomHelper for this\\n *     element.\\n * @return {!goog.dom.DomHelper} The DomHelper.\\n */\\ngoog.dom.getDomHelper = function(opt_element) {\\n  'use strict';\\n  return opt_element ?\\n      new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :\\n      (goog.dom.defaultDomHelper_ ||\\n       (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));\\n};\\n\\n\\n/**\\n * Cached default DOM helper.\\n * @type {!goog.dom.DomHelper|undefined}\\n * @private\\n */\\ngoog.dom.defaultDomHelper_;\\n\\n\\n/**\\n * Gets the document object being used by the dom library.\\n * @return {!Document} Document object.\\n */\\ngoog.dom.getDocument = function() {\\n  'use strict';\\n  return document;\\n};\\n\\n\\n/**\\n * Gets an element from the current document by element id.\\n *\\n * If an Element is passed in, it is returned.\\n *\\n * @param {string|Element} element Element ID or a DOM node.\\n * @return {Element} The element with the given ID, or the node passed in.\\n */\\ngoog.dom.getElement = function(element) {\\n  'use strict';\\n  return goog.dom.getElementHelper_(document, element);\\n};\\n\\n\\n/**\\n * Gets an element by id from the given document (if present).\\n * If an element is given, it is returned.\\n * @param {!Document} doc\\n * @param {string|Element} element Element ID or a DOM node.\\n * @return {Element} The resulting element.\\n * @private\\n */\\ngoog.dom.getElementHelper_ = function(doc, element) {\\n  'use strict';\\n  return typeof element === 'string' ? doc.getElementById(element) : element;\\n};\\n\\n\\n/**\\n * Gets an element by id, asserting that the element is found.\\n *\\n * This is used when an element is expected to exist, and should fail with\\n * an assertion error if it does not (if assertions are enabled).\\n *\\n * @param {string} id Element ID.\\n * @return {!Element} The element with the given ID, if it exists.\\n */\\ngoog.dom.getRequiredElement = function(id) {\\n  'use strict';\\n  return goog.dom.getRequiredElementHelper_(document, id);\\n};\\n\\n\\n/**\\n * Helper function for getRequiredElementHelper functions, both static and\\n * on DomHelper.  Asserts the element with the given id exists.\\n * @param {!Document} doc\\n * @param {string} id\\n * @return {!Element} The element with the given ID, if it exists.\\n * @private\\n */\\ngoog.dom.getRequiredElementHelper_ = function(doc, id) {\\n  'use strict';\\n  // To prevent users passing in Elements as is permitted in getElement().\\n  goog.asserts.assertString(id);\\n  var element = goog.dom.getElementHelper_(doc, id);\\n  element =\\n      goog.asserts.assertElement(element, 'No element found with id: ' + id);\\n  return element;\\n};\\n\\n\\n/**\\n * Alias for getElement.\\n * @param {string|Element} element Element ID or a DOM node.\\n * @return {Element} The element with the given ID, or the node passed in.\\n * @deprecated Use {@link goog.dom.getElement} instead.\\n */\\ngoog.dom.$ = goog.dom.getElement;\\n\\n\\n/**\\n * Gets elements by tag name.\\n * @param {!goog.dom.TagName<T>} tagName\\n * @param {(!Document|!Element)=} opt_parent Parent element or document where to\\n *     look for elements. Defaults to document.\\n * @return {!NodeList<R>} List of elements. The members of the list are\\n *     {!Element} if tagName is not a member of goog.dom.TagName or more\\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\\n *     goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.getElementsByTagName = function(tagName, opt_parent) {\\n  'use strict';\\n  var parent = opt_parent || document;\\n  return parent.getElementsByTagName(String(tagName));\\n};\\n\\n\\n/**\\n * Looks up elements by both tag and class name, using browser native functions\\n * (`querySelectorAll`, `getElementsByTagName` or\\n * `getElementsByClassName`) where possible. This function\\n * is a useful, if limited, way of collecting a list of DOM elements\\n * with certain characteristics.  `querySelectorAll` offers a\\n * more powerful and general solution which allows matching on CSS3\\n * selector expressions.\\n *\\n * Note that tag names are case sensitive in the SVG namespace, and this\\n * function converts opt_tag to uppercase for comparisons. For queries in the\\n * SVG namespace you should use querySelector or querySelectorAll instead.\\n * https://bugzilla.mozilla.org/show_bug.cgi?id=963870\\n * https://bugs.webkit.org/show_bug.cgi?id=83438\\n *\\n * @see {https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll}\\n *\\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\\n * @param {?string=} opt_class Optional class name.\\n * @param {(Document|Element)=} opt_el Optional element to look in.\\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\\n *     and numerical indices are guaranteed to exist). The members of the array\\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\\n *     goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\\n  'use strict';\\n  return goog.dom.getElementsByTagNameAndClass_(\\n      document, opt_tag, opt_class, opt_el);\\n};\\n\\n\\n/**\\n * Gets the first element matching the tag and the class.\\n *\\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\\n * @param {?string=} opt_class Optional class name.\\n * @param {(Document|Element)=} opt_el Optional element to look in.\\n * @return {?R} Reference to a DOM node. The return type is {?Element} if\\n *     tagName is a string or a more specific type if it is a member of\\n *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.getElementByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\\n  'use strict';\\n  return goog.dom.getElementByTagNameAndClass_(\\n      document, opt_tag, opt_class, opt_el);\\n};\\n\\n\\n/**\\n * Returns a static, array-like list of the elements with the provided\\n * className.\\n *\\n * @param {string} className the name of the class to look for.\\n * @param {(Document|Element)=} opt_el Optional element to look in.\\n * @return {!IArrayLike<!Element>} The items found with the class name provided.\\n */\\ngoog.dom.getElementsByClass = function(className, opt_el) {\\n  'use strict';\\n  var parent = opt_el || document;\\n  if (goog.dom.canUseQuerySelector_(parent)) {\\n    return parent.querySelectorAll('.' + className);\\n  }\\n  return goog.dom.getElementsByTagNameAndClass_(\\n      document, '*', className, opt_el);\\n};\\n\\n\\n/**\\n * Returns the first element with the provided className.\\n *\\n * @param {string} className the name of the class to look for.\\n * @param {Element|Document=} opt_el Optional element to look in.\\n * @return {Element} The first item with the class name provided.\\n */\\ngoog.dom.getElementByClass = function(className, opt_el) {\\n  'use strict';\\n  var parent = opt_el || document;\\n  var retVal = null;\\n  if (parent.getElementsByClassName) {\\n    retVal = parent.getElementsByClassName(className)[0];\\n  } else {\\n    retVal =\\n        goog.dom.getElementByTagNameAndClass_(document, '*', className, opt_el);\\n  }\\n  return retVal || null;\\n};\\n\\n\\n/**\\n * Ensures an element with the given className exists, and then returns the\\n * first element with the provided className.\\n *\\n * @param {string} className the name of the class to look for.\\n * @param {!Element|!Document=} opt_root Optional element or document to look\\n *     in.\\n * @return {!Element} The first item with the class name provided.\\n * @throws {goog.asserts.AssertionError} Thrown if no element is found.\\n */\\ngoog.dom.getRequiredElementByClass = function(className, opt_root) {\\n  'use strict';\\n  var retValue = goog.dom.getElementByClass(className, opt_root);\\n  return goog.asserts.assert(\\n      retValue, 'No element found with className: ' + className);\\n};\\n\\n\\n/**\\n * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and\\n * fast W3C Selectors API.\\n * @param {!(Element|Document)} parent The parent document object.\\n * @return {boolean} whether or not we can use parent.querySelector* APIs.\\n * @private\\n */\\ngoog.dom.canUseQuerySelector_ = function(parent) {\\n  'use strict';\\n  return !!(parent.querySelectorAll && parent.querySelector);\\n};\\n\\n\\n/**\\n * Helper for `getElementsByTagNameAndClass`.\\n * @param {!Document} doc The document to get the elements in.\\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\\n * @param {?string=} opt_class Optional class name.\\n * @param {(Document|Element)=} opt_el Optional element to look in.\\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\\n *     and numerical indices are guaranteed to exist). The members of the array\\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\\n *     goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n * @private\\n */\\ngoog.dom.getElementsByTagNameAndClass_ = function(\\n    doc, opt_tag, opt_class, opt_el) {\\n  'use strict';\\n  var parent = opt_el || doc;\\n  var tagName =\\n      (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';\\n\\n  if (goog.dom.canUseQuerySelector_(parent) && (tagName || opt_class)) {\\n    var query = tagName + (opt_class ? '.' + opt_class : '');\\n    return parent.querySelectorAll(query);\\n  }\\n\\n  // Use the native getElementsByClassName if available, under the assumption\\n  // that even when the tag name is specified, there will be fewer elements to\\n  // filter through when going by class than by tag name\\n  if (opt_class && parent.getElementsByClassName) {\\n    var els = parent.getElementsByClassName(opt_class);\\n\\n    if (tagName) {\\n      var arrayLike = {};\\n      var len = 0;\\n\\n      // Filter for specific tags if requested.\\n      for (var i = 0, el; el = els[i]; i++) {\\n        if (tagName == el.nodeName) {\\n          arrayLike[len++] = el;\\n        }\\n      }\\n      arrayLike.length = len;\\n\\n      return /** @type {!IArrayLike<!Element>} */ (arrayLike);\\n    } else {\\n      return els;\\n    }\\n  }\\n\\n  var els = parent.getElementsByTagName(tagName || '*');\\n\\n  if (opt_class) {\\n    var arrayLike = {};\\n    var len = 0;\\n    for (var i = 0, el; el = els[i]; i++) {\\n      var className = el.className;\\n      // Check if className has a split function since SVG className does not.\\n      if (typeof className.split == 'function' &&\\n          goog.array.contains(className.split(/\\\\s+/), opt_class)) {\\n        arrayLike[len++] = el;\\n      }\\n    }\\n    arrayLike.length = len;\\n    return /** @type {!IArrayLike<!Element>} */ (arrayLike);\\n  } else {\\n    return els;\\n  }\\n};\\n\\n\\n/**\\n * Helper for goog.dom.getElementByTagNameAndClass.\\n *\\n * @param {!Document} doc The document to get the elements in.\\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\\n * @param {?string=} opt_class Optional class name.\\n * @param {(Document|Element)=} opt_el Optional element to look in.\\n * @return {?R} Reference to a DOM node. The return type is {?Element} if\\n *     tagName is a string or a more specific type if it is a member of\\n *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n * @private\\n */\\ngoog.dom.getElementByTagNameAndClass_ = function(\\n    doc, opt_tag, opt_class, opt_el) {\\n  'use strict';\\n  var parent = opt_el || doc;\\n  var tag = (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';\\n  if (goog.dom.canUseQuerySelector_(parent) && (tag || opt_class)) {\\n    return parent.querySelector(tag + (opt_class ? '.' + opt_class : ''));\\n  }\\n  var elements =\\n      goog.dom.getElementsByTagNameAndClass_(doc, opt_tag, opt_class, opt_el);\\n  return elements[0] || null;\\n};\\n\\n\\n\\n/**\\n * Alias for `getElementsByTagNameAndClass`.\\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\\n * @param {?string=} opt_class Optional class name.\\n * @param {Element=} opt_el Optional element to look in.\\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\\n *     and numerical indices are guaranteed to exist). The members of the array\\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\\n *     goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.\\n */\\ngoog.dom.$$ = goog.dom.getElementsByTagNameAndClass;\\n\\n\\n/**\\n * Sets multiple properties, and sometimes attributes, on an element. Note that\\n * properties are simply object properties on the element instance, while\\n * attributes are visible in the DOM. Many properties map to attributes with the\\n * same names, some with different names, and there are also unmappable cases.\\n *\\n * This method sets properties by default (which means that custom attributes\\n * are not supported). These are the exeptions (some of which is legacy):\\n * - \\\"style\\\": Even though this is an attribute name, it is translated to a\\n *   property, \\\"style.cssText\\\". Note that this property sanitizes and formats\\n *   its value, unlike the attribute.\\n * - \\\"class\\\": This is an attribute name, it is translated to the \\\"className\\\"\\n *   property.\\n * - \\\"for\\\": This is an attribute name, it is translated to the \\\"htmlFor\\\"\\n *   property.\\n * - Entries in {@see goog.dom.DIRECT_ATTRIBUTE_MAP_} are set as attributes,\\n *   this is probably due to browser quirks.\\n * - \\\"aria-*\\\", \\\"data-*\\\": Always set as attributes, they have no property\\n *   counterparts.\\n *\\n * @param {Element} element DOM node to set properties on.\\n * @param {Object} properties Hash of property:value pairs.\\n *     Property values can be strings or goog.string.TypedString values (such as\\n *     goog.html.SafeUrl).\\n */\\ngoog.dom.setProperties = function(element, properties) {\\n  'use strict';\\n  goog.object.forEach(properties, function(val, key) {\\n    'use strict';\\n    if (val && typeof val == 'object' && val.implementsGoogStringTypedString) {\\n      val = val.getTypedStringValue();\\n    }\\n    if (key == 'style') {\\n      element.style.cssText = val;\\n    } else if (key == 'class') {\\n      element.className = val;\\n    } else if (key == 'for') {\\n      element.htmlFor = val;\\n    } else if (goog.dom.DIRECT_ATTRIBUTE_MAP_.hasOwnProperty(key)) {\\n      element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);\\n    } else if (\\n        goog.string.startsWith(key, 'aria-') ||\\n        goog.string.startsWith(key, 'data-')) {\\n      element.setAttribute(key, val);\\n    } else {\\n      element[key] = val;\\n    }\\n  });\\n};\\n\\n\\n/**\\n * Map of attributes that should be set using\\n * element.setAttribute(key, val) instead of element[key] = val.  Used\\n * by goog.dom.setProperties.\\n *\\n * @private {!Object<string, string>}\\n * @const\\n */\\ngoog.dom.DIRECT_ATTRIBUTE_MAP_ = {\\n  'cellpadding': 'cellPadding',\\n  'cellspacing': 'cellSpacing',\\n  'colspan': 'colSpan',\\n  'frameborder': 'frameBorder',\\n  'height': 'height',\\n  'maxlength': 'maxLength',\\n  'nonce': 'nonce',\\n  'role': 'role',\\n  'rowspan': 'rowSpan',\\n  'type': 'type',\\n  'usemap': 'useMap',\\n  'valign': 'vAlign',\\n  'width': 'width'\\n};\\n\\n\\n/**\\n * Gets the dimensions of the viewport.\\n *\\n * Gecko Standards mode:\\n * docEl.clientWidth  Width of viewport excluding scrollbar.\\n * win.innerWidth     Width of viewport including scrollbar.\\n * body.clientWidth   Width of body element.\\n *\\n * docEl.clientHeight Height of viewport excluding scrollbar.\\n * win.innerHeight    Height of viewport including scrollbar.\\n * body.clientHeight  Height of document.\\n *\\n * Gecko Backwards compatible mode:\\n * docEl.clientWidth  Width of viewport excluding scrollbar.\\n * win.innerWidth     Width of viewport including scrollbar.\\n * body.clientWidth   Width of viewport excluding scrollbar.\\n *\\n * docEl.clientHeight Height of document.\\n * win.innerHeight    Height of viewport including scrollbar.\\n * body.clientHeight  Height of viewport excluding scrollbar.\\n *\\n * IE6/7 Standards mode:\\n * docEl.clientWidth  Width of viewport excluding scrollbar.\\n * win.innerWidth     Undefined.\\n * body.clientWidth   Width of body element.\\n *\\n * docEl.clientHeight Height of viewport excluding scrollbar.\\n * win.innerHeight    Undefined.\\n * body.clientHeight  Height of document element.\\n *\\n * IE5 + IE6/7 Backwards compatible mode:\\n * docEl.clientWidth  0.\\n * win.innerWidth     Undefined.\\n * body.clientWidth   Width of viewport excluding scrollbar.\\n *\\n * docEl.clientHeight 0.\\n * win.innerHeight    Undefined.\\n * body.clientHeight  Height of viewport excluding scrollbar.\\n *\\n * Opera 9 Standards and backwards compatible mode:\\n * docEl.clientWidth  Width of viewport excluding scrollbar.\\n * win.innerWidth     Width of viewport including scrollbar.\\n * body.clientWidth   Width of viewport excluding scrollbar.\\n *\\n * docEl.clientHeight Height of document.\\n * win.innerHeight    Height of viewport including scrollbar.\\n * body.clientHeight  Height of viewport excluding scrollbar.\\n *\\n * WebKit:\\n * Safari 2\\n * docEl.clientHeight Same as scrollHeight.\\n * docEl.clientWidth  Same as innerWidth.\\n * win.innerWidth     Width of viewport excluding scrollbar.\\n * win.innerHeight    Height of the viewport including scrollbar.\\n * frame.innerHeight  Height of the viewport exluding scrollbar.\\n *\\n * Safari 3 (tested in 522)\\n *\\n * docEl.clientWidth  Width of viewport excluding scrollbar.\\n * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.\\n * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.\\n *\\n * @param {Window=} opt_window Optional window element to test.\\n * @return {!goog.math.Size} Object with values 'width' and 'height'.\\n */\\ngoog.dom.getViewportSize = function(opt_window) {\\n  'use strict';\\n  // TODO(arv): This should not take an argument\\n  return goog.dom.getViewportSize_(opt_window || window);\\n};\\n\\n\\n/**\\n * Helper for `getViewportSize`.\\n * @param {Window} win The window to get the view port size for.\\n * @return {!goog.math.Size} Object with values 'width' and 'height'.\\n * @private\\n */\\ngoog.dom.getViewportSize_ = function(win) {\\n  'use strict';\\n  var doc = win.document;\\n  var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;\\n  return new goog.math.Size(el.clientWidth, el.clientHeight);\\n};\\n\\n\\n/**\\n * Calculates the height of the document.\\n *\\n * @return {number} The height of the current document.\\n */\\ngoog.dom.getDocumentHeight = function() {\\n  'use strict';\\n  return goog.dom.getDocumentHeight_(window);\\n};\\n\\n/**\\n * Calculates the height of the document of the given window.\\n *\\n * @param {!Window} win The window whose document height to retrieve.\\n * @return {number} The height of the document of the given window.\\n */\\ngoog.dom.getDocumentHeightForWindow = function(win) {\\n  'use strict';\\n  return goog.dom.getDocumentHeight_(win);\\n};\\n\\n/**\\n * Calculates the height of the document of the given window.\\n *\\n * Function code copied from the opensocial gadget api:\\n *   gadgets.window.adjustHeight(opt_height)\\n *\\n * @private\\n * @param {!Window} win The window whose document height to retrieve.\\n * @return {number} The height of the document of the given window.\\n */\\ngoog.dom.getDocumentHeight_ = function(win) {\\n  'use strict';\\n  // NOTE(eae): This method will return the window size rather than the document\\n  // size in webkit quirks mode.\\n  var doc = win.document;\\n  var height = 0;\\n\\n  if (doc) {\\n    // Calculating inner content height is hard and different between\\n    // browsers rendering in Strict vs. Quirks mode.  We use a combination of\\n    // three properties within document.body and document.documentElement:\\n    // - scrollHeight\\n    // - offsetHeight\\n    // - clientHeight\\n    // These values differ significantly between browsers and rendering modes.\\n    // But there are patterns.  It just takes a lot of time and persistence\\n    // to figure out.\\n\\n    var body = doc.body;\\n    var docEl = /** @type {!HTMLElement} */ (doc.documentElement);\\n    if (!(docEl && body)) {\\n      return 0;\\n    }\\n\\n    // Get the height of the viewport\\n    var vh = goog.dom.getViewportSize_(win).height;\\n    if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {\\n      // In Strict mode:\\n      // The inner content height is contained in either:\\n      //    document.documentElement.scrollHeight\\n      //    document.documentElement.offsetHeight\\n      // Based on studying the values output by different browsers,\\n      // use the value that's NOT equal to the viewport height found above.\\n      height =\\n          docEl.scrollHeight != vh ? docEl.scrollHeight : docEl.offsetHeight;\\n    } else {\\n      // In Quirks mode:\\n      // documentElement.clientHeight is equal to documentElement.offsetHeight\\n      // except in IE.  In most browsers, document.documentElement can be used\\n      // to calculate the inner content height.\\n      // However, in other browsers (e.g. IE), document.body must be used\\n      // instead.  How do we know which one to use?\\n      // If document.documentElement.clientHeight does NOT equal\\n      // document.documentElement.offsetHeight, then use document.body.\\n      var sh = docEl.scrollHeight;\\n      var oh = docEl.offsetHeight;\\n      if (docEl.clientHeight != oh) {\\n        sh = body.scrollHeight;\\n        oh = body.offsetHeight;\\n      }\\n\\n      // Detect whether the inner content height is bigger or smaller\\n      // than the bounding box (viewport).  If bigger, take the larger\\n      // value.  If smaller, take the smaller value.\\n      if (sh > vh) {\\n        // Content is larger\\n        height = sh > oh ? sh : oh;\\n      } else {\\n        // Content is smaller\\n        height = sh < oh ? sh : oh;\\n      }\\n    }\\n  }\\n\\n  return height;\\n};\\n\\n\\n/**\\n * Gets the page scroll distance as a coordinate object.\\n *\\n * @param {Window=} opt_window Optional window element to test.\\n * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.\\n * @deprecated Use {@link goog.dom.getDocumentScroll} instead.\\n */\\ngoog.dom.getPageScroll = function(opt_window) {\\n  'use strict';\\n  var win = opt_window || goog.global || window;\\n  return goog.dom.getDomHelper(win.document).getDocumentScroll();\\n};\\n\\n\\n/**\\n * Gets the document scroll distance as a coordinate object.\\n *\\n * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.\\n */\\ngoog.dom.getDocumentScroll = function() {\\n  'use strict';\\n  return goog.dom.getDocumentScroll_(document);\\n};\\n\\n\\n/**\\n * Helper for `getDocumentScroll`.\\n *\\n * @param {!Document} doc The document to get the scroll for.\\n * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.\\n * @private\\n */\\ngoog.dom.getDocumentScroll_ = function(doc) {\\n  'use strict';\\n  var el = goog.dom.getDocumentScrollElement_(doc);\\n  var win = goog.dom.getWindow_(doc);\\n  if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher('10') &&\\n      win.pageYOffset != el.scrollTop) {\\n    // The keyboard on IE10 touch devices shifts the page using the pageYOffset\\n    // without modifying scrollTop. For this case, we want the body scroll\\n    // offsets.\\n    return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);\\n  }\\n  return new goog.math.Coordinate(\\n      win.pageXOffset || el.scrollLeft, win.pageYOffset || el.scrollTop);\\n};\\n\\n\\n/**\\n * Gets the document scroll element.\\n * @return {!Element} Scrolling element.\\n */\\ngoog.dom.getDocumentScrollElement = function() {\\n  'use strict';\\n  return goog.dom.getDocumentScrollElement_(document);\\n};\\n\\n\\n/**\\n * Helper for `getDocumentScrollElement`.\\n * @param {!Document} doc The document to get the scroll element for.\\n * @return {!Element} Scrolling element.\\n * @private\\n */\\ngoog.dom.getDocumentScrollElement_ = function(doc) {\\n  'use strict';\\n  // Old WebKit needs body.scrollLeft in both quirks mode and strict mode. We\\n  // also default to the documentElement if the document does not have a body\\n  // (e.g. a SVG document).\\n  // Uses http://dev.w3.org/csswg/cssom-view/#dom-document-scrollingelement to\\n  // avoid trying to guess about browser behavior from the UA string.\\n  if (doc.scrollingElement) {\\n    return doc.scrollingElement;\\n  }\\n  if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) {\\n    return doc.documentElement;\\n  }\\n  return doc.body || doc.documentElement;\\n};\\n\\n\\n/**\\n * Gets the window object associated with the given document.\\n *\\n * @param {Document=} opt_doc  Document object to get window for.\\n * @return {!Window} The window associated with the given document.\\n */\\ngoog.dom.getWindow = function(opt_doc) {\\n  'use strict';\\n  // TODO(arv): This should not take an argument.\\n  return opt_doc ? goog.dom.getWindow_(opt_doc) : window;\\n};\\n\\n\\n/**\\n * Helper for `getWindow`.\\n *\\n * @param {!Document} doc  Document object to get window for.\\n * @return {!Window} The window associated with the given document.\\n * @private\\n */\\ngoog.dom.getWindow_ = function(doc) {\\n  'use strict';\\n  return /** @type {!Window} */ (doc.parentWindow || doc.defaultView);\\n};\\n\\n\\n/**\\n * Returns a dom node with a set of attributes.  This function accepts varargs\\n * for subsequent nodes to be added.  Subsequent nodes will be added to the\\n * first node as childNodes.\\n *\\n * So:\\n * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),\\n * createDom(goog.dom.TagName.P));</code> would return a div with two child\\n * paragraphs\\n *\\n * This function uses {@link goog.dom.setProperties} to set attributes: the\\n * `opt_attributes` parameter follows the same rules.\\n *\\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\\n *     of name-value pairs for attributes. If a string, then this is the\\n *     className of the new element. If an array, the elements will be joined\\n *     together as the className of the new element.\\n * @param {...(Object|string|Array|NodeList|null|undefined)} var_args Further\\n *     DOM nodes or strings for text nodes. If one of the var_args is an array\\n *     or NodeList, its elements will be added as childNodes instead.\\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\\n *     is a string or a more specific type if it is a member of\\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.createDom = function(tagName, opt_attributes, var_args) {\\n  'use strict';\\n  return goog.dom.createDom_(document, arguments);\\n};\\n\\n\\n/**\\n * Helper for `createDom`.\\n * @param {!Document} doc The document to create the DOM in.\\n * @param {!Arguments} args Argument object passed from the callers. See\\n *     `goog.dom.createDom` for details.\\n * @return {!Element} Reference to a DOM node.\\n * @private\\n */\\ngoog.dom.createDom_ = function(doc, args) {\\n  'use strict';\\n  var tagName = String(args[0]);\\n  var attributes = args[1];\\n\\n  // Internet Explorer is dumb:\\n  // name: https://msdn.microsoft.com/en-us/library/ms534184(v=vs.85).aspx\\n  // type: https://msdn.microsoft.com/en-us/library/ms534700(v=vs.85).aspx\\n  // Also does not allow setting of 'type' attribute on 'input' or 'button'.\\n  if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes &&\\n      (attributes.name || attributes.type)) {\\n    var tagNameArr = ['<', tagName];\\n    if (attributes.name) {\\n      tagNameArr.push(' name=\\\"', goog.string.htmlEscape(attributes.name), '\\\"');\\n    }\\n    if (attributes.type) {\\n      tagNameArr.push(' type=\\\"', goog.string.htmlEscape(attributes.type), '\\\"');\\n\\n      // Clone attributes map to remove 'type' without mutating the input.\\n      var clone = {};\\n      goog.object.extend(clone, attributes);\\n\\n      // JSCompiler can't see how goog.object.extend added this property,\\n      // because it was essentially added by reflection.\\n      // So it needs to be quoted.\\n      delete clone['type'];\\n\\n      attributes = clone;\\n    }\\n    tagNameArr.push('>');\\n    tagName = tagNameArr.join('');\\n  }\\n\\n  var element = goog.dom.createElement_(doc, tagName);\\n\\n  if (attributes) {\\n    if (typeof attributes === 'string') {\\n      element.className = attributes;\\n    } else if (Array.isArray(attributes)) {\\n      element.className = attributes.join(' ');\\n    } else {\\n      goog.dom.setProperties(element, attributes);\\n    }\\n  }\\n\\n  if (args.length > 2) {\\n    goog.dom.append_(doc, element, args, 2);\\n  }\\n\\n  return element;\\n};\\n\\n\\n/**\\n * Appends a node with text or other nodes.\\n * @param {!Document} doc The document to create new nodes in.\\n * @param {!Node} parent The node to append nodes to.\\n * @param {!Arguments} args The values to add. See `goog.dom.append`.\\n * @param {number} startIndex The index of the array to start from.\\n * @private\\n */\\ngoog.dom.append_ = function(doc, parent, args, startIndex) {\\n  'use strict';\\n  function childHandler(child) {\\n    // TODO(user): More coercion, ala MochiKit?\\n    if (child) {\\n      parent.appendChild(\\n          typeof child === 'string' ? doc.createTextNode(child) : child);\\n    }\\n  }\\n\\n  for (var i = startIndex; i < args.length; i++) {\\n    var arg = args[i];\\n    // TODO(attila): Fix isArrayLike to return false for a text node.\\n    if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {\\n      // If the argument is a node list, not a real array, use a clone,\\n      // because forEach can't be used to mutate a NodeList.\\n      goog.array.forEach(\\n          goog.dom.isNodeList(arg) ? goog.array.toArray(arg) : arg,\\n          childHandler);\\n    } else {\\n      childHandler(arg);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Alias for `createDom`.\\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\\n *     of name-value pairs for attributes. If a string, then this is the\\n *     className of the new element. If an array, the elements will be joined\\n *     together as the className of the new element.\\n * @param {...(Object|string|Array|NodeList|null|undefined)} var_args Further\\n *     DOM nodes or strings for text nodes. If one of the var_args is an array,\\n *     its children will be added as childNodes instead.\\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\\n *     is a string or a more specific type if it is a member of\\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n * @deprecated Use {@link goog.dom.createDom} instead.\\n */\\ngoog.dom.$dom = goog.dom.createDom;\\n\\n\\n/**\\n * Creates a new element.\\n * @param {string|!goog.dom.TagName<T>} name Tag to create.\\n * @return {R} The new element. The return type is {!Element} if name is\\n *     a string or a more specific type if it is a member of goog.dom.TagName\\n *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.createElement = function(name) {\\n  'use strict';\\n  return goog.dom.createElement_(document, name);\\n};\\n\\n\\n/**\\n * Creates a new element.\\n * @param {!Document} doc The document to create the element in.\\n * @param {string|!goog.dom.TagName<T>} name Tag to create.\\n * @return {R} The new element. The return type is {!Element} if name is\\n *     a string or a more specific type if it is a member of goog.dom.TagName\\n *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n * @private\\n */\\ngoog.dom.createElement_ = function(doc, name) {\\n  'use strict';\\n  name = String(name);\\n  if (doc.contentType === 'application/xhtml+xml') name = name.toLowerCase();\\n  return doc.createElement(name);\\n};\\n\\n\\n/**\\n * Creates a new text node.\\n * @param {number|string} content Content.\\n * @return {!Text} The new text node.\\n */\\ngoog.dom.createTextNode = function(content) {\\n  'use strict';\\n  return document.createTextNode(String(content));\\n};\\n\\n\\n/**\\n * Create a table.\\n * @param {number} rows The number of rows in the table.  Must be >= 1.\\n * @param {number} columns The number of columns in the table.  Must be >= 1.\\n * @param {boolean=} opt_fillWithNbsp If true, fills table entries with\\n *     `goog.string.Unicode.NBSP` characters.\\n * @return {!Element} The created table.\\n */\\ngoog.dom.createTable = function(rows, columns, opt_fillWithNbsp) {\\n  'use strict';\\n  // TODO(mlourenco): Return HTMLTableElement, also in prototype function.\\n  // Callers need to be updated to e.g. not assign numbers to table.cellSpacing.\\n  return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);\\n};\\n\\n\\n/**\\n * Create a table.\\n * @param {!Document} doc Document object to use to create the table.\\n * @param {number} rows The number of rows in the table.  Must be >= 1.\\n * @param {number} columns The number of columns in the table.  Must be >= 1.\\n * @param {boolean} fillWithNbsp If true, fills table entries with\\n *     `goog.string.Unicode.NBSP` characters.\\n * @return {!HTMLTableElement} The created table.\\n * @private\\n */\\ngoog.dom.createTable_ = function(doc, rows, columns, fillWithNbsp) {\\n  'use strict';\\n  var table = goog.dom.createElement_(doc, goog.dom.TagName.TABLE);\\n  var tbody =\\n      table.appendChild(goog.dom.createElement_(doc, goog.dom.TagName.TBODY));\\n  for (var i = 0; i < rows; i++) {\\n    var tr = goog.dom.createElement_(doc, goog.dom.TagName.TR);\\n    for (var j = 0; j < columns; j++) {\\n      var td = goog.dom.createElement_(doc, goog.dom.TagName.TD);\\n      // IE <= 9 will create a text node if we set text content to the empty\\n      // string, so we avoid doing it unless necessary. This ensures that the\\n      // same DOM tree is returned on all browsers.\\n      if (fillWithNbsp) {\\n        goog.dom.setTextContent(td, goog.string.Unicode.NBSP);\\n      }\\n      tr.appendChild(td);\\n    }\\n    tbody.appendChild(tr);\\n  }\\n  return table;\\n};\\n\\n\\n\\n/**\\n * Creates a new Node from constant strings of HTML markup.\\n * @param {...!goog.string.Const} var_args The HTML strings to concatenate then\\n *     convert into a node.\\n * @return {!Node}\\n */\\ngoog.dom.constHtmlToNode = function(var_args) {\\n  'use strict';\\n  var stringArray = goog.array.map(arguments, goog.string.Const.unwrap);\\n  var safeHtml =\\n      goog.html.uncheckedconversions\\n          .safeHtmlFromStringKnownToSatisfyTypeContract(\\n              goog.string.Const.from(\\n                  'Constant HTML string, that gets turned into a ' +\\n                  'Node later, so it will be automatically balanced.'),\\n              stringArray.join(''));\\n  return goog.dom.safeHtmlToNode(safeHtml);\\n};\\n\\n\\n/**\\n * Converts HTML markup into a node. This is a safe version of\\n * `goog.dom.htmlToDocumentFragment` which is now deleted.\\n * @param {!goog.html.SafeHtml} html The HTML markup to convert.\\n * @return {!Node} The resulting node.\\n */\\ngoog.dom.safeHtmlToNode = function(html) {\\n  'use strict';\\n  return goog.dom.safeHtmlToNode_(document, html);\\n};\\n\\n\\n/**\\n * Helper for `safeHtmlToNode`.\\n * @param {!Document} doc The document.\\n * @param {!goog.html.SafeHtml} html The HTML markup to convert.\\n * @return {!Node} The resulting node.\\n * @private\\n */\\ngoog.dom.safeHtmlToNode_ = function(doc, html) {\\n  'use strict';\\n  var tempDiv = goog.dom.createElement_(doc, goog.dom.TagName.DIV);\\n  if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {\\n    goog.dom.safe.setInnerHtml(\\n        tempDiv, goog.html.SafeHtml.concat(goog.html.SafeHtml.BR, html));\\n    tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));\\n  } else {\\n    goog.dom.safe.setInnerHtml(tempDiv, html);\\n  }\\n  return goog.dom.childrenToNode_(doc, tempDiv);\\n};\\n\\n\\n/**\\n * Helper for `safeHtmlToNode_`.\\n * @param {!Document} doc The document.\\n * @param {!Node} tempDiv The input node.\\n * @return {!Node} The resulting node.\\n * @private\\n */\\ngoog.dom.childrenToNode_ = function(doc, tempDiv) {\\n  'use strict';\\n  if (tempDiv.childNodes.length == 1) {\\n    return tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));\\n  } else {\\n    var fragment = doc.createDocumentFragment();\\n    while (tempDiv.firstChild) {\\n      fragment.appendChild(tempDiv.firstChild);\\n    }\\n    return fragment;\\n  }\\n};\\n\\n\\n/**\\n * Returns true if the browser is in \\\"CSS1-compatible\\\" (standards-compliant)\\n * mode, false otherwise.\\n * @return {boolean} True if in CSS1-compatible mode.\\n */\\ngoog.dom.isCss1CompatMode = function() {\\n  'use strict';\\n  return goog.dom.isCss1CompatMode_(document);\\n};\\n\\n\\n/**\\n * Returns true if the browser is in \\\"CSS1-compatible\\\" (standards-compliant)\\n * mode, false otherwise.\\n * @param {!Document} doc The document to check.\\n * @return {boolean} True if in CSS1-compatible mode.\\n * @private\\n */\\ngoog.dom.isCss1CompatMode_ = function(doc) {\\n  'use strict';\\n  if (goog.dom.COMPAT_MODE_KNOWN_) {\\n    return goog.dom.ASSUME_STANDARDS_MODE;\\n  }\\n\\n  return doc.compatMode == 'CSS1Compat';\\n};\\n\\n\\n/**\\n * Determines if the given node can contain children, intended to be used for\\n * HTML generation.\\n *\\n * IE natively supports node.canHaveChildren but has inconsistent behavior.\\n * Prior to IE8 the base tag allows children and in IE9 all nodes return true\\n * for canHaveChildren.\\n *\\n * In practice all non-IE browsers allow you to add children to any node, but\\n * the behavior is inconsistent:\\n *\\n * <pre>\\n *   var a = goog.dom.createElement(goog.dom.TagName.BR);\\n *   a.appendChild(document.createTextNode('foo'));\\n *   a.appendChild(document.createTextNode('bar'));\\n *   console.log(a.childNodes.length);  // 2\\n *   console.log(a.innerHTML);  // Chrome: \\\"\\\", IE9: \\\"foobar\\\", FF3.5: \\\"foobar\\\"\\n * </pre>\\n *\\n * For more information, see:\\n * http://dev.w3.org/html5/markup/syntax.html#syntax-elements\\n *\\n * TODO(user): Rename shouldAllowChildren() ?\\n *\\n * @param {Node} node The node to check.\\n * @return {boolean} Whether the node can contain children.\\n */\\ngoog.dom.canHaveChildren = function(node) {\\n  'use strict';\\n  if (node.nodeType != goog.dom.NodeType.ELEMENT) {\\n    return false;\\n  }\\n  switch (/** @type {!Element} */ (node).tagName) {\\n    case String(goog.dom.TagName.APPLET):\\n    case String(goog.dom.TagName.AREA):\\n    case String(goog.dom.TagName.BASE):\\n    case String(goog.dom.TagName.BR):\\n    case String(goog.dom.TagName.COL):\\n    case String(goog.dom.TagName.COMMAND):\\n    case String(goog.dom.TagName.EMBED):\\n    case String(goog.dom.TagName.FRAME):\\n    case String(goog.dom.TagName.HR):\\n    case String(goog.dom.TagName.IMG):\\n    case String(goog.dom.TagName.INPUT):\\n    case String(goog.dom.TagName.IFRAME):\\n    case String(goog.dom.TagName.ISINDEX):\\n    case String(goog.dom.TagName.KEYGEN):\\n    case String(goog.dom.TagName.LINK):\\n    case String(goog.dom.TagName.NOFRAMES):\\n    case String(goog.dom.TagName.NOSCRIPT):\\n    case String(goog.dom.TagName.META):\\n    case String(goog.dom.TagName.OBJECT):\\n    case String(goog.dom.TagName.PARAM):\\n    case String(goog.dom.TagName.SCRIPT):\\n    case String(goog.dom.TagName.SOURCE):\\n    case String(goog.dom.TagName.STYLE):\\n    case String(goog.dom.TagName.TRACK):\\n    case String(goog.dom.TagName.WBR):\\n      return false;\\n  }\\n  return true;\\n};\\n\\n\\n/**\\n * Appends a child to a node.\\n * @param {Node} parent Parent.\\n * @param {Node} child Child.\\n */\\ngoog.dom.appendChild = function(parent, child) {\\n  'use strict';\\n  goog.asserts.assert(\\n      parent != null && child != null,\\n      'goog.dom.appendChild expects non-null arguments');\\n  parent.appendChild(child);\\n};\\n\\n\\n/**\\n * Appends a node with text or other nodes.\\n * @param {!Node} parent The node to append nodes to.\\n * @param {...goog.dom.Appendable} var_args The things to append to the node.\\n *     If this is a Node it is appended as is.\\n *     If this is a string then a text node is appended.\\n *     If this is an array like object then fields 0 to length - 1 are appended.\\n */\\ngoog.dom.append = function(parent, var_args) {\\n  'use strict';\\n  goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);\\n};\\n\\n\\n/**\\n * Removes all the child nodes on a DOM node.\\n * @param {Node} node Node to remove children from.\\n */\\ngoog.dom.removeChildren = function(node) {\\n  'use strict';\\n  // Note: Iterations over live collections can be slow, this is the fastest\\n  // we could find. The double parenthesis are used to prevent JsCompiler and\\n  // strict warnings.\\n  var child;\\n  while ((child = node.firstChild)) {\\n    node.removeChild(child);\\n  }\\n};\\n\\n\\n/**\\n * Inserts a new node before an existing reference node (i.e. as the previous\\n * sibling). If the reference node has no parent, then does nothing.\\n * @param {Node} newNode Node to insert.\\n * @param {Node} refNode Reference node to insert before.\\n */\\ngoog.dom.insertSiblingBefore = function(newNode, refNode) {\\n  'use strict';\\n  goog.asserts.assert(\\n      newNode != null && refNode != null,\\n      'goog.dom.insertSiblingBefore expects non-null arguments');\\n  if (refNode.parentNode) {\\n    refNode.parentNode.insertBefore(newNode, refNode);\\n  }\\n};\\n\\n\\n/**\\n * Inserts a new node after an existing reference node (i.e. as the next\\n * sibling). If the reference node has no parent, then does nothing.\\n * @param {Node} newNode Node to insert.\\n * @param {Node} refNode Reference node to insert after.\\n */\\ngoog.dom.insertSiblingAfter = function(newNode, refNode) {\\n  'use strict';\\n  goog.asserts.assert(\\n      newNode != null && refNode != null,\\n      'goog.dom.insertSiblingAfter expects non-null arguments');\\n  if (refNode.parentNode) {\\n    refNode.parentNode.insertBefore(newNode, refNode.nextSibling);\\n  }\\n};\\n\\n\\n/**\\n * Insert a child at a given index. If index is larger than the number of child\\n * nodes that the parent currently has, the node is inserted as the last child\\n * node.\\n * @param {Element} parent The element into which to insert the child.\\n * @param {Node} child The element to insert.\\n * @param {number} index The index at which to insert the new child node. Must\\n *     not be negative.\\n */\\ngoog.dom.insertChildAt = function(parent, child, index) {\\n  'use strict';\\n  // Note that if the second argument is null, insertBefore\\n  // will append the child at the end of the list of children.\\n  goog.asserts.assert(\\n      parent != null, 'goog.dom.insertChildAt expects a non-null parent');\\n  parent.insertBefore(\\n      /** @type {!Node} */ (child), parent.childNodes[index] || null);\\n};\\n\\n\\n/**\\n * Removes a node from its parent.\\n * @param {Node} node The node to remove.\\n * @return {Node} The node removed if removed; else, null.\\n */\\ngoog.dom.removeNode = function(node) {\\n  'use strict';\\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\\n};\\n\\n\\n/**\\n * Replaces a node in the DOM tree. Will do nothing if `oldNode` has no\\n * parent.\\n * @param {Node} newNode Node to insert.\\n * @param {Node} oldNode Node to replace.\\n */\\ngoog.dom.replaceNode = function(newNode, oldNode) {\\n  'use strict';\\n  goog.asserts.assert(\\n      newNode != null && oldNode != null,\\n      'goog.dom.replaceNode expects non-null arguments');\\n  var parent = oldNode.parentNode;\\n  if (parent) {\\n    parent.replaceChild(newNode, oldNode);\\n  }\\n};\\n\\n\\n/**\\n * Replaces child nodes of `target` with child nodes of `source`. This is\\n * roughly equivalent to `target.innerHTML = source.innerHTML` which is not\\n * compatible with Trusted Types.\\n * @param {?Node} target Node to clean and replace its children.\\n * @param {?Node} source Node to get the children from. The nodes will be cloned\\n *     so they will stay in source.\\n */\\ngoog.dom.copyContents = function(target, source) {\\n  'use strict';\\n  goog.asserts.assert(\\n      target != null && source != null,\\n      'goog.dom.copyContents expects non-null arguments');\\n  var childNodes = source.cloneNode(/* deep= */ true).childNodes;\\n  goog.dom.removeChildren(target);\\n  while (childNodes.length) {\\n    target.appendChild(childNodes[0]);\\n  }\\n};\\n\\n\\n/**\\n * Flattens an element. That is, removes it and replace it with its children.\\n * Does nothing if the element is not in the document.\\n * @param {Element} element The element to flatten.\\n * @return {Element|undefined} The original element, detached from the document\\n *     tree, sans children; or undefined, if the element was not in the document\\n *     to begin with.\\n */\\ngoog.dom.flattenElement = function(element) {\\n  'use strict';\\n  var child, parent = element.parentNode;\\n  if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {\\n    // Use IE DOM method (supported by Opera too) if available\\n    if (element.removeNode) {\\n      return /** @type {Element} */ (element.removeNode(false));\\n    } else {\\n      // Move all children of the original node up one level.\\n      while ((child = element.firstChild)) {\\n        parent.insertBefore(child, element);\\n      }\\n\\n      // Detach the original element.\\n      return /** @type {Element} */ (goog.dom.removeNode(element));\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Returns an array containing just the element children of the given element.\\n * @param {Element} element The element whose element children we want.\\n * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list\\n *     of just the element children of the given element.\\n */\\ngoog.dom.getChildren = function(element) {\\n  'use strict';\\n  // We check if the children attribute is supported for child elements\\n  // since IE8 misuses the attribute by also including comments.\\n  if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE &&\\n      element.children != undefined) {\\n    return element.children;\\n  }\\n  // Fall back to manually filtering the element's child nodes.\\n  return goog.array.filter(element.childNodes, function(node) {\\n    'use strict';\\n    return node.nodeType == goog.dom.NodeType.ELEMENT;\\n  });\\n};\\n\\n\\n/**\\n * Returns the first child node that is an element.\\n * @param {Node} node The node to get the first child element of.\\n * @return {Element} The first child node of `node` that is an element.\\n */\\ngoog.dom.getFirstElementChild = function(node) {\\n  'use strict';\\n  if (node.firstElementChild !== undefined) {\\n    return /** @type {!Element} */ (node).firstElementChild;\\n  }\\n  return goog.dom.getNextElementNode_(node.firstChild, true);\\n};\\n\\n\\n/**\\n * Returns the last child node that is an element.\\n * @param {Node} node The node to get the last child element of.\\n * @return {Element} The last child node of `node` that is an element.\\n */\\ngoog.dom.getLastElementChild = function(node) {\\n  'use strict';\\n  if (node.lastElementChild !== undefined) {\\n    return /** @type {!Element} */ (node).lastElementChild;\\n  }\\n  return goog.dom.getNextElementNode_(node.lastChild, false);\\n};\\n\\n\\n/**\\n * Returns the first next sibling that is an element.\\n * @param {Node} node The node to get the next sibling element of.\\n * @return {Element} The next sibling of `node` that is an element.\\n */\\ngoog.dom.getNextElementSibling = function(node) {\\n  'use strict';\\n  if (node.nextElementSibling !== undefined) {\\n    return /** @type {!Element} */ (node).nextElementSibling;\\n  }\\n  return goog.dom.getNextElementNode_(node.nextSibling, true);\\n};\\n\\n\\n/**\\n * Returns the first previous sibling that is an element.\\n * @param {Node} node The node to get the previous sibling element of.\\n * @return {Element} The first previous sibling of `node` that is\\n *     an element.\\n */\\ngoog.dom.getPreviousElementSibling = function(node) {\\n  'use strict';\\n  if (node.previousElementSibling !== undefined) {\\n    return /** @type {!Element} */ (node).previousElementSibling;\\n  }\\n  return goog.dom.getNextElementNode_(node.previousSibling, false);\\n};\\n\\n\\n/**\\n * Returns the first node that is an element in the specified direction,\\n * starting with `node`.\\n * @param {Node} node The node to get the next element from.\\n * @param {boolean} forward Whether to look forwards or backwards.\\n * @return {Element} The first element.\\n * @private\\n */\\ngoog.dom.getNextElementNode_ = function(node, forward) {\\n  'use strict';\\n  while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {\\n    node = forward ? node.nextSibling : node.previousSibling;\\n  }\\n\\n  return /** @type {Element} */ (node);\\n};\\n\\n\\n/**\\n * Returns the next node in source order from the given node.\\n * @param {Node} node The node.\\n * @return {Node} The next node in the DOM tree, or null if this was the last\\n *     node.\\n */\\ngoog.dom.getNextNode = function(node) {\\n  'use strict';\\n  if (!node) {\\n    return null;\\n  }\\n\\n  if (node.firstChild) {\\n    return node.firstChild;\\n  }\\n\\n  while (node && !node.nextSibling) {\\n    node = node.parentNode;\\n  }\\n\\n  return node ? node.nextSibling : null;\\n};\\n\\n\\n/**\\n * Returns the previous node in source order from the given node.\\n * @param {Node} node The node.\\n * @return {Node} The previous node in the DOM tree, or null if this was the\\n *     first node.\\n */\\ngoog.dom.getPreviousNode = function(node) {\\n  'use strict';\\n  if (!node) {\\n    return null;\\n  }\\n\\n  if (!node.previousSibling) {\\n    return node.parentNode;\\n  }\\n\\n  node = node.previousSibling;\\n  while (node && node.lastChild) {\\n    node = node.lastChild;\\n  }\\n\\n  return node;\\n};\\n\\n\\n/**\\n * Whether the object looks like a DOM node.\\n * @param {?} obj The object being tested for node likeness.\\n * @return {boolean} Whether the object looks like a DOM node.\\n */\\ngoog.dom.isNodeLike = function(obj) {\\n  'use strict';\\n  return goog.isObject(obj) && obj.nodeType > 0;\\n};\\n\\n\\n/**\\n * Whether the object looks like an Element.\\n * @param {?} obj The object being tested for Element likeness.\\n * @return {boolean} Whether the object looks like an Element.\\n */\\ngoog.dom.isElement = function(obj) {\\n  'use strict';\\n  return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;\\n};\\n\\n\\n/**\\n * Returns true if the specified value is a Window object. This includes the\\n * global window for HTML pages, and iframe windows.\\n * @param {?} obj Variable to test.\\n * @return {boolean} Whether the variable is a window.\\n */\\ngoog.dom.isWindow = function(obj) {\\n  'use strict';\\n  return goog.isObject(obj) && obj['window'] == obj;\\n};\\n\\n\\n/**\\n * Returns an element's parent, if it's an Element.\\n * @param {Element} element The DOM element.\\n * @return {Element} The parent, or null if not an Element.\\n */\\ngoog.dom.getParentElement = function(element) {\\n  'use strict';\\n  var parent;\\n  if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {\\n    var isIe9 = goog.userAgent.IE && goog.userAgent.isVersionOrHigher('9') &&\\n        !goog.userAgent.isVersionOrHigher('10');\\n    // SVG elements in IE9 can't use the parentElement property.\\n    // goog.global['SVGElement'] is not defined in IE9 quirks mode.\\n    if (!(isIe9 && goog.global['SVGElement'] &&\\n          element instanceof goog.global['SVGElement'])) {\\n      parent = element.parentElement;\\n      if (parent) {\\n        return parent;\\n      }\\n    }\\n  }\\n  parent = element.parentNode;\\n  return goog.dom.isElement(parent) ? /** @type {!Element} */ (parent) : null;\\n};\\n\\n\\n/**\\n * Whether a node contains another node.\\n * @param {?Node|undefined} parent The node that should contain the other node.\\n * @param {?Node|undefined} descendant The node to test presence of.\\n * @return {boolean} Whether the parent node contains the descendant node.\\n */\\ngoog.dom.contains = function(parent, descendant) {\\n  'use strict';\\n  if (!parent || !descendant) {\\n    return false;\\n  }\\n  // We use browser specific methods for this if available since it is faster\\n  // that way.\\n\\n  // IE DOM\\n  if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {\\n    return parent == descendant || parent.contains(descendant);\\n  }\\n\\n  // W3C DOM Level 3\\n  if (typeof parent.compareDocumentPosition != 'undefined') {\\n    return parent == descendant ||\\n        Boolean(parent.compareDocumentPosition(descendant) & 16);\\n  }\\n\\n  // W3C DOM Level 1\\n  while (descendant && parent != descendant) {\\n    descendant = descendant.parentNode;\\n  }\\n  return descendant == parent;\\n};\\n\\n\\n/**\\n * Compares the document order of two nodes, returning 0 if they are the same\\n * node, a negative number if node1 is before node2, and a positive number if\\n * node2 is before node1.  Note that we compare the order the tags appear in the\\n * document so in the tree <b><i>text</i></b> the B node is considered to be\\n * before the I node.\\n *\\n * @param {Node} node1 The first node to compare.\\n * @param {Node} node2 The second node to compare.\\n * @return {number} 0 if the nodes are the same node, a negative number if node1\\n *     is before node2, and a positive number if node2 is before node1.\\n */\\ngoog.dom.compareNodeOrder = function(node1, node2) {\\n  'use strict';\\n  // Fall out quickly for equality.\\n  if (node1 == node2) {\\n    return 0;\\n  }\\n\\n  // Use compareDocumentPosition where available\\n  if (node1.compareDocumentPosition) {\\n    // 4 is the bitmask for FOLLOWS.\\n    return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;\\n  }\\n\\n  // Special case for document nodes on IE 7 and 8.\\n  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {\\n    if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {\\n      return -1;\\n    }\\n    if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {\\n      return 1;\\n    }\\n  }\\n\\n  // Process in IE using sourceIndex - we check to see if the first node has\\n  // a source index or if its parent has one.\\n  if ('sourceIndex' in node1 ||\\n      (node1.parentNode && 'sourceIndex' in node1.parentNode)) {\\n    var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;\\n    var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;\\n\\n    if (isElement1 && isElement2) {\\n      return node1.sourceIndex - node2.sourceIndex;\\n    } else {\\n      var parent1 = node1.parentNode;\\n      var parent2 = node2.parentNode;\\n\\n      if (parent1 == parent2) {\\n        return goog.dom.compareSiblingOrder_(node1, node2);\\n      }\\n\\n      if (!isElement1 && goog.dom.contains(parent1, node2)) {\\n        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);\\n      }\\n\\n\\n      if (!isElement2 && goog.dom.contains(parent2, node1)) {\\n        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);\\n      }\\n\\n      return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -\\n          (isElement2 ? node2.sourceIndex : parent2.sourceIndex);\\n    }\\n  }\\n\\n  // For Safari, we compare ranges.\\n  var doc = goog.dom.getOwnerDocument(node1);\\n\\n  var range1, range2;\\n  range1 = doc.createRange();\\n  range1.selectNode(node1);\\n  range1.collapse(true);\\n\\n  range2 = doc.createRange();\\n  range2.selectNode(node2);\\n  range2.collapse(true);\\n\\n  return range1.compareBoundaryPoints(\\n      goog.global['Range'].START_TO_END, range2);\\n};\\n\\n\\n/**\\n * Utility function to compare the position of two nodes, when\\n * `textNode`'s parent is an ancestor of `node`.  If this entry\\n * condition is not met, this function will attempt to reference a null object.\\n * @param {!Node} textNode The textNode to compare.\\n * @param {Node} node The node to compare.\\n * @return {number} -1 if node is before textNode, +1 otherwise.\\n * @private\\n */\\ngoog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {\\n  'use strict';\\n  var parent = textNode.parentNode;\\n  if (parent == node) {\\n    // If textNode is a child of node, then node comes first.\\n    return -1;\\n  }\\n  var sibling = node;\\n  while (sibling.parentNode != parent) {\\n    sibling = sibling.parentNode;\\n  }\\n  return goog.dom.compareSiblingOrder_(sibling, textNode);\\n};\\n\\n\\n/**\\n * Utility function to compare the position of two nodes known to be non-equal\\n * siblings.\\n * @param {Node} node1 The first node to compare.\\n * @param {!Node} node2 The second node to compare.\\n * @return {number} -1 if node1 is before node2, +1 otherwise.\\n * @private\\n */\\ngoog.dom.compareSiblingOrder_ = function(node1, node2) {\\n  'use strict';\\n  var s = node2;\\n  while ((s = s.previousSibling)) {\\n    if (s == node1) {\\n      // We just found node1 before node2.\\n      return -1;\\n    }\\n  }\\n\\n  // Since we didn't find it, node1 must be after node2.\\n  return 1;\\n};\\n\\n\\n/**\\n * Find the deepest common ancestor of the given nodes.\\n * @param {...Node} var_args The nodes to find a common ancestor of.\\n * @return {Node} The common ancestor of the nodes, or null if there is none.\\n *     null will only be returned if two or more of the nodes are from different\\n *     documents.\\n */\\ngoog.dom.findCommonAncestor = function(var_args) {\\n  'use strict';\\n  var i, count = arguments.length;\\n  if (!count) {\\n    return null;\\n  } else if (count == 1) {\\n    return arguments[0];\\n  }\\n\\n  var paths = [];\\n  var minLength = Infinity;\\n  for (i = 0; i < count; i++) {\\n    // Compute the list of ancestors.\\n    var ancestors = [];\\n    var node = arguments[i];\\n    while (node) {\\n      ancestors.unshift(node);\\n      node = node.parentNode;\\n    }\\n\\n    // Save the list for comparison.\\n    paths.push(ancestors);\\n    minLength = Math.min(minLength, ancestors.length);\\n  }\\n  var output = null;\\n  for (i = 0; i < minLength; i++) {\\n    var first = paths[0][i];\\n    for (var j = 1; j < count; j++) {\\n      if (first != paths[j][i]) {\\n        return output;\\n      }\\n    }\\n    output = first;\\n  }\\n  return output;\\n};\\n\\n\\n/**\\n * Returns whether node is in a document or detached. Throws an error if node\\n * itself is a document. This specifically handles two cases beyond naive use of\\n * builtins: (1) it works correctly in IE, and (2) it works for elements from\\n * different documents/iframes. If neither of these considerations are relevant\\n * then a simple `document.contains(node)` may be used instead.\\n * @param {!Node} node\\n * @return {boolean}\\n */\\ngoog.dom.isInDocument = function(node) {\\n  'use strict';\\n  return (node.ownerDocument.compareDocumentPosition(node) & 16) == 16;\\n};\\n\\n\\n/**\\n * Returns the owner document for a node.\\n * @param {Node|Window} node The node to get the document for.\\n * @return {!Document} The document owning the node.\\n */\\ngoog.dom.getOwnerDocument = function(node) {\\n  'use strict';\\n  // TODO(nnaze): Update param signature to be non-nullable.\\n  goog.asserts.assert(node, 'Node cannot be null or undefined.');\\n  return /** @type {!Document} */ (\\n      node.nodeType == goog.dom.NodeType.DOCUMENT ? node : node.ownerDocument ||\\n              node.document);\\n};\\n\\n\\n/**\\n * Cross-browser function for getting the document element of a frame or iframe.\\n * @param {Element} frame Frame element.\\n * @return {!Document} The frame content document.\\n */\\ngoog.dom.getFrameContentDocument = function(frame) {\\n  'use strict';\\n  return frame.contentDocument ||\\n      /** @type {!HTMLFrameElement} */ (frame).contentWindow.document;\\n};\\n\\n\\n/**\\n * Cross-browser function for getting the window of a frame or iframe.\\n * @param {Element} frame Frame element.\\n * @return {Window} The window associated with the given frame, or null if none\\n *     exists.\\n */\\ngoog.dom.getFrameContentWindow = function(frame) {\\n  'use strict';\\n  try {\\n    return frame.contentWindow ||\\n        (frame.contentDocument ? goog.dom.getWindow(frame.contentDocument) :\\n                                 null);\\n  } catch (e) {\\n    // NOTE(user): In IE8, checking the contentWindow or contentDocument\\n    // properties will throw a \\\"Unspecified Error\\\" exception if the iframe is\\n    // not inserted in the DOM. If we get this we can be sure that no window\\n    // exists, so return null.\\n  }\\n  return null;\\n};\\n\\n\\n/**\\n * Sets the text content of a node, with cross-browser support.\\n * @param {Node} node The node to change the text content of.\\n * @param {string|number} text The value that should replace the node's content.\\n */\\ngoog.dom.setTextContent = function(node, text) {\\n  'use strict';\\n  goog.asserts.assert(\\n      node != null,\\n      'goog.dom.setTextContent expects a non-null value for node');\\n\\n  if ('textContent' in node) {\\n    node.textContent = text;\\n  } else if (node.nodeType == goog.dom.NodeType.TEXT) {\\n    /** @type {!Text} */ (node).data = String(text);\\n  } else if (\\n      node.firstChild && node.firstChild.nodeType == goog.dom.NodeType.TEXT) {\\n    // If the first child is a text node we just change its data and remove the\\n    // rest of the children.\\n    while (node.lastChild != node.firstChild) {\\n      node.removeChild(goog.asserts.assert(node.lastChild));\\n    }\\n    /** @type {!Text} */ (node.firstChild).data = String(text);\\n  } else {\\n    goog.dom.removeChildren(node);\\n    var doc = goog.dom.getOwnerDocument(node);\\n    node.appendChild(doc.createTextNode(String(text)));\\n  }\\n};\\n\\n\\n/**\\n * Gets the outerHTML of a node, which is like innerHTML, except that it\\n * actually contains the HTML of the node itself.\\n * @param {Element} element The element to get the HTML of.\\n * @return {string} The outerHTML of the given element.\\n */\\ngoog.dom.getOuterHtml = function(element) {\\n  'use strict';\\n  goog.asserts.assert(\\n      element !== null,\\n      'goog.dom.getOuterHtml expects a non-null value for element');\\n  // IE, Opera and WebKit all have outerHTML.\\n  if ('outerHTML' in element) {\\n    return element.outerHTML;\\n  } else {\\n    var doc = goog.dom.getOwnerDocument(element);\\n    var div = goog.dom.createElement_(doc, goog.dom.TagName.DIV);\\n    div.appendChild(element.cloneNode(true));\\n    return div.innerHTML;\\n  }\\n};\\n\\n\\n/**\\n * Finds the first descendant node that matches the filter function, using depth\\n * first search. This function offers the most general purpose way of finding a\\n * matching element.\\n *\\n * Prefer using `querySelector` if the matching criteria can be expressed as a\\n * CSS selector, or `goog.dom.findElement` if you would filter for `nodeType ==\\n * Node.ELEMENT_NODE`.\\n *\\n * @param {Node} root The root of the tree to search.\\n * @param {function(Node) : boolean} p The filter function.\\n * @return {Node|undefined} The found node or undefined if none is found.\\n */\\ngoog.dom.findNode = function(root, p) {\\n  'use strict';\\n  var rv = [];\\n  var found = goog.dom.findNodes_(root, p, rv, true);\\n  return found ? rv[0] : undefined;\\n};\\n\\n\\n/**\\n * Finds all the descendant nodes that match the filter function, using depth\\n * first search. This function offers the most general-purpose way\\n * of finding a set of matching elements.\\n *\\n * Prefer using `querySelectorAll` if the matching criteria can be expressed as\\n * a CSS selector, or `goog.dom.findElements` if you would filter for\\n * `nodeType == Node.ELEMENT_NODE`.\\n *\\n * @param {Node} root The root of the tree to search.\\n * @param {function(Node) : boolean} p The filter function.\\n * @return {!Array<!Node>} The found nodes or an empty array if none are found.\\n */\\ngoog.dom.findNodes = function(root, p) {\\n  'use strict';\\n  var rv = [];\\n  goog.dom.findNodes_(root, p, rv, false);\\n  return rv;\\n};\\n\\n\\n/**\\n * Finds the first or all the descendant nodes that match the filter function,\\n * using a depth first search.\\n * @param {Node} root The root of the tree to search.\\n * @param {function(Node) : boolean} p The filter function.\\n * @param {!Array<!Node>} rv The found nodes are added to this array.\\n * @param {boolean} findOne If true we exit after the first found node.\\n * @return {boolean} Whether the search is complete or not. True in case findOne\\n *     is true and the node is found. False otherwise.\\n * @private\\n */\\ngoog.dom.findNodes_ = function(root, p, rv, findOne) {\\n  'use strict';\\n  if (root != null) {\\n    var child = root.firstChild;\\n    while (child) {\\n      if (p(child)) {\\n        rv.push(child);\\n        if (findOne) {\\n          return true;\\n        }\\n      }\\n      if (goog.dom.findNodes_(child, p, rv, findOne)) {\\n        return true;\\n      }\\n      child = child.nextSibling;\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * Finds the first descendant element (excluding `root`) that matches the filter\\n * function, using depth first search. Prefer using `querySelector` if the\\n * matching criteria can be expressed as a CSS selector.\\n *\\n * @param {!Element | !Document} root\\n * @param {function(!Element): boolean} pred Filter function.\\n * @return {?Element} First matching element or null if there is none.\\n */\\ngoog.dom.findElement = function(root, pred) {\\n  'use strict';\\n  var stack = goog.dom.getChildrenReverse_(root);\\n  while (stack.length > 0) {\\n    var next = stack.pop();\\n    if (pred(next)) return next;\\n    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {\\n      stack.push(c);\\n    }\\n  }\\n  return null;\\n};\\n\\n\\n/**\\n * Finds all the descendant elements (excluding `root`) that match the filter\\n * function, using depth first search. Prefer using `querySelectorAll` if the\\n * matching criteria can be expressed as a CSS selector.\\n *\\n * @param {!Element | !Document} root\\n * @param {function(!Element): boolean} pred Filter function.\\n * @return {!Array<!Element>}\\n */\\ngoog.dom.findElements = function(root, pred) {\\n  'use strict';\\n  var result = [], stack = goog.dom.getChildrenReverse_(root);\\n  while (stack.length > 0) {\\n    var next = stack.pop();\\n    if (pred(next)) result.push(next);\\n    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {\\n      stack.push(c);\\n    }\\n  }\\n  return result;\\n};\\n\\n\\n/**\\n * @param {!Element | !Document} node\\n * @return {!Array<!Element>} node's child elements in reverse order.\\n * @private\\n */\\ngoog.dom.getChildrenReverse_ = function(node) {\\n  'use strict';\\n  // document.lastElementChild doesn't exist in IE9; fall back to\\n  // documentElement.\\n  if (node.nodeType == goog.dom.NodeType.DOCUMENT) {\\n    return [node.documentElement];\\n  } else {\\n    var children = [];\\n    for (var c = node.lastElementChild; c; c = c.previousElementSibling) {\\n      children.push(c);\\n    }\\n    return children;\\n  }\\n};\\n\\n\\n/**\\n * Map of tags whose content to ignore when calculating text length.\\n * @private {!Object<string, number>}\\n * @const\\n */\\ngoog.dom.TAGS_TO_IGNORE_ = {\\n  'SCRIPT': 1,\\n  'STYLE': 1,\\n  'HEAD': 1,\\n  'IFRAME': 1,\\n  'OBJECT': 1\\n};\\n\\n\\n/**\\n * Map of tags which have predefined values with regard to whitespace.\\n * @private {!Object<string, string>}\\n * @const\\n */\\ngoog.dom.PREDEFINED_TAG_VALUES_ = {\\n  'IMG': ' ',\\n  'BR': '\\\\n'\\n};\\n\\n\\n/**\\n * Returns true if the element has a tab index that allows it to receive\\n * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements\\n * natively support keyboard focus, even if they have no tab index.\\n * @param {!Element} element Element to check.\\n * @return {boolean} Whether the element has a tab index that allows keyboard\\n *     focus.\\n */\\ngoog.dom.isFocusableTabIndex = function(element) {\\n  'use strict';\\n  return goog.dom.hasSpecifiedTabIndex_(element) &&\\n      goog.dom.isTabIndexFocusable_(element);\\n};\\n\\n\\n/**\\n * Enables or disables keyboard focus support on the element via its tab index.\\n * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true\\n * (or elements that natively support keyboard focus, like form elements) can\\n * receive keyboard focus.  See http://go/tabindex for more info.\\n * @param {Element} element Element whose tab index is to be changed.\\n * @param {boolean} enable Whether to set or remove a tab index on the element\\n *     that supports keyboard focus.\\n */\\ngoog.dom.setFocusableTabIndex = function(element, enable) {\\n  'use strict';\\n  if (enable) {\\n    element.tabIndex = 0;\\n  } else {\\n    // Set tabIndex to -1 first, then remove it. This is a workaround for\\n    // Safari (confirmed in version 4 on Windows). When removing the attribute\\n    // without setting it to -1 first, the element remains keyboard focusable\\n    // despite not having a tabIndex attribute anymore.\\n    element.tabIndex = -1;\\n    element.removeAttribute('tabIndex');  // Must be camelCase!\\n  }\\n};\\n\\n\\n/**\\n * Returns true if the element can be focused, i.e. it has a tab index that\\n * allows it to receive keyboard focus (tabIndex >= 0), or it is an element\\n * that natively supports keyboard focus.\\n * @param {!Element} element Element to check.\\n * @return {boolean} Whether the element allows keyboard focus.\\n */\\ngoog.dom.isFocusable = function(element) {\\n  'use strict';\\n  var focusable;\\n  // Some elements can have unspecified tab index and still receive focus.\\n  if (goog.dom.nativelySupportsFocus_(element)) {\\n    // Make sure the element is not disabled ...\\n    focusable = !element.disabled &&\\n        // ... and if a tab index is specified, it allows focus.\\n        (!goog.dom.hasSpecifiedTabIndex_(element) ||\\n         goog.dom.isTabIndexFocusable_(element));\\n  } else {\\n    focusable = goog.dom.isFocusableTabIndex(element);\\n  }\\n\\n  // IE requires elements to be visible in order to focus them.\\n  return focusable && goog.userAgent.IE ?\\n      goog.dom.hasNonZeroBoundingRect_(/** @type {!HTMLElement} */ (element)) :\\n      focusable;\\n};\\n\\n\\n/**\\n * Returns true if the element has a specified tab index.\\n * @param {!Element} element Element to check.\\n * @return {boolean} Whether the element has a specified tab index.\\n * @private\\n */\\ngoog.dom.hasSpecifiedTabIndex_ = function(element) {\\n  'use strict';\\n  // IE8 and below don't support hasAttribute(), instead check whether the\\n  // 'tabindex' attributeNode is specified. Otherwise check hasAttribute().\\n  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')) {\\n    var attrNode = element.getAttributeNode('tabindex');  // Must be lowercase!\\n    return attrNode != null && attrNode.specified;\\n  } else {\\n    return element.hasAttribute('tabindex');\\n  }\\n};\\n\\n\\n/**\\n * Returns true if the element's tab index allows the element to be focused.\\n * @param {!Element} element Element to check.\\n * @return {boolean} Whether the element's tab index allows focus.\\n * @private\\n */\\ngoog.dom.isTabIndexFocusable_ = function(element) {\\n  'use strict';\\n  var index = /** @type {!HTMLElement} */ (element).tabIndex;\\n  // NOTE: IE9 puts tabIndex in 16-bit int, e.g. -2 is 65534.\\n  return typeof (index) === 'number' && index >= 0 && index < 32768;\\n};\\n\\n\\n/**\\n * Returns true if the element is focusable even when tabIndex is not set.\\n * @param {!Element} element Element to check.\\n * @return {boolean} Whether the element natively supports focus.\\n * @private\\n */\\ngoog.dom.nativelySupportsFocus_ = function(element) {\\n  'use strict';\\n  return (\\n      element.tagName == goog.dom.TagName.A && element.hasAttribute('href') ||\\n      element.tagName == goog.dom.TagName.INPUT ||\\n      element.tagName == goog.dom.TagName.TEXTAREA ||\\n      element.tagName == goog.dom.TagName.SELECT ||\\n      element.tagName == goog.dom.TagName.BUTTON);\\n};\\n\\n\\n/**\\n * Returns true if the element has a bounding rectangle that would be visible\\n * (i.e. its width and height are greater than zero).\\n * @param {!HTMLElement} element Element to check.\\n * @return {boolean} Whether the element has a non-zero bounding rectangle.\\n * @private\\n */\\ngoog.dom.hasNonZeroBoundingRect_ = function(element) {\\n  'use strict';\\n  var rect;\\n  if (typeof element['getBoundingClientRect'] !== 'function' ||\\n      // In IE, getBoundingClientRect throws on detached nodes.\\n      (goog.userAgent.IE && element.parentElement == null)) {\\n    rect = {'height': element.offsetHeight, 'width': element.offsetWidth};\\n  } else {\\n    rect = element.getBoundingClientRect();\\n  }\\n  return rect != null && rect.height > 0 && rect.width > 0;\\n};\\n\\n\\n/**\\n * Returns the text content of the current node, without markup and invisible\\n * symbols. New lines are stripped and whitespace is collapsed,\\n * such that each character would be visible.\\n *\\n * In browsers that support it, innerText is used.  Other browsers attempt to\\n * simulate it via node traversal.  Line breaks are canonicalized in IE.\\n *\\n * @param {Node} node The node from which we are getting content.\\n * @return {string} The text content.\\n */\\ngoog.dom.getTextContent = function(node) {\\n  'use strict';\\n  var textContent;\\n  // Note(arv): IE9, Opera, and Safari 3 support innerText but they include\\n  // text nodes in script tags. So we revert to use a user agent test here.\\n  if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && node !== null &&\\n      ('innerText' in node)) {\\n    textContent = goog.string.canonicalizeNewlines(node.innerText);\\n    // Unfortunately .innerText() returns text with &shy; symbols\\n    // We need to filter it out and then remove duplicate whitespaces\\n  } else {\\n    var buf = [];\\n    goog.dom.getTextContent_(node, buf, true);\\n    textContent = buf.join('');\\n  }\\n\\n  // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.\\n  textContent = textContent.replace(/ \\\\xAD /g, ' ').replace(/\\\\xAD/g, '');\\n  // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.\\n  textContent = textContent.replace(/\\\\u200B/g, '');\\n\\n  // Skip this replacement on old browsers with working innerText, which\\n  // automatically turns &nbsp; into ' ' and / +/ into ' ' when reading\\n  // innerText.\\n  if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) {\\n    textContent = textContent.replace(/ +/g, ' ');\\n  }\\n  if (textContent != ' ') {\\n    textContent = textContent.replace(/^\\\\s*/, '');\\n  }\\n\\n  return textContent;\\n};\\n\\n\\n/**\\n * Returns the text content of the current node, without markup.\\n *\\n * Unlike `getTextContent` this method does not collapse whitespaces\\n * or normalize lines breaks.\\n *\\n * @param {Node} node The node from which we are getting content.\\n * @return {string} The raw text content.\\n */\\ngoog.dom.getRawTextContent = function(node) {\\n  'use strict';\\n  var buf = [];\\n  goog.dom.getTextContent_(node, buf, false);\\n\\n  return buf.join('');\\n};\\n\\n\\n/**\\n * Recursive support function for text content retrieval.\\n *\\n * @param {Node} node The node from which we are getting content.\\n * @param {Array<string>} buf string buffer.\\n * @param {boolean} normalizeWhitespace Whether to normalize whitespace.\\n * @private\\n */\\ngoog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {\\n  'use strict';\\n  if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {\\n    // ignore certain tags\\n  } else if (node.nodeType == goog.dom.NodeType.TEXT) {\\n    if (normalizeWhitespace) {\\n      buf.push(String(node.nodeValue).replace(/(\\\\r\\\\n|\\\\r|\\\\n)/g, ''));\\n    } else {\\n      buf.push(node.nodeValue);\\n    }\\n  } else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {\\n    buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);\\n  } else {\\n    var child = node.firstChild;\\n    while (child) {\\n      goog.dom.getTextContent_(child, buf, normalizeWhitespace);\\n      child = child.nextSibling;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Returns the text length of the text contained in a node, without markup. This\\n * is equivalent to the selection length if the node was selected, or the number\\n * of cursor movements to traverse the node. Images & BRs take one space.  New\\n * lines are ignored.\\n *\\n * @param {Node} node The node whose text content length is being calculated.\\n * @return {number} The length of `node`'s text content.\\n */\\ngoog.dom.getNodeTextLength = function(node) {\\n  'use strict';\\n  return goog.dom.getTextContent(node).length;\\n};\\n\\n\\n/**\\n * Returns the text offset of a node relative to one of its ancestors. The text\\n * length is the same as the length calculated by goog.dom.getNodeTextLength.\\n *\\n * @param {Node} node The node whose offset is being calculated.\\n * @param {Node=} opt_offsetParent The node relative to which the offset will\\n *     be calculated. Defaults to the node's owner document's body.\\n * @return {number} The text offset.\\n */\\ngoog.dom.getNodeTextOffset = function(node, opt_offsetParent) {\\n  'use strict';\\n  var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;\\n  var buf = [];\\n  while (node && node != root) {\\n    var cur = node;\\n    while ((cur = cur.previousSibling)) {\\n      buf.unshift(goog.dom.getTextContent(cur));\\n    }\\n    node = node.parentNode;\\n  }\\n  // Trim left to deal with FF cases when there might be line breaks and empty\\n  // nodes at the front of the text\\n  return goog.string.trimLeft(buf.join('')).replace(/ +/g, ' ').length;\\n};\\n\\n\\n/**\\n * Returns the node at a given offset in a parent node.  If an object is\\n * provided for the optional third parameter, the node and the remainder of the\\n * offset will stored as properties of this object.\\n * @param {Node} parent The parent node.\\n * @param {number} offset The offset into the parent node.\\n * @param {Object=} opt_result Object to be used to store the return value. The\\n *     return value will be stored in the form {node: Node, remainder: number}\\n *     if this object is provided.\\n * @return {Node} The node at the given offset.\\n */\\ngoog.dom.getNodeAtOffset = function(parent, offset, opt_result) {\\n  'use strict';\\n  var stack = [parent], pos = 0, cur = null;\\n  while (stack.length > 0 && pos < offset) {\\n    cur = stack.pop();\\n    if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {\\n      // ignore certain tags\\n    } else if (cur.nodeType == goog.dom.NodeType.TEXT) {\\n      var text = cur.nodeValue.replace(/(\\\\r\\\\n|\\\\r|\\\\n)/g, '').replace(/ +/g, ' ');\\n      pos += text.length;\\n    } else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {\\n      pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;\\n    } else {\\n      for (var i = cur.childNodes.length - 1; i >= 0; i--) {\\n        stack.push(cur.childNodes[i]);\\n      }\\n    }\\n  }\\n  if (goog.isObject(opt_result)) {\\n    opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;\\n    opt_result.node = cur;\\n  }\\n\\n  return cur;\\n};\\n\\n\\n/**\\n * Returns true if the object is a `NodeList`.  To qualify as a NodeList,\\n * the object must have a numeric length property and an item function (which\\n * has type 'string' on IE for some reason).\\n * @param {Object} val Object to test.\\n * @return {boolean} Whether the object is a NodeList.\\n */\\ngoog.dom.isNodeList = function(val) {\\n  'use strict';\\n  // TODO(attila): Now the isNodeList is part of goog.dom we can use\\n  // goog.userAgent to make this simpler.\\n  // A NodeList must have a length property of type 'number' on all platforms.\\n  if (val && typeof val.length == 'number') {\\n    // A NodeList is an object everywhere except Safari, where it's a function.\\n    if (goog.isObject(val)) {\\n      // A NodeList must have an item function (on non-IE platforms) or an item\\n      // property of type 'string' (on IE).\\n      return typeof val.item == 'function' || typeof val.item == 'string';\\n    } else if (typeof val === 'function') {\\n      // On Safari, a NodeList is a function with an item property that is also\\n      // a function.\\n      return typeof /** @type {?} */ (val.item) == 'function';\\n    }\\n  }\\n\\n  // Not a NodeList.\\n  return false;\\n};\\n\\n\\n/**\\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\\n * tag name and/or class name. If the passed element matches the specified\\n * criteria, the element itself is returned.\\n * @param {Node} element The DOM node to start with.\\n * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or\\n *     null/undefined to match only based on class name).\\n * @param {?string=} opt_class The class name to match (or null/undefined to\\n *     match only based on tag name).\\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\\n *     dom.\\n * @return {?R} The first ancestor that matches the passed criteria, or\\n *     null if no match is found. The return type is {?Element} if opt_tag is\\n *     not a member of goog.dom.TagName or a more specific type if it is (e.g.\\n *     {?HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.getAncestorByTagNameAndClass = function(\\n    element, opt_tag, opt_class, opt_maxSearchSteps) {\\n  'use strict';\\n  if (!opt_tag && !opt_class) {\\n    return null;\\n  }\\n  var tagName = opt_tag ? String(opt_tag).toUpperCase() : null;\\n  return /** @type {Element} */ (goog.dom.getAncestor(element, function(node) {\\n    'use strict';\\n    return (!tagName || node.nodeName == tagName) &&\\n        (!opt_class ||\\n         typeof node.className === 'string' &&\\n             goog.array.contains(node.className.split(/\\\\s+/), opt_class));\\n  }, true, opt_maxSearchSteps));\\n};\\n\\n\\n/**\\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\\n * class name. If the passed element matches the specified criteria, the\\n * element itself is returned.\\n * @param {Node} element The DOM node to start with.\\n * @param {string} className The class name to match.\\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\\n *     dom.\\n * @return {Element} The first ancestor that matches the passed criteria, or\\n *     null if none match.\\n */\\ngoog.dom.getAncestorByClass = function(element, className, opt_maxSearchSteps) {\\n  'use strict';\\n  return goog.dom.getAncestorByTagNameAndClass(\\n      element, null, className, opt_maxSearchSteps);\\n};\\n\\n\\n/**\\n * Walks up the DOM hierarchy returning the first ancestor that passes the\\n * matcher function.\\n * @param {Node} element The DOM node to start with.\\n * @param {function(!Node) : boolean} matcher A function that returns true if\\n *     the passed node matches the desired criteria.\\n * @param {boolean=} opt_includeNode If true, the node itself is included in\\n *     the search (the first call to the matcher will pass startElement as\\n *     the node to test).\\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\\n *     dom.\\n * @return {Node} DOM node that matched the matcher, or null if there was\\n *     no match.\\n */\\ngoog.dom.getAncestor = function(\\n    element, matcher, opt_includeNode, opt_maxSearchSteps) {\\n  'use strict';\\n  if (element && !opt_includeNode) {\\n    element = element.parentNode;\\n  }\\n  var steps = 0;\\n  while (element &&\\n         (opt_maxSearchSteps == null || steps <= opt_maxSearchSteps)) {\\n    goog.asserts.assert(element.name != 'parentNode');\\n    if (matcher(element)) {\\n      return element;\\n    }\\n    element = element.parentNode;\\n    steps++;\\n  }\\n  // Reached the root of the DOM without a match\\n  return null;\\n};\\n\\n\\n/**\\n * Determines the active element in the given document.\\n * @param {Document} doc The document to look in.\\n * @return {Element} The active element.\\n */\\ngoog.dom.getActiveElement = function(doc) {\\n  'use strict';\\n  // While in an iframe, IE9 will throw \\\"Unspecified error\\\" when accessing\\n  // activeElement.\\n  try {\\n    var activeElement = doc && doc.activeElement;\\n    // While not in an iframe, IE9-11 sometimes gives null.\\n    // While in an iframe, IE11 sometimes returns an empty object.\\n    return activeElement && activeElement.nodeName ? activeElement : null;\\n  } catch (e) {\\n    return null;\\n  }\\n};\\n\\n\\n/**\\n * Gives the current devicePixelRatio.\\n *\\n * By default, this is the value of window.devicePixelRatio (which should be\\n * preferred if present).\\n *\\n * If window.devicePixelRatio is not present, the ratio is calculated with\\n * window.matchMedia, if present. Otherwise, gives 1.0.\\n *\\n * Some browsers (including Chrome) consider the browser zoom level in the pixel\\n * ratio, so the value may change across multiple calls.\\n *\\n * @return {number} The number of actual pixels per virtual pixel.\\n */\\ngoog.dom.getPixelRatio = function() {\\n  'use strict';\\n  var win = goog.dom.getWindow();\\n  if (win.devicePixelRatio !== undefined) {\\n    return win.devicePixelRatio;\\n  } else if (win.matchMedia) {\\n    // Should be for IE10 and FF6-17 (this basically clamps to lower)\\n    // Note that the order of these statements is important\\n    return goog.dom.matchesPixelRatio_(3) || goog.dom.matchesPixelRatio_(2) ||\\n           goog.dom.matchesPixelRatio_(1.5) || goog.dom.matchesPixelRatio_(1) ||\\n           .75;\\n  }\\n  return 1;\\n};\\n\\n\\n/**\\n * Calculates a mediaQuery to check if the current device supports the\\n * given actual to virtual pixel ratio.\\n * @param {number} pixelRatio The ratio of actual pixels to virtual pixels.\\n * @return {number} pixelRatio if applicable, otherwise 0.\\n * @private\\n */\\ngoog.dom.matchesPixelRatio_ = function(pixelRatio) {\\n  'use strict';\\n  var win = goog.dom.getWindow();\\n  /**\\n   * Due to the 1:96 fixed ratio of CSS in to CSS px, 1dppx is equivalent to\\n   * 96dpi.\\n   * @const {number}\\n   */\\n  var dpiPerDppx = 96;\\n  var query =\\n      // FF16-17\\n      '(min-resolution: ' + pixelRatio + 'dppx),' +\\n      // FF6-15\\n      '(min--moz-device-pixel-ratio: ' + pixelRatio + '),' +\\n      // IE10 (this works for the two browsers above too but I don't want to\\n      // trust the 1:96 fixed ratio magic)\\n      '(min-resolution: ' + (pixelRatio * dpiPerDppx) + 'dpi)';\\n  return win.matchMedia(query).matches ? pixelRatio : 0;\\n};\\n\\n\\n/**\\n * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a\\n * type information.\\n * @param {!HTMLCanvasElement|!OffscreenCanvas} canvas\\n * @return {!CanvasRenderingContext2D}\\n */\\ngoog.dom.getCanvasContext2D = function(canvas) {\\n  'use strict';\\n  return /** @type {!CanvasRenderingContext2D} */ (canvas.getContext('2d'));\\n};\\n\\n\\n\\n/**\\n * Create an instance of a DOM helper with a new document object.\\n * @param {Document=} opt_document Document object to associate with this\\n *     DOM helper.\\n * @constructor\\n */\\ngoog.dom.DomHelper = function(opt_document) {\\n  'use strict';\\n  /**\\n   * Reference to the document object to use\\n   * @type {!Document}\\n   * @private\\n   */\\n  this.document_ = opt_document || goog.global.document || document;\\n};\\n\\n\\n/**\\n * Gets the dom helper object for the document where the element resides.\\n * @param {Node=} opt_node If present, gets the DomHelper for this node.\\n * @return {!goog.dom.DomHelper} The DomHelper.\\n */\\ngoog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;\\n\\n\\n/**\\n * Sets the document object.\\n * @param {!Document} document Document object.\\n */\\ngoog.dom.DomHelper.prototype.setDocument = function(document) {\\n  'use strict';\\n  this.document_ = document;\\n};\\n\\n\\n/**\\n * Gets the document object being used by the dom library.\\n * @return {!Document} Document object.\\n */\\ngoog.dom.DomHelper.prototype.getDocument = function() {\\n  'use strict';\\n  return this.document_;\\n};\\n\\n\\n/**\\n * Alias for `getElementById`. If a DOM node is passed in then we just\\n * return that.\\n * @param {string|Element} element Element ID or a DOM node.\\n * @return {Element} The element with the given ID, or the node passed in.\\n */\\ngoog.dom.DomHelper.prototype.getElement = function(element) {\\n  'use strict';\\n  return goog.dom.getElementHelper_(this.document_, element);\\n};\\n\\n\\n/**\\n * Gets an element by id, asserting that the element is found.\\n *\\n * This is used when an element is expected to exist, and should fail with\\n * an assertion error if it does not (if assertions are enabled).\\n *\\n * @param {string} id Element ID.\\n * @return {!Element} The element with the given ID, if it exists.\\n */\\ngoog.dom.DomHelper.prototype.getRequiredElement = function(id) {\\n  'use strict';\\n  return goog.dom.getRequiredElementHelper_(this.document_, id);\\n};\\n\\n\\n/**\\n * Alias for `getElement`.\\n * @param {string|Element} element Element ID or a DOM node.\\n * @return {Element} The element with the given ID, or the node passed in.\\n * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.\\n */\\ngoog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;\\n\\n\\n/**\\n * Gets elements by tag name.\\n * @param {!goog.dom.TagName<T>} tagName\\n * @param {(!Document|!Element)=} opt_parent Parent element or document where to\\n *     look for elements. Defaults to document of this DomHelper.\\n * @return {!NodeList<R>} List of elements. The members of the list are\\n *     {!Element} if tagName is not a member of goog.dom.TagName or more\\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\\n *     goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.DomHelper.prototype.getElementsByTagName = function(\\n    tagName, opt_parent) {\\n  'use strict';\\n  var parent = opt_parent || this.document_;\\n  return parent.getElementsByTagName(String(tagName));\\n};\\n\\n\\n/**\\n * Looks up elements by both tag and class name, using browser native functions\\n * (`querySelectorAll`, `getElementsByTagName` or\\n * `getElementsByClassName`) where possible. The returned array is a live\\n * NodeList or a static list depending on the code path taken.\\n *\\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name or * for all\\n *     tags.\\n * @param {?string=} opt_class Optional class name.\\n * @param {(Document|Element)=} opt_el Optional element to look in.\\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\\n *     and numerical indices are guaranteed to exist). The members of the array\\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\\n *     goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(\\n    opt_tag, opt_class, opt_el) {\\n  'use strict';\\n  return goog.dom.getElementsByTagNameAndClass_(\\n      this.document_, opt_tag, opt_class, opt_el);\\n};\\n\\n\\n/**\\n * Gets the first element matching the tag and the class.\\n *\\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\\n * @param {?string=} opt_class Optional class name.\\n * @param {(Document|Element)=} opt_el Optional element to look in.\\n * @return {?R} Reference to a DOM node. The return type is {?Element} if\\n *     tagName is a string or a more specific type if it is a member of\\n *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.DomHelper.prototype.getElementByTagNameAndClass = function(\\n    opt_tag, opt_class, opt_el) {\\n  'use strict';\\n  return goog.dom.getElementByTagNameAndClass_(\\n      this.document_, opt_tag, opt_class, opt_el);\\n};\\n\\n\\n/**\\n * Returns an array of all the elements with the provided className.\\n * @param {string} className the name of the class to look for.\\n * @param {Element|Document=} opt_el Optional element to look in.\\n * @return {!IArrayLike<!Element>} The items found with the class name provided.\\n */\\ngoog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {\\n  'use strict';\\n  var doc = opt_el || this.document_;\\n  return goog.dom.getElementsByClass(className, doc);\\n};\\n\\n\\n/**\\n * Returns the first element we find matching the provided class name.\\n * @param {string} className the name of the class to look for.\\n * @param {(Element|Document)=} opt_el Optional element to look in.\\n * @return {Element} The first item found with the class name provided.\\n */\\ngoog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {\\n  'use strict';\\n  var doc = opt_el || this.document_;\\n  return goog.dom.getElementByClass(className, doc);\\n};\\n\\n\\n/**\\n * Ensures an element with the given className exists, and then returns the\\n * first element with the provided className.\\n * @param {string} className the name of the class to look for.\\n * @param {(!Element|!Document)=} opt_root Optional element or document to look\\n *     in.\\n * @return {!Element} The first item found with the class name provided.\\n * @throws {goog.asserts.AssertionError} Thrown if no element is found.\\n */\\ngoog.dom.DomHelper.prototype.getRequiredElementByClass = function(\\n    className, opt_root) {\\n  'use strict';\\n  var root = opt_root || this.document_;\\n  return goog.dom.getRequiredElementByClass(className, root);\\n};\\n\\n\\n/**\\n * Alias for `getElementsByTagNameAndClass`.\\n * @deprecated Use DomHelper getElementsByTagNameAndClass.\\n *\\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\\n * @param {?string=} opt_class Optional class name.\\n * @param {Element=} opt_el Optional element to look in.\\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\\n *     and numerical indices are guaranteed to exist). The members of the array\\n *     are {!Element} if opt_tag is a string or more specific types if it is\\n *     a member of goog.dom.TagName (e.g. {!HTMLAnchorElement} for\\n *     goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.DomHelper.prototype.$$ =\\n    goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;\\n\\n\\n/**\\n * Sets a number of properties on a node.\\n * @param {Element} element DOM node to set properties on.\\n * @param {Object} properties Hash of property:value pairs.\\n */\\ngoog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;\\n\\n\\n/**\\n * Gets the dimensions of the viewport.\\n * @param {Window=} opt_window Optional window element to test. Defaults to\\n *     the window of the Dom Helper.\\n * @return {!goog.math.Size} Object with values 'width' and 'height'.\\n */\\ngoog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {\\n  'use strict';\\n  // TODO(arv): This should not take an argument. That breaks the rule of a\\n  // a DomHelper representing a single frame/window/document.\\n  return goog.dom.getViewportSize(opt_window || this.getWindow());\\n};\\n\\n\\n/**\\n * Calculates the height of the document.\\n *\\n * @return {number} The height of the document.\\n */\\ngoog.dom.DomHelper.prototype.getDocumentHeight = function() {\\n  'use strict';\\n  return goog.dom.getDocumentHeight_(this.getWindow());\\n};\\n\\n\\n/**\\n * Typedef for use with goog.dom.createDom and goog.dom.append.\\n * @typedef {Object|string|Array|NodeList}\\n */\\ngoog.dom.Appendable;\\n\\n\\n/**\\n * Returns a dom node with a set of attributes.  This function accepts varargs\\n * for subsequent nodes to be added.  Subsequent nodes will be added to the\\n * first node as childNodes.\\n *\\n * So:\\n * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),\\n * createDom(goog.dom.TagName.P));</code> would return a div with two child\\n * paragraphs\\n *\\n * An easy way to move all child nodes of an existing element to a new parent\\n * element is:\\n * <code>createDom(goog.dom.TagName.DIV, null, oldElement.childNodes);</code>\\n * which will remove all child nodes from the old element and add them as\\n * child nodes of the new DIV.\\n *\\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\\n *     of name-value pairs for attributes. If a string, then this is the\\n *     className of the new element. If an array, the elements will be joined\\n *     together as the className of the new element.\\n * @param {...(goog.dom.Appendable|undefined)} var_args Further DOM nodes or\\n *     strings for text nodes. If one of the var_args is an array or\\n *     NodeList, its elements will be added as childNodes instead.\\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\\n *     is a string or a more specific type if it is a member of\\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.DomHelper.prototype.createDom = function(\\n    tagName, opt_attributes, var_args) {\\n  'use strict';\\n  return goog.dom.createDom_(this.document_, arguments);\\n};\\n\\n\\n/**\\n * Alias for `createDom`.\\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\\n *     of name-value pairs for attributes. If a string, then this is the\\n *     className of the new element. If an array, the elements will be joined\\n *     together as the className of the new element.\\n * @param {...(goog.dom.Appendable|undefined)} var_args Further DOM nodes or\\n *     strings for text nodes.  If one of the var_args is an array, its children\\n *     will be added as childNodes instead.\\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\\n *     is a string or a more specific type if it is a member of\\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.\\n */\\ngoog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;\\n\\n\\n/**\\n * Creates a new element.\\n * @param {string|!goog.dom.TagName<T>} name Tag to create.\\n * @return {R} The new element. The return type is {!Element} if name is\\n *     a string or a more specific type if it is a member of goog.dom.TagName\\n *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.DomHelper.prototype.createElement = function(name) {\\n  'use strict';\\n  return goog.dom.createElement_(this.document_, name);\\n};\\n\\n\\n/**\\n * Creates a new text node.\\n * @param {number|string} content Content.\\n * @return {!Text} The new text node.\\n */\\ngoog.dom.DomHelper.prototype.createTextNode = function(content) {\\n  'use strict';\\n  return this.document_.createTextNode(String(content));\\n};\\n\\n\\n/**\\n * Create a table.\\n * @param {number} rows The number of rows in the table.  Must be >= 1.\\n * @param {number} columns The number of columns in the table.  Must be >= 1.\\n * @param {boolean=} opt_fillWithNbsp If true, fills table entries with\\n *     `goog.string.Unicode.NBSP` characters.\\n * @return {!HTMLElement} The created table.\\n */\\ngoog.dom.DomHelper.prototype.createTable = function(\\n    rows, columns, opt_fillWithNbsp) {\\n  'use strict';\\n  return goog.dom.createTable_(\\n      this.document_, rows, columns, !!opt_fillWithNbsp);\\n};\\n\\n\\n/**\\n * Converts an HTML into a node or a document fragment. A single Node is used if\\n * `html` only generates a single node. If `html` generates multiple\\n * nodes then these are put inside a `DocumentFragment`. This is a safe\\n * version of `goog.dom.DomHelper#htmlToDocumentFragment` which is now\\n * deleted.\\n * @param {!goog.html.SafeHtml} html The HTML markup to convert.\\n * @return {!Node} The resulting node.\\n */\\ngoog.dom.DomHelper.prototype.safeHtmlToNode = function(html) {\\n  'use strict';\\n  return goog.dom.safeHtmlToNode_(this.document_, html);\\n};\\n\\n\\n/**\\n * Returns true if the browser is in \\\"CSS1-compatible\\\" (standards-compliant)\\n * mode, false otherwise.\\n * @return {boolean} True if in CSS1-compatible mode.\\n */\\ngoog.dom.DomHelper.prototype.isCss1CompatMode = function() {\\n  'use strict';\\n  return goog.dom.isCss1CompatMode_(this.document_);\\n};\\n\\n\\n/**\\n * Gets the window object associated with the document.\\n * @return {!Window} The window associated with the given document.\\n */\\ngoog.dom.DomHelper.prototype.getWindow = function() {\\n  'use strict';\\n  return goog.dom.getWindow_(this.document_);\\n};\\n\\n\\n/**\\n * Gets the document scroll element.\\n * @return {!Element} Scrolling element.\\n */\\ngoog.dom.DomHelper.prototype.getDocumentScrollElement = function() {\\n  'use strict';\\n  return goog.dom.getDocumentScrollElement_(this.document_);\\n};\\n\\n\\n/**\\n * Gets the document scroll distance as a coordinate object.\\n * @return {!goog.math.Coordinate} Object with properties 'x' and 'y'.\\n */\\ngoog.dom.DomHelper.prototype.getDocumentScroll = function() {\\n  'use strict';\\n  return goog.dom.getDocumentScroll_(this.document_);\\n};\\n\\n\\n/**\\n * Determines the active element in the given document.\\n * @param {Document=} opt_doc The document to look in.\\n * @return {Element} The active element.\\n */\\ngoog.dom.DomHelper.prototype.getActiveElement = function(opt_doc) {\\n  'use strict';\\n  return goog.dom.getActiveElement(opt_doc || this.document_);\\n};\\n\\n\\n/**\\n * Appends a child to a node.\\n * @param {Node} parent Parent.\\n * @param {Node} child Child.\\n */\\ngoog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;\\n\\n\\n/**\\n * Appends a node with text or other nodes.\\n * @param {!Node} parent The node to append nodes to.\\n * @param {...goog.dom.Appendable} var_args The things to append to the node.\\n *     If this is a Node it is appended as is.\\n *     If this is a string then a text node is appended.\\n *     If this is an array like object then fields 0 to length - 1 are appended.\\n */\\ngoog.dom.DomHelper.prototype.append = goog.dom.append;\\n\\n\\n/**\\n * Determines if the given node can contain children, intended to be used for\\n * HTML generation.\\n *\\n * @param {Node} node The node to check.\\n * @return {boolean} Whether the node can contain children.\\n */\\ngoog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;\\n\\n\\n/**\\n * Removes all the child nodes on a DOM node.\\n * @param {Node} node Node to remove children from.\\n */\\ngoog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;\\n\\n\\n/**\\n * Inserts a new node before an existing reference node (i.e., as the previous\\n * sibling). If the reference node has no parent, then does nothing.\\n * @param {Node} newNode Node to insert.\\n * @param {Node} refNode Reference node to insert before.\\n */\\ngoog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;\\n\\n\\n/**\\n * Inserts a new node after an existing reference node (i.e., as the next\\n * sibling). If the reference node has no parent, then does nothing.\\n * @param {Node} newNode Node to insert.\\n * @param {Node} refNode Reference node to insert after.\\n */\\ngoog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;\\n\\n\\n/**\\n * Insert a child at a given index. If index is larger than the number of child\\n * nodes that the parent currently has, the node is inserted as the last child\\n * node.\\n * @param {Element} parent The element into which to insert the child.\\n * @param {Node} child The element to insert.\\n * @param {number} index The index at which to insert the new child node. Must\\n *     not be negative.\\n */\\ngoog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;\\n\\n\\n/**\\n * Removes a node from its parent.\\n * @param {Node} node The node to remove.\\n * @return {Node} The node removed if removed; else, null.\\n */\\ngoog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;\\n\\n\\n/**\\n * Replaces a node in the DOM tree. Will do nothing if `oldNode` has no\\n * parent.\\n * @param {Node} newNode Node to insert.\\n * @param {Node} oldNode Node to replace.\\n */\\ngoog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;\\n\\n\\n/**\\n * Replaces child nodes of `target` with child nodes of `source`. This is\\n * roughly equivalent to `target.innerHTML = source.innerHTML` which is not\\n * compatible with Trusted Types.\\n * @param {?Node} target Node to clean and replace its children.\\n * @param {?Node} source Node to get the children from. The nodes will be cloned\\n *     so they will stay in source.\\n */\\ngoog.dom.DomHelper.prototype.copyContents = goog.dom.copyContents;\\n\\n\\n/**\\n * Flattens an element. That is, removes it and replace it with its children.\\n * @param {Element} element The element to flatten.\\n * @return {Element|undefined} The original element, detached from the document\\n *     tree, sans children, or undefined if the element was already not in the\\n *     document.\\n */\\ngoog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;\\n\\n\\n/**\\n * Returns an array containing just the element children of the given element.\\n * @param {Element} element The element whose element children we want.\\n * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list\\n *     of just the element children of the given element.\\n */\\ngoog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;\\n\\n\\n/**\\n * Returns the first child node that is an element.\\n * @param {Node} node The node to get the first child element of.\\n * @return {Element} The first child node of `node` that is an element.\\n */\\ngoog.dom.DomHelper.prototype.getFirstElementChild =\\n    goog.dom.getFirstElementChild;\\n\\n\\n/**\\n * Returns the last child node that is an element.\\n * @param {Node} node The node to get the last child element of.\\n * @return {Element} The last child node of `node` that is an element.\\n */\\ngoog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;\\n\\n\\n/**\\n * Returns the first next sibling that is an element.\\n * @param {Node} node The node to get the next sibling element of.\\n * @return {Element} The next sibling of `node` that is an element.\\n */\\ngoog.dom.DomHelper.prototype.getNextElementSibling =\\n    goog.dom.getNextElementSibling;\\n\\n\\n/**\\n * Returns the first previous sibling that is an element.\\n * @param {Node} node The node to get the previous sibling element of.\\n * @return {Element} The first previous sibling of `node` that is\\n *     an element.\\n */\\ngoog.dom.DomHelper.prototype.getPreviousElementSibling =\\n    goog.dom.getPreviousElementSibling;\\n\\n\\n/**\\n * Returns the next node in source order from the given node.\\n * @param {Node} node The node.\\n * @return {Node} The next node in the DOM tree, or null if this was the last\\n *     node.\\n */\\ngoog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;\\n\\n\\n/**\\n * Returns the previous node in source order from the given node.\\n * @param {Node} node The node.\\n * @return {Node} The previous node in the DOM tree, or null if this was the\\n *     first node.\\n */\\ngoog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;\\n\\n\\n/**\\n * Whether the object looks like a DOM node.\\n * @param {?} obj The object being tested for node likeness.\\n * @return {boolean} Whether the object looks like a DOM node.\\n */\\ngoog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;\\n\\n\\n/**\\n * Whether the object looks like an Element.\\n * @param {?} obj The object being tested for Element likeness.\\n * @return {boolean} Whether the object looks like an Element.\\n */\\ngoog.dom.DomHelper.prototype.isElement = goog.dom.isElement;\\n\\n\\n/**\\n * Returns true if the specified value is a Window object. This includes the\\n * global window for HTML pages, and iframe windows.\\n * @param {?} obj Variable to test.\\n * @return {boolean} Whether the variable is a window.\\n */\\ngoog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;\\n\\n\\n/**\\n * Returns an element's parent, if it's an Element.\\n * @param {Element} element The DOM element.\\n * @return {Element} The parent, or null if not an Element.\\n */\\ngoog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;\\n\\n\\n/**\\n * Whether a node contains another node.\\n * @param {Node} parent The node that should contain the other node.\\n * @param {Node} descendant The node to test presence of.\\n * @return {boolean} Whether the parent node contains the descendant node.\\n */\\ngoog.dom.DomHelper.prototype.contains = goog.dom.contains;\\n\\n\\n/**\\n * Compares the document order of two nodes, returning 0 if they are the same\\n * node, a negative number if node1 is before node2, and a positive number if\\n * node2 is before node1.  Note that we compare the order the tags appear in the\\n * document so in the tree <b><i>text</i></b> the B node is considered to be\\n * before the I node.\\n *\\n * @param {Node} node1 The first node to compare.\\n * @param {Node} node2 The second node to compare.\\n * @return {number} 0 if the nodes are the same node, a negative number if node1\\n *     is before node2, and a positive number if node2 is before node1.\\n */\\ngoog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;\\n\\n\\n/**\\n * Find the deepest common ancestor of the given nodes.\\n * @param {...Node} var_args The nodes to find a common ancestor of.\\n * @return {Node} The common ancestor of the nodes, or null if there is none.\\n *     null will only be returned if two or more of the nodes are from different\\n *     documents.\\n */\\ngoog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;\\n\\n\\n/**\\n * Returns the owner document for a node.\\n * @param {Node} node The node to get the document for.\\n * @return {!Document} The document owning the node.\\n */\\ngoog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;\\n\\n\\n/**\\n * Cross browser function for getting the document element of an iframe.\\n * @param {Element} iframe Iframe element.\\n * @return {!Document} The frame content document.\\n */\\ngoog.dom.DomHelper.prototype.getFrameContentDocument =\\n    goog.dom.getFrameContentDocument;\\n\\n\\n/**\\n * Cross browser function for getting the window of a frame or iframe.\\n * @param {Element} frame Frame element.\\n * @return {Window} The window associated with the given frame.\\n */\\ngoog.dom.DomHelper.prototype.getFrameContentWindow =\\n    goog.dom.getFrameContentWindow;\\n\\n\\n/**\\n * Sets the text content of a node, with cross-browser support.\\n * @param {Node} node The node to change the text content of.\\n * @param {string|number} text The value that should replace the node's content.\\n */\\ngoog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;\\n\\n\\n/**\\n * Gets the outerHTML of a node, which islike innerHTML, except that it\\n * actually contains the HTML of the node itself.\\n * @param {Element} element The element to get the HTML of.\\n * @return {string} The outerHTML of the given element.\\n */\\ngoog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;\\n\\n\\n/**\\n * Finds the first descendant node that matches the filter function. This does\\n * a depth first search.\\n * @param {Node} root The root of the tree to search.\\n * @param {function(Node) : boolean} p The filter function.\\n * @return {Node|undefined} The found node or undefined if none is found.\\n */\\ngoog.dom.DomHelper.prototype.findNode = goog.dom.findNode;\\n\\n\\n/**\\n * Finds all the descendant nodes that matches the filter function. This does a\\n * depth first search.\\n * @param {Node} root The root of the tree to search.\\n * @param {function(Node) : boolean} p The filter function.\\n * @return {Array<Node>} The found nodes or an empty array if none are found.\\n */\\ngoog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;\\n\\n\\n/**\\n * Returns true if the element has a tab index that allows it to receive\\n * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements\\n * natively support keyboard focus, even if they have no tab index.\\n * @param {!Element} element Element to check.\\n * @return {boolean} Whether the element has a tab index that allows keyboard\\n *     focus.\\n */\\ngoog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;\\n\\n\\n/**\\n * Enables or disables keyboard focus support on the element via its tab index.\\n * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true\\n * (or elements that natively support keyboard focus, like form elements) can\\n * receive keyboard focus.  See http://go/tabindex for more info.\\n * @param {Element} element Element whose tab index is to be changed.\\n * @param {boolean} enable Whether to set or remove a tab index on the element\\n *     that supports keyboard focus.\\n */\\ngoog.dom.DomHelper.prototype.setFocusableTabIndex =\\n    goog.dom.setFocusableTabIndex;\\n\\n\\n/**\\n * Returns true if the element can be focused, i.e. it has a tab index that\\n * allows it to receive keyboard focus (tabIndex >= 0), or it is an element\\n * that natively supports keyboard focus.\\n * @param {!Element} element Element to check.\\n * @return {boolean} Whether the element allows keyboard focus.\\n */\\ngoog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;\\n\\n\\n/**\\n * Returns the text contents of the current node, without markup. New lines are\\n * stripped and whitespace is collapsed, such that each character would be\\n * visible.\\n *\\n * In browsers that support it, innerText is used.  Other browsers attempt to\\n * simulate it via node traversal.  Line breaks are canonicalized in IE.\\n *\\n * @param {Node} node The node from which we are getting content.\\n * @return {string} The text content.\\n */\\ngoog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;\\n\\n\\n/**\\n * Returns the text length of the text contained in a node, without markup. This\\n * is equivalent to the selection length if the node was selected, or the number\\n * of cursor movements to traverse the node. Images & BRs take one space.  New\\n * lines are ignored.\\n *\\n * @param {Node} node The node whose text content length is being calculated.\\n * @return {number} The length of `node`'s text content.\\n */\\ngoog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;\\n\\n\\n/**\\n * Returns the text offset of a node relative to one of its ancestors. The text\\n * length is the same as the length calculated by\\n * `goog.dom.getNodeTextLength`.\\n *\\n * @param {Node} node The node whose offset is being calculated.\\n * @param {Node=} opt_offsetParent Defaults to the node's owner document's body.\\n * @return {number} The text offset.\\n */\\ngoog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;\\n\\n\\n/**\\n * Returns the node at a given offset in a parent node.  If an object is\\n * provided for the optional third parameter, the node and the remainder of the\\n * offset will stored as properties of this object.\\n * @param {Node} parent The parent node.\\n * @param {number} offset The offset into the parent node.\\n * @param {Object=} opt_result Object to be used to store the return value. The\\n *     return value will be stored in the form {node: Node, remainder: number}\\n *     if this object is provided.\\n * @return {Node} The node at the given offset.\\n */\\ngoog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;\\n\\n\\n/**\\n * Returns true if the object is a `NodeList`.  To qualify as a NodeList,\\n * the object must have a numeric length property and an item function (which\\n * has type 'string' on IE for some reason).\\n * @param {Object} val Object to test.\\n * @return {boolean} Whether the object is a NodeList.\\n */\\ngoog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;\\n\\n\\n/**\\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\\n * tag name and/or class name. If the passed element matches the specified\\n * criteria, the element itself is returned.\\n * @param {Node} element The DOM node to start with.\\n * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or\\n *     null/undefined to match only based on class name).\\n * @param {?string=} opt_class The class name to match (or null/undefined to\\n *     match only based on tag name).\\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\\n *     dom.\\n * @return {?R} The first ancestor that matches the passed criteria, or\\n *     null if no match is found. The return type is {?Element} if opt_tag is\\n *     not a member of goog.dom.TagName or a more specific type if it is (e.g.\\n *     {?HTMLAnchorElement} for goog.dom.TagName.A).\\n * @template T\\n * @template R := cond(isUnknown(T), 'Element', T) =:\\n */\\ngoog.dom.DomHelper.prototype.getAncestorByTagNameAndClass =\\n    goog.dom.getAncestorByTagNameAndClass;\\n\\n\\n/**\\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\\n * class name. If the passed element matches the specified criteria, the\\n * element itself is returned.\\n * @param {Node} element The DOM node to start with.\\n * @param {string} class The class name to match.\\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\\n *     dom.\\n * @return {Element} The first ancestor that matches the passed criteria, or\\n *     null if none match.\\n */\\ngoog.dom.DomHelper.prototype.getAncestorByClass = goog.dom.getAncestorByClass;\\n\\n\\n/**\\n * Walks up the DOM hierarchy returning the first ancestor that passes the\\n * matcher function.\\n * @param {Node} element The DOM node to start with.\\n * @param {function(Node) : boolean} matcher A function that returns true if the\\n *     passed node matches the desired criteria.\\n * @param {boolean=} opt_includeNode If true, the node itself is included in\\n *     the search (the first call to the matcher will pass startElement as\\n *     the node to test).\\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\\n *     dom.\\n * @return {Node} DOM node that matched the matcher, or null if there was\\n *     no match.\\n */\\ngoog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;\\n\\n\\n/**\\n * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a\\n * type information.\\n * @param {!HTMLCanvasElement} canvas\\n * @return {!CanvasRenderingContext2D}\\n */\\ngoog.dom.DomHelper.prototype.getCanvasContext2D = goog.dom.getCanvasContext2D;\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"dom\",\"ASSUME_QUIRKS_MODE\",\"define\",\"ASSUME_STANDARDS_MODE\",\"COMPAT_MODE_KNOWN_\",\"getDomHelper\",\"goog.dom.getDomHelper\",\"opt_element\",\"DomHelper\",\"getOwnerDocument\",\"defaultDomHelper_\",\"getDocument\",\"goog.dom.getDocument\",\"document\",\"getElement\",\"goog.dom.getElement\",\"element\",\"getElementHelper_\",\"goog.dom.getElementHelper_\",\"doc\",\"getElementById\",\"getRequiredElement\",\"goog.dom.getRequiredElement\",\"id\",\"getRequiredElementHelper_\",\"goog.dom.getRequiredElementHelper_\",\"asserts\",\"assertString\",\"assertElement\",\"$\",\"getElementsByTagName\",\"goog.dom.getElementsByTagName\",\"tagName\",\"opt_parent\",\"parent\",\"String\",\"getElementsByTagNameAndClass\",\"goog.dom.getElementsByTagNameAndClass\",\"opt_tag\",\"opt_class\",\"opt_el\",\"getElementsByTagNameAndClass_\",\"getElementByTagNameAndClass\",\"goog.dom.getElementByTagNameAndClass\",\"getElementByTagNameAndClass_\",\"getElementsByClass\",\"goog.dom.getElementsByClass\",\"className\",\"canUseQuerySelector_\",\"querySelectorAll\",\"getElementByClass\",\"goog.dom.getElementByClass\",\"retVal\",\"getElementsByClassName\",\"getRequiredElementByClass\",\"goog.dom.getRequiredElementByClass\",\"opt_root\",\"retValue\",\"assert\",\"goog.dom.canUseQuerySelector_\",\"querySelector\",\"goog.dom.getElementsByTagNameAndClass_\",\"toUpperCase\",\"query\",\"els\",\"arrayLike\",\"len\",\"i\",\"el\",\"nodeName\",\"length\",\"split\",\"array\",\"contains\",\"goog.dom.getElementByTagNameAndClass_\",\"tag\",\"elements\",\"$$\",\"setProperties\",\"goog.dom.setProperties\",\"properties\",\"object\",\"forEach\",\"val\",\"key\",\"implementsGoogStringTypedString\",\"getTypedStringValue\",\"style\",\"cssText\",\"htmlFor\",\"DIRECT_ATTRIBUTE_MAP_\",\"hasOwnProperty\",\"setAttribute\",\"string\",\"startsWith\",\"getViewportSize\",\"goog.dom.getViewportSize\",\"opt_window\",\"getViewportSize_\",\"window\",\"goog.dom.getViewportSize_\",\"win\",\"isCss1CompatMode_\",\"documentElement\",\"body\",\"math\",\"Size\",\"clientWidth\",\"clientHeight\",\"getDocumentHeight\",\"goog.dom.getDocumentHeight\",\"getDocumentHeight_\",\"getDocumentHeightForWindow\",\"goog.dom.getDocumentHeightForWindow\",\"goog.dom.getDocumentHeight_\",\"height\",\"docEl\",\"vh\",\"scrollHeight\",\"offsetHeight\",\"sh\",\"oh\",\"getPageScroll\",\"goog.dom.getPageScroll\",\"global\",\"getDocumentScroll\",\"goog.dom.getDocumentScroll\",\"getDocumentScroll_\",\"goog.dom.getDocumentScroll_\",\"getDocumentScrollElement_\",\"getWindow_\",\"userAgent\",\"IE\",\"isVersionOrHigher\",\"pageYOffset\",\"scrollTop\",\"Coordinate\",\"scrollLeft\",\"pageXOffset\",\"getDocumentScrollElement\",\"goog.dom.getDocumentScrollElement\",\"goog.dom.getDocumentScrollElement_\",\"scrollingElement\",\"WEBKIT\",\"getWindow\",\"goog.dom.getWindow\",\"opt_doc\",\"goog.dom.getWindow_\",\"parentWindow\",\"defaultView\",\"createDom\",\"goog.dom.createDom\",\"opt_attributes\",\"var_args\",\"createDom_\",\"arguments\",\"goog.dom.createDom_\",\"args\",\"attributes\",\"BrowserFeature\",\"CAN_ADD_NAME_OR_TYPE_ATTRIBUTES\",\"name\",\"type\",\"tagNameArr\",\"push\",\"htmlEscape\",\"clone\",\"extend\",\"join\",\"createElement_\",\"Array\",\"isArray\",\"append_\",\"goog.dom.append_\",\"startIndex\",\"childHandler\",\"child\",\"appendChild\",\"createTextNode\",\"arg\",\"isArrayLike\",\"isNodeLike\",\"isNodeList\",\"toArray\",\"$dom\",\"createElement\",\"goog.dom.createElement\",\"goog.dom.createElement_\",\"contentType\",\"toLowerCase\",\"goog.dom.createTextNode\",\"content\",\"createTable\",\"goog.dom.createTable\",\"rows\",\"columns\",\"opt_fillWithNbsp\",\"createTable_\",\"goog.dom.createTable_\",\"fillWithNbsp\",\"table\",\"TagName\",\"TABLE\",\"tbody\",\"TBODY\",\"tr\",\"TR\",\"j\",\"td\",\"TD\",\"setTextContent\",\"Unicode\",\"NBSP\",\"constHtmlToNode\",\"goog.dom.constHtmlToNode\",\"stringArray\",\"map\",\"Const\",\"unwrap\",\"safeHtml\",\"html\",\"uncheckedconversions\",\"safeHtmlFromStringKnownToSatisfyTypeContract\",\"from\",\"safeHtmlToNode\",\"goog.dom.safeHtmlToNode\",\"safeHtmlToNode_\",\"goog.dom.safeHtmlToNode_\",\"tempDiv\",\"DIV\",\"INNER_HTML_NEEDS_SCOPED_ELEMENT\",\"safe\",\"setInnerHtml\",\"SafeHtml\",\"concat\",\"BR\",\"removeChild\",\"firstChild\",\"childrenToNode_\",\"goog.dom.childrenToNode_\",\"childNodes\",\"fragment\",\"createDocumentFragment\",\"isCss1CompatMode\",\"goog.dom.isCss1CompatMode\",\"goog.dom.isCss1CompatMode_\",\"compatMode\",\"canHaveChildren\",\"goog.dom.canHaveChildren\",\"node\",\"nodeType\",\"NodeType\",\"ELEMENT\",\"APPLET\",\"AREA\",\"BASE\",\"COL\",\"COMMAND\",\"EMBED\",\"FRAME\",\"HR\",\"IMG\",\"INPUT\",\"IFRAME\",\"ISINDEX\",\"KEYGEN\",\"LINK\",\"NOFRAMES\",\"NOSCRIPT\",\"META\",\"OBJECT\",\"PARAM\",\"SCRIPT\",\"SOURCE\",\"STYLE\",\"TRACK\",\"WBR\",\"goog.dom.appendChild\",\"append\",\"goog.dom.append\",\"removeChildren\",\"goog.dom.removeChildren\",\"insertSiblingBefore\",\"goog.dom.insertSiblingBefore\",\"newNode\",\"refNode\",\"parentNode\",\"insertBefore\",\"insertSiblingAfter\",\"goog.dom.insertSiblingAfter\",\"nextSibling\",\"insertChildAt\",\"goog.dom.insertChildAt\",\"index\",\"removeNode\",\"goog.dom.removeNode\",\"replaceNode\",\"goog.dom.replaceNode\",\"oldNode\",\"replaceChild\",\"copyContents\",\"goog.dom.copyContents\",\"target\",\"source\",\"cloneNode\",\"flattenElement\",\"goog.dom.flattenElement\",\"DOCUMENT_FRAGMENT\",\"getChildren\",\"goog.dom.getChildren\",\"CAN_USE_CHILDREN_ATTRIBUTE\",\"children\",\"undefined\",\"filter\",\"getFirstElementChild\",\"goog.dom.getFirstElementChild\",\"firstElementChild\",\"getNextElementNode_\",\"getLastElementChild\",\"goog.dom.getLastElementChild\",\"lastElementChild\",\"lastChild\",\"getNextElementSibling\",\"goog.dom.getNextElementSibling\",\"nextElementSibling\",\"getPreviousElementSibling\",\"goog.dom.getPreviousElementSibling\",\"previousElementSibling\",\"previousSibling\",\"goog.dom.getNextElementNode_\",\"forward\",\"getNextNode\",\"goog.dom.getNextNode\",\"getPreviousNode\",\"goog.dom.getPreviousNode\",\"goog.dom.isNodeLike\",\"obj\",\"isObject\",\"isElement\",\"goog.dom.isElement\",\"isWindow\",\"goog.dom.isWindow\",\"getParentElement\",\"goog.dom.getParentElement\",\"CAN_USE_PARENT_ELEMENT_PROPERTY\",\"isIe9\",\"parentElement\",\"goog.dom.contains\",\"descendant\",\"compareDocumentPosition\",\"Boolean\",\"compareNodeOrder\",\"goog.dom.compareNodeOrder\",\"node1\",\"node2\",\"isDocumentModeOrHigher\",\"DOCUMENT\",\"isElement1\",\"isElement2\",\"sourceIndex\",\"parent1\",\"parent2\",\"compareSiblingOrder_\",\"compareParentsDescendantNodeIe_\",\"range1\",\"range2\",\"createRange\",\"selectNode\",\"collapse\",\"compareBoundaryPoints\",\"START_TO_END\",\"goog.dom.compareParentsDescendantNodeIe_\",\"textNode\",\"sibling\",\"goog.dom.compareSiblingOrder_\",\"s\",\"findCommonAncestor\",\"goog.dom.findCommonAncestor\",\"count\",\"paths\",\"minLength\",\"Infinity\",\"ancestors\",\"unshift\",\"Math\",\"min\",\"output\",\"first\",\"isInDocument\",\"goog.dom.isInDocument\",\"ownerDocument\",\"goog.dom.getOwnerDocument\",\"getFrameContentDocument\",\"goog.dom.getFrameContentDocument\",\"frame\",\"contentDocument\",\"contentWindow\",\"getFrameContentWindow\",\"goog.dom.getFrameContentWindow\",\"e\",\"goog.dom.setTextContent\",\"text\",\"textContent\",\"TEXT\",\"data\",\"getOuterHtml\",\"goog.dom.getOuterHtml\",\"outerHTML\",\"div\",\"innerHTML\",\"findNode\",\"goog.dom.findNode\",\"root\",\"p\",\"rv\",\"found\",\"findNodes_\",\"findNodes\",\"goog.dom.findNodes\",\"goog.dom.findNodes_\",\"findOne\",\"findElement\",\"goog.dom.findElement\",\"pred\",\"stack\",\"getChildrenReverse_\",\"next\",\"pop\",\"c\",\"findElements\",\"goog.dom.findElements\",\"result\",\"goog.dom.getChildrenReverse_\",\"TAGS_TO_IGNORE_\",\"PREDEFINED_TAG_VALUES_\",\"isFocusableTabIndex\",\"goog.dom.isFocusableTabIndex\",\"hasSpecifiedTabIndex_\",\"isTabIndexFocusable_\",\"setFocusableTabIndex\",\"goog.dom.setFocusableTabIndex\",\"enable\",\"tabIndex\",\"removeAttribute\",\"isFocusable\",\"goog.dom.isFocusable\",\"focusable\",\"nativelySupportsFocus_\",\"disabled\",\"hasNonZeroBoundingRect_\",\"goog.dom.hasSpecifiedTabIndex_\",\"attrNode\",\"getAttributeNode\",\"specified\",\"hasAttribute\",\"goog.dom.isTabIndexFocusable_\",\"goog.dom.nativelySupportsFocus_\",\"A\",\"TEXTAREA\",\"SELECT\",\"BUTTON\",\"goog.dom.hasNonZeroBoundingRect_\",\"rect\",\"offsetWidth\",\"getBoundingClientRect\",\"width\",\"getTextContent\",\"goog.dom.getTextContent\",\"CAN_USE_INNER_TEXT\",\"canonicalizeNewlines\",\"innerText\",\"buf\",\"getTextContent_\",\"replace\",\"getRawTextContent\",\"goog.dom.getRawTextContent\",\"goog.dom.getTextContent_\",\"normalizeWhitespace\",\"nodeValue\",\"getNodeTextLength\",\"goog.dom.getNodeTextLength\",\"getNodeTextOffset\",\"goog.dom.getNodeTextOffset\",\"opt_offsetParent\",\"cur\",\"trimLeft\",\"getNodeAtOffset\",\"goog.dom.getNodeAtOffset\",\"offset\",\"opt_result\",\"pos\",\"remainder\",\"goog.dom.isNodeList\",\"item\",\"getAncestorByTagNameAndClass\",\"goog.dom.getAncestorByTagNameAndClass\",\"opt_maxSearchSteps\",\"getAncestor\",\"getAncestorByClass\",\"goog.dom.getAncestorByClass\",\"goog.dom.getAncestor\",\"matcher\",\"opt_includeNode\",\"steps\",\"getActiveElement\",\"goog.dom.getActiveElement\",\"activeElement\",\"getPixelRatio\",\"goog.dom.getPixelRatio\",\"devicePixelRatio\",\"matchMedia\",\"matchesPixelRatio_\",\"goog.dom.matchesPixelRatio_\",\"pixelRatio\",\"dpiPerDppx\",\"matches\",\"getCanvasContext2D\",\"goog.dom.getCanvasContext2D\",\"canvas\",\"getContext\",\"goog.dom.DomHelper\",\"opt_document\",\"document_\",\"prototype\",\"setDocument\",\"goog.dom.DomHelper.prototype.setDocument\",\"goog.dom.DomHelper.prototype.getDocument\",\"goog.dom.DomHelper.prototype.getElement\",\"goog.dom.DomHelper.prototype.getRequiredElement\",\"goog.dom.DomHelper.prototype.getElementsByTagName\",\"goog.dom.DomHelper.prototype.getElementsByTagNameAndClass\",\"goog.dom.DomHelper.prototype.getElementByTagNameAndClass\",\"goog.dom.DomHelper.prototype.getElementsByClass\",\"goog.dom.DomHelper.prototype.getElementByClass\",\"goog.dom.DomHelper.prototype.getRequiredElementByClass\",\"goog.dom.DomHelper.prototype.getViewportSize\",\"goog.dom.DomHelper.prototype.getDocumentHeight\",\"Appendable\",\"goog.dom.DomHelper.prototype.createDom\",\"goog.dom.DomHelper.prototype.createElement\",\"goog.dom.DomHelper.prototype.createTextNode\",\"goog.dom.DomHelper.prototype.createTable\",\"goog.dom.DomHelper.prototype.safeHtmlToNode\",\"goog.dom.DomHelper.prototype.isCss1CompatMode\",\"goog.dom.DomHelper.prototype.getWindow\",\"goog.dom.DomHelper.prototype.getDocumentScrollElement\",\"goog.dom.DomHelper.prototype.getDocumentScroll\",\"goog.dom.DomHelper.prototype.getActiveElement\"]\n}\n"]