["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/i18n/bidi.js"],"~:js","goog.provide(\"goog.i18n.bidi\");\ngoog.provide(\"goog.i18n.bidi.Dir\");\ngoog.provide(\"goog.i18n.bidi.DirectionalString\");\ngoog.provide(\"goog.i18n.bidi.Format\");\ngoog.i18n.bidi.FORCE_RTL = goog.define(\"goog.i18n.bidi.FORCE_RTL\", false);\ngoog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || (goog.LOCALE.substring(0, 2).toLowerCase() == \"ar\" || goog.LOCALE.substring(0, 2).toLowerCase() == \"fa\" || goog.LOCALE.substring(0, 2).toLowerCase() == \"he\" || goog.LOCALE.substring(0, 2).toLowerCase() == \"iw\" || goog.LOCALE.substring(0, 2).toLowerCase() == \"ps\" || goog.LOCALE.substring(0, 2).toLowerCase() == \"sd\" || goog.LOCALE.substring(0, 2).toLowerCase() == \"ug\" || goog.LOCALE.substring(0, 2).toLowerCase() == \"ur\" || goog.LOCALE.substring(0, \n2).toLowerCase() == \"yi\") && (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == \"-\" || goog.LOCALE.substring(2, 3) == \"_\") || goog.LOCALE.length >= 3 && goog.LOCALE.substring(0, 3).toLowerCase() == \"ckb\" && (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == \"-\" || goog.LOCALE.substring(3, 4) == \"_\") || goog.LOCALE.length >= 7 && ((goog.LOCALE.substring(2, 3) == \"-\" || goog.LOCALE.substring(2, 3) == \"_\") && (goog.LOCALE.substring(3, 7).toLowerCase() == \"adlm\" || goog.LOCALE.substring(3, \n7).toLowerCase() == \"arab\" || goog.LOCALE.substring(3, 7).toLowerCase() == \"hebr\" || goog.LOCALE.substring(3, 7).toLowerCase() == \"nkoo\" || goog.LOCALE.substring(3, 7).toLowerCase() == \"rohg\" || goog.LOCALE.substring(3, 7).toLowerCase() == \"thaa\")) || goog.LOCALE.length >= 8 && ((goog.LOCALE.substring(3, 4) == \"-\" || goog.LOCALE.substring(3, 4) == \"_\") && (goog.LOCALE.substring(4, 8).toLowerCase() == \"adlm\" || goog.LOCALE.substring(4, 8).toLowerCase() == \"arab\" || goog.LOCALE.substring(4, 8).toLowerCase() == \n\"hebr\" || goog.LOCALE.substring(4, 8).toLowerCase() == \"nkoo\" || goog.LOCALE.substring(4, 8).toLowerCase() == \"rohg\" || goog.LOCALE.substring(4, 8).toLowerCase() == \"thaa\"));\ngoog.i18n.bidi.Format = {LRE:\"‪\", RLE:\"‫\", PDF:\"‬\", LRM:\"‎\", RLM:\"‏\"};\ngoog.i18n.bidi.Dir = {LTR:1, RTL:-1, NEUTRAL:0};\ngoog.i18n.bidi.RIGHT = \"right\";\ngoog.i18n.bidi.LEFT = \"left\";\ngoog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;\ngoog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;\ngoog.i18n.bidi.toDir = function(givenDir, opt_noNeutral) {\n  if (typeof givenDir == \"number\") {\n    return givenDir > 0 ? goog.i18n.bidi.Dir.LTR : givenDir < 0 ? goog.i18n.bidi.Dir.RTL : opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;\n  } else {\n    if (givenDir == null) {\n      return null;\n    } else {\n      return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;\n    }\n  }\n};\ngoog.i18n.bidi.ltrChars_ = \"A-Za-zÀ-ÖØ-öø-ʸ̀-֐ऀ-῿\" + \"‎Ⰰ-\\ud801\\ud804-\\ud839\\ud83c-\\udbff\" + \"豈-﬜︀-﹯﻽-￿\";\ngoog.i18n.bidi.rtlChars_ = \"֑-ۯۺ-ࣿ‏\\ud802-\\ud803\\ud83a-\\ud83b\" + \"יִ-﷿ﹰ-ﻼ\";\ngoog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;\ngoog.i18n.bidi.stripHtmlIfNeeded_ = function(str, opt_isStripNeeded) {\n  return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, \"\") : str;\n};\ngoog.i18n.bidi.rtlCharReg_ = new RegExp(\"[\" + goog.i18n.bidi.rtlChars_ + \"]\");\ngoog.i18n.bidi.ltrCharReg_ = new RegExp(\"[\" + goog.i18n.bidi.ltrChars_ + \"]\");\ngoog.i18n.bidi.hasAnyRtl = function(str, opt_isHtml) {\n  return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\ngoog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;\ngoog.i18n.bidi.hasAnyLtr = function(str, opt_isHtml) {\n  return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\ngoog.i18n.bidi.ltrRe_ = new RegExp(\"^[\" + goog.i18n.bidi.ltrChars_ + \"]\");\ngoog.i18n.bidi.rtlRe_ = new RegExp(\"^[\" + goog.i18n.bidi.rtlChars_ + \"]\");\ngoog.i18n.bidi.isRtlChar = function(str) {\n  return goog.i18n.bidi.rtlRe_.test(str);\n};\ngoog.i18n.bidi.isLtrChar = function(str) {\n  return goog.i18n.bidi.ltrRe_.test(str);\n};\ngoog.i18n.bidi.isNeutralChar = function(str) {\n  return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);\n};\ngoog.i18n.bidi.ltrDirCheckRe_ = new RegExp(\"^[^\" + goog.i18n.bidi.rtlChars_ + \"]*[\" + goog.i18n.bidi.ltrChars_ + \"]\");\ngoog.i18n.bidi.rtlDirCheckRe_ = new RegExp(\"^[^\" + goog.i18n.bidi.ltrChars_ + \"]*[\" + goog.i18n.bidi.rtlChars_ + \"]\");\ngoog.i18n.bidi.startsWithRtl = function(str, opt_isHtml) {\n  return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\ngoog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;\ngoog.i18n.bidi.startsWithLtr = function(str, opt_isHtml) {\n  return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\ngoog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;\ngoog.i18n.bidi.isRequiredLtrRe_ = /^http:\\/\\/.*/;\ngoog.i18n.bidi.isNeutralText = function(str, opt_isHtml) {\n  str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);\n  return goog.i18n.bidi.isRequiredLtrRe_.test(str) || !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);\n};\ngoog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp(\"[\" + goog.i18n.bidi.ltrChars_ + \"]\" + \"[^\" + goog.i18n.bidi.rtlChars_ + \"]*$\");\ngoog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp(\"[\" + goog.i18n.bidi.rtlChars_ + \"]\" + \"[^\" + goog.i18n.bidi.ltrChars_ + \"]*$\");\ngoog.i18n.bidi.endsWithLtr = function(str, opt_isHtml) {\n  return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\ngoog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;\ngoog.i18n.bidi.endsWithRtl = function(str, opt_isHtml) {\n  return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\ngoog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;\ngoog.i18n.bidi.rtlLocalesRe_ = new RegExp(\"^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|\" + \".*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))\" + \"(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)\", \"i\");\ngoog.i18n.bidi.isRtlLanguage = function(lang) {\n  return goog.i18n.bidi.rtlLocalesRe_.test(lang);\n};\ngoog.i18n.bidi.bracketGuardTextRe_ = /(\\(.*?\\)+)|(\\[.*?\\]+)|(\\{.*?\\}+)|(<.*?>+)/g;\ngoog.i18n.bidi.guardBracketInText = function(s, opt_isRtlContext) {\n  const useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) : opt_isRtlContext;\n  const mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;\n  return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + \"$\\x26\" + mark);\n};\ngoog.i18n.bidi.enforceRtlInHtml = function(html) {\n  if (html.charAt(0) == \"\\x3c\") {\n    return html.replace(/<\\w+/, \"$\\x26 dir\\x3drtl\");\n  }\n  return \"\\n\\x3cspan dir\\x3drtl\\x3e\" + html + \"\\x3c/span\\x3e\";\n};\ngoog.i18n.bidi.enforceRtlInText = function(text) {\n  return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;\n};\ngoog.i18n.bidi.enforceLtrInHtml = function(html) {\n  if (html.charAt(0) == \"\\x3c\") {\n    return html.replace(/<\\w+/, \"$\\x26 dir\\x3dltr\");\n  }\n  return \"\\n\\x3cspan dir\\x3dltr\\x3e\" + html + \"\\x3c/span\\x3e\";\n};\ngoog.i18n.bidi.enforceLtrInText = function(text) {\n  return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;\n};\ngoog.i18n.bidi.dimensionsRe_ = /:\\s*([.\\d][.\\w]*)\\s+([.\\d][.\\w]*)\\s+([.\\d][.\\w]*)\\s+([.\\d][.\\w]*)/g;\ngoog.i18n.bidi.leftRe_ = /left/gi;\ngoog.i18n.bidi.rightRe_ = /right/gi;\ngoog.i18n.bidi.tempRe_ = /%%%%/g;\ngoog.i18n.bidi.mirrorCSS = function(cssStr) {\n  return cssStr.replace(goog.i18n.bidi.dimensionsRe_, \":$1 $4 $3 $2\").replace(goog.i18n.bidi.leftRe_, \"%%%%\").replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);\n};\ngoog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\\u0591-\\u05f2])\"/g;\ngoog.i18n.bidi.singleQuoteSubstituteRe_ = /([\\u0591-\\u05f2])'/g;\ngoog.i18n.bidi.normalizeHebrewQuote = function(str) {\n  return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, \"$1״\").replace(goog.i18n.bidi.singleQuoteSubstituteRe_, \"$1׳\");\n};\ngoog.i18n.bidi.wordSeparatorRe_ = /\\s+/;\ngoog.i18n.bidi.hasNumeralsRe_ = /[\\d\\u06f0-\\u06f9]/;\ngoog.i18n.bidi.rtlDetectionThreshold_ = 0.40;\ngoog.i18n.bidi.estimateDirection = function(str, opt_isHtml) {\n  let rtlCount = 0;\n  let totalCount = 0;\n  let hasWeaklyLtr = false;\n  const tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml).split(goog.i18n.bidi.wordSeparatorRe_);\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (goog.i18n.bidi.startsWithRtl(token)) {\n      rtlCount++;\n      totalCount++;\n    } else {\n      if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {\n        hasWeaklyLtr = true;\n      } else {\n        if (goog.i18n.bidi.hasAnyLtr(token)) {\n          totalCount++;\n        } else {\n          if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {\n            hasWeaklyLtr = true;\n          }\n        }\n      }\n    }\n  }\n  return totalCount == 0 ? hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;\n};\ngoog.i18n.bidi.detectRtlDirectionality = function(str, opt_isHtml) {\n  return goog.i18n.bidi.estimateDirection(str, opt_isHtml) == goog.i18n.bidi.Dir.RTL;\n};\ngoog.i18n.bidi.setElementDirAndAlign = function(element, dir) {\n  if (element) {\n    const htmlElement = element;\n    dir = goog.i18n.bidi.toDir(dir);\n    if (dir) {\n      htmlElement.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;\n      htmlElement.dir = dir == goog.i18n.bidi.Dir.RTL ? \"rtl\" : \"ltr\";\n    }\n  }\n};\ngoog.i18n.bidi.setElementDirByTextDirectionality = function(element, text) {\n  const htmlElement = element;\n  switch(goog.i18n.bidi.estimateDirection(text)) {\n    case goog.i18n.bidi.Dir.LTR:\n      if (htmlElement.dir !== \"ltr\") {\n        htmlElement.dir = \"ltr\";\n      }\n      break;\n    case goog.i18n.bidi.Dir.RTL:\n      if (htmlElement.dir !== \"rtl\") {\n        htmlElement.dir = \"rtl\";\n      }\n      break;\n    default:\n      htmlElement.removeAttribute(\"dir\");\n  }\n};\ngoog.i18n.bidi.DirectionalString = function() {\n};\ngoog.i18n.bidi.DirectionalString.prototype.implementsGoogI18nBidiDirectionalString;\ngoog.i18n.bidi.DirectionalString.prototype.getDirection;\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility functions for supporting Bidi issues.\n */\n\n\n/**\n * Namespace for bidi supporting functions.\n */\ngoog.provide('goog.i18n.bidi');\ngoog.provide('goog.i18n.bidi.Dir');\ngoog.provide('goog.i18n.bidi.DirectionalString');\ngoog.provide('goog.i18n.bidi.Format');\n\n\n/**\n * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant\n * to say that the current locale is a RTL locale.  This should only be used\n * if you want to override the default behavior for deciding whether the\n * current locale is RTL or not.\n *\n * {@see goog.i18n.bidi.IS_RTL}\n */\ngoog.i18n.bidi.FORCE_RTL = goog.define('goog.i18n.bidi.FORCE_RTL', false);\n\n\n/**\n * Constant that defines whether or not the current locale is a RTL locale.\n * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default\n * to check that {@link goog.LOCALE} is one of a few major RTL locales.\n *\n * <p>This is designed to be a maximally efficient compile-time constant. For\n * example, for the default goog.LOCALE, compiling\n * \"if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}\" should produce no code. It\n * is this design consideration that limits the implementation to only\n * supporting a few major RTL locales, as opposed to the broader repertoire of\n * something like goog.i18n.bidi.isRtlLanguage.\n *\n * <p>Since this constant refers to the directionality of the locale, it is up\n * to the caller to determine if this constant should also be used for the\n * direction of the UI.\n *\n * {@see goog.LOCALE}\n *\n * @type {boolean}\n *\n * TODO(user): write a test that checks that this is a compile-time constant.\n */\n// LINT.IfChange\ngoog.i18n.bidi.IS_RTL =\n    goog.i18n.bidi.FORCE_RTL ||\n    ((goog.LOCALE.substring(0, 2).toLowerCase() == 'ar' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'fa' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'he' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'iw' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'ps' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'sd' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'ug' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'ur' ||\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'yi') &&\n     (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == '-' ||\n      goog.LOCALE.substring(2, 3) == '_')) ||\n    (  // Specific to CKB (Central Kurdish)\n        goog.LOCALE.length >= 3 &&\n        goog.LOCALE.substring(0, 3).toLowerCase() == 'ckb' &&\n        (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == '-' ||\n         goog.LOCALE.substring(3, 4) == '_')) ||\n    (  // 2 letter language codes with RTL scripts\n        goog.LOCALE.length >= 7 &&\n        ((goog.LOCALE.substring(2, 3) == '-' ||\n          goog.LOCALE.substring(2, 3) == '_') &&\n         (goog.LOCALE.substring(3, 7).toLowerCase() == 'adlm' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'arab' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'hebr' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'nkoo' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'rohg' ||\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'thaa'))) ||\n    (  // 3 letter languages codes with RTL scripts\n        goog.LOCALE.length >= 8 &&\n        ((goog.LOCALE.substring(3, 4) == '-' ||\n          goog.LOCALE.substring(3, 4) == '_') &&\n         (goog.LOCALE.substring(4, 8).toLowerCase() == 'adlm' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'arab' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'hebr' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'nkoo' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'rohg' ||\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'thaa')));\n//    closure/RtlLocalesTest.java)\n\n// TODO(user): Add additional scripts and languages that are RTL,\n// e.g., mende, samaritan, etc.\n\n\n/**\n * Unicode formatting characters and directionality string constants.\n * @enum {string}\n */\ngoog.i18n.bidi.Format = {\n  /** Unicode \"Left-To-Right Embedding\" (LRE) character. */\n  LRE: '\\u202A',\n  /** Unicode \"Right-To-Left Embedding\" (RLE) character. */\n  RLE: '\\u202B',\n  /** Unicode \"Pop Directional Formatting\" (PDF) character. */\n  PDF: '\\u202C',\n  /** Unicode \"Left-To-Right Mark\" (LRM) character. */\n  LRM: '\\u200E',\n  /** Unicode \"Right-To-Left Mark\" (RLM) character. */\n  RLM: '\\u200F'\n};\n\n\n/**\n * Directionality enum.\n * @enum {number}\n */\ngoog.i18n.bidi.Dir = {\n  /**\n   * Left-to-right.\n   */\n  LTR: 1,\n\n  /**\n   * Right-to-left.\n   */\n  RTL: -1,\n\n  /**\n   * Neither left-to-right nor right-to-left.\n   */\n  NEUTRAL: 0\n};\n\n\n/**\n * 'right' string constant.\n * @type {string}\n */\ngoog.i18n.bidi.RIGHT = 'right';\n\n\n/**\n * 'left' string constant.\n * @type {string}\n */\ngoog.i18n.bidi.LEFT = 'left';\n\n\n/**\n * 'left' if locale is RTL, 'right' if not.\n * @type {string}\n */\ngoog.i18n.bidi.I18N_RIGHT =\n    goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;\n\n\n/**\n * 'right' if locale is RTL, 'left' if not.\n * @type {string}\n */\ngoog.i18n.bidi.I18N_LEFT =\n    goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;\n\n\n/**\n * Convert a directionality given in various formats to a goog.i18n.bidi.Dir\n * constant. Useful for interaction with different standards of directionality\n * representation.\n *\n * @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given\n *     in one of the following formats:\n *     1. A goog.i18n.bidi.Dir constant.\n *     2. A number (positive = LTR, negative = RTL, 0 = neutral).\n *     3. A boolean (true = RTL, false = LTR).\n *     4. A null for unknown directionality.\n * @param {boolean=} opt_noNeutral Whether a givenDir of zero or\n *     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in\n *     order to preserve legacy behavior.\n * @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the\n *     given directionality. If given null, returns null (i.e. unknown).\n */\ngoog.i18n.bidi.toDir = function(givenDir, opt_noNeutral) {\n  'use strict';\n  if (typeof givenDir == 'number') {\n    // This includes the non-null goog.i18n.bidi.Dir case.\n    return givenDir > 0 ?\n        goog.i18n.bidi.Dir.LTR :\n        givenDir < 0 ? goog.i18n.bidi.Dir.RTL :\n                       opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;\n  } else if (givenDir == null) {\n    return null;\n  } else {\n    // Must be typeof givenDir == 'boolean'.\n    return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;\n  }\n};\n\n\n/**\n * A practical pattern to identify strong LTR character in the BMP.\n * This pattern is not theoretically correct according to the Unicode\n * standard. It is simplified for performance and small code size.\n * It also partially supports LTR scripts beyond U+FFFF by including\n * UTF-16 high surrogate values corresponding to mostly L-class code\n * point ranges.\n * However, low surrogate values and private-use regions are not included\n * in this RegEx.\n * @type {string}\n * @private\n */\ngoog.i18n.bidi.ltrChars_ =\n    'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0900-\\u1FFF' +\n    '\\u200E\\u2C00-\\uD801\\uD804-\\uD839\\uD83C-\\uDBFF' +\n    '\\uF900-\\uFB1C\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n/**\n * A practical pattern to identify strong RTL character. This pattern is not\n * theoretically correct according to the Unicode standard. It is simplified\n * for performance and small code size.\n * It also partially supports RTL scripts beyond U+FFFF by including\n * UTF-16 high surrogate values corresponding to mostly R- or AL-class\n * code point ranges.\n * However, low surrogate values and private-use regions are not included\n * in this RegEx.\n * @type {string}\n * @private\n */\ngoog.i18n.bidi.rtlChars_ =\n    '\\u0591-\\u06EF\\u06FA-\\u08FF\\u200F\\uD802-\\uD803\\uD83A-\\uD83B' +\n    '\\uFB1D-\\uFDFF\\uFE70-\\uFEFC';\n\n/**\n * Simplified regular expression for an HTML tag (opening or closing) or an HTML\n * escape. We might want to skip over such expressions when estimating the text\n * directionality.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;\n\n\n/**\n * Returns the input text with spaces instead of HTML tags or HTML escapes, if\n * opt_isStripNeeded is true. Else returns the input as is.\n * Useful for text directionality estimation.\n * Note: the function should not be used in other contexts; it is not 100%\n * correct, but rather a good-enough implementation for directionality\n * estimation purposes.\n * @param {string} str The given string.\n * @param {boolean=} opt_isStripNeeded Whether to perform the stripping.\n *     Default: false (to retain consistency with calling functions).\n * @return {string} The given string cleaned of HTML tags / escapes.\n * @private\n */\ngoog.i18n.bidi.stripHtmlIfNeeded_ = function(str, opt_isStripNeeded) {\n  'use strict';\n  return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, '') : str;\n};\n\n\n/**\n * Regular expression to check for RTL characters, BMP and high surrogate.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlCharReg_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + ']');\n\n\n/**\n * Regular expression to check for LTR characters.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.ltrCharReg_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + ']');\n\n\n/**\n * Test whether the given string has any RTL characters in it.\n * @param {string} str The given string that need to be tested.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether the string contains RTL characters.\n */\ngoog.i18n.bidi.hasAnyRtl = function(str, opt_isHtml) {\n  'use strict';\n  return goog.i18n.bidi.rtlCharReg_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Test whether the given string has any RTL characters in it.\n * @param {string} str The given string that need to be tested.\n * @return {boolean} Whether the string contains RTL characters.\n * @deprecated Use hasAnyRtl.\n */\ngoog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;\n\n\n/**\n * Test whether the given string has any LTR characters in it.\n * @param {string} str The given string that need to be tested.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether the string contains LTR characters.\n */\ngoog.i18n.bidi.hasAnyLtr = function(str, opt_isHtml) {\n  'use strict';\n  return goog.i18n.bidi.ltrCharReg_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Regular expression pattern to check if the first character in the string\n * is LTR.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.ltrRe_ = new RegExp('^[' + goog.i18n.bidi.ltrChars_ + ']');\n\n\n/**\n * Regular expression pattern to check if the first character in the string\n * is RTL.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlRe_ = new RegExp('^[' + goog.i18n.bidi.rtlChars_ + ']');\n\n\n/**\n * Check if the first character in the string is RTL or not.\n * @param {string} str The given string that need to be tested.\n * @return {boolean} Whether the first character in str is an RTL char.\n */\ngoog.i18n.bidi.isRtlChar = function(str) {\n  'use strict';\n  return goog.i18n.bidi.rtlRe_.test(str);\n};\n\n\n/**\n * Check if the first character in the string is LTR or not.\n * @param {string} str The given string that need to be tested.\n * @return {boolean} Whether the first character in str is an LTR char.\n */\ngoog.i18n.bidi.isLtrChar = function(str) {\n  'use strict';\n  return goog.i18n.bidi.ltrRe_.test(str);\n};\n\n\n/**\n * Check if the first character in the string is neutral or not.\n * @param {string} str The given string that need to be tested.\n * @return {boolean} Whether the first character in str is a neutral char.\n */\ngoog.i18n.bidi.isNeutralChar = function(str) {\n  'use strict';\n  return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);\n};\n\n\n/**\n * Regular expressions to check if a piece of text is of LTR directionality\n * on first character with strong directionality.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.ltrDirCheckRe_ = new RegExp(\n    '^[^' + goog.i18n.bidi.rtlChars_ + ']*[' + goog.i18n.bidi.ltrChars_ + ']');\n\n\n/**\n * Regular expressions to check if a piece of text is of RTL directionality\n * on first character with strong directionality.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlDirCheckRe_ = new RegExp(\n    '^[^' + goog.i18n.bidi.ltrChars_ + ']*[' + goog.i18n.bidi.rtlChars_ + ']');\n\n\n/**\n * Check whether the first strongly directional character (if any) is RTL.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether RTL directionality is detected using the first\n *     strongly-directional character method.\n */\ngoog.i18n.bidi.startsWithRtl = function(str, opt_isHtml) {\n  'use strict';\n  return goog.i18n.bidi.rtlDirCheckRe_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Check whether the first strongly directional character (if any) is RTL.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether RTL directionality is detected using the first\n *     strongly-directional character method.\n * @deprecated Use startsWithRtl.\n */\ngoog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;\n\n\n/**\n * Check whether the first strongly directional character (if any) is LTR.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether LTR directionality is detected using the first\n *     strongly-directional character method.\n */\ngoog.i18n.bidi.startsWithLtr = function(str, opt_isHtml) {\n  'use strict';\n  return goog.i18n.bidi.ltrDirCheckRe_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Check whether the first strongly directional character (if any) is LTR.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether LTR directionality is detected using the first\n *     strongly-directional character method.\n * @deprecated Use startsWithLtr.\n */\ngoog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;\n\n\n/**\n * Regular expression to check if a string looks like something that must\n * always be LTR even in RTL text, e.g. a URL. When estimating the\n * directionality of text containing these, we treat these as weakly LTR,\n * like numbers.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.isRequiredLtrRe_ = /^http:\\/\\/.*/;\n\n\n/**\n * Check whether the input string either contains no strongly directional\n * characters or looks like a url.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether neutral directionality is detected.\n */\ngoog.i18n.bidi.isNeutralText = function(str, opt_isHtml) {\n  'use strict';\n  str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);\n  return goog.i18n.bidi.isRequiredLtrRe_.test(str) ||\n      !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);\n};\n\n\n/**\n * Regular expressions to check if the last strongly-directional character in a\n * piece of text is LTR.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp(\n    '[' + goog.i18n.bidi.ltrChars_ + ']' +\n    '[^' + goog.i18n.bidi.rtlChars_ + ']*$');\n\n\n/**\n * Regular expressions to check if the last strongly-directional character in a\n * piece of text is RTL.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp(\n    '[' + goog.i18n.bidi.rtlChars_ + ']' +\n    '[^' + goog.i18n.bidi.ltrChars_ + ']*$');\n\n\n/**\n * Check if the exit directionality a piece of text is LTR, i.e. if the last\n * strongly-directional character in the string is LTR.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether LTR exit directionality was detected.\n */\ngoog.i18n.bidi.endsWithLtr = function(str, opt_isHtml) {\n  'use strict';\n  return goog.i18n.bidi.ltrExitDirCheckRe_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Check if the exit directionality a piece of text is LTR, i.e. if the last\n * strongly-directional character in the string is LTR.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether LTR exit directionality was detected.\n * @deprecated Use endsWithLtr.\n */\ngoog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;\n\n\n/**\n * Check if the exit directionality a piece of text is RTL, i.e. if the last\n * strongly-directional character in the string is RTL.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether RTL exit directionality was detected.\n */\ngoog.i18n.bidi.endsWithRtl = function(str, opt_isHtml) {\n  'use strict';\n  return goog.i18n.bidi.rtlExitDirCheckRe_.test(\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\n};\n\n\n/**\n * Check if the exit directionality a piece of text is RTL, i.e. if the last\n * strongly-directional character in the string is RTL.\n * @param {string} str String being checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether RTL exit directionality was detected.\n * @deprecated Use endsWithRtl.\n */\ngoog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;\n\n\n/**\n * A regular expression for matching right-to-left language codes.\n * See {@link #isRtlLanguage} for the design.\n * Note that not all RTL scripts are included.\n * @type {!RegExp}\n * @private\n */\ngoog.i18n.bidi.rtlLocalesRe_ = new RegExp(\n    '^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|' +\n        '.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))' +\n        '(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)',\n    'i');\n\n\n/**\n * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:\n * - a language code explicitly specifying one of the right-to-left scripts,\n *   e.g. \"az-Arab\", or<p>\n * - a language code specifying one of the languages normally written in a\n *   right-to-left script, e.g. \"fa\" (Farsi), except ones explicitly specifying\n *   Latin or Cyrillic script (which are the usual LTR alternatives).<p>\n * The list of right-to-left scripts appears in the 100-199 range in\n * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and\n * Hebrew are by far the most widely used. We also recognize Thaana, and N'Ko,\n * which also have significant modern usage. Adlam and Rohingya\n * scripts are now included since they can be expected to be used in the\n * future. The rest (Syriac, Samaritan, Mandaic, etc.) seem to have extremely\n * limited or no modern usage and are not recognized to save on code size. The\n * languages usually written in a right-to-left script are taken as those with\n * Suppress-Script: Hebr|Arab|Thaa|Nkoo|Adlm|Rohg in\n * http://www.iana.org/assignments/language-subtag-registry,\n * as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).\n * Other subtags of the language code, e.g. regions like EG (Egypt), are\n * ignored.\n * @param {string} lang BCP 47 (a.k.a III) language code.\n * @return {boolean} Whether the language code is an RTL language.\n */\ngoog.i18n.bidi.isRtlLanguage = function(lang) {\n  'use strict';\n  return goog.i18n.bidi.rtlLocalesRe_.test(lang);\n};\n\n\n/**\n * Regular expression for bracket guard replacement in text.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.bracketGuardTextRe_ =\n    /(\\(.*?\\)+)|(\\[.*?\\]+)|(\\{.*?\\}+)|(<.*?>+)/g;\n\n\n/**\n * Apply bracket guard using LRM and RLM. This is to address the problem of\n * messy bracket display frequently happens in RTL layout.\n * This function works for plain text, not for HTML. In HTML, the opening\n * bracket might be in a different context than the closing bracket (such as\n * an attribute value).\n * @param {string} s The string that need to be processed.\n * @param {boolean=} opt_isRtlContext specifies default direction (usually\n *     direction of the UI).\n * @return {string} The processed string, with all bracket guarded.\n */\ngoog.i18n.bidi.guardBracketInText = function(s, opt_isRtlContext) {\n  'use strict';\n  const useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) :\n                                                  opt_isRtlContext;\n  const mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;\n  return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + '$&' + mark);\n};\n\n\n/**\n * Enforce the html snippet in RTL directionality regardless of overall context.\n * If the html piece was enclosed by tag, dir will be applied to existing\n * tag, otherwise a span tag will be added as wrapper. For this reason, if\n * html snippet starts with a tag, this tag must enclose the whole piece. If\n * the tag already has a dir specified, this new one will override existing\n * one in behavior (tested on FF and IE).\n * @param {string} html The string that need to be processed.\n * @return {string} The processed string, with directionality enforced to RTL.\n */\ngoog.i18n.bidi.enforceRtlInHtml = function(html) {\n  'use strict';\n  if (html.charAt(0) == '<') {\n    return html.replace(/<\\w+/, '$& dir=rtl');\n  }\n  // '\\n' is important for FF so that it won't incorrectly merge span groups\n  return '\\n<span dir=rtl>' + html + '</span>';\n};\n\n\n/**\n * Enforce RTL on both end of the given text piece using unicode BiDi formatting\n * characters RLE and PDF.\n * @param {string} text The piece of text that need to be wrapped.\n * @return {string} The wrapped string after process.\n */\ngoog.i18n.bidi.enforceRtlInText = function(text) {\n  'use strict';\n  return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;\n};\n\n\n/**\n * Enforce the html snippet in RTL directionality regardless or overall context.\n * If the html piece was enclosed by tag, dir will be applied to existing\n * tag, otherwise a span tag will be added as wrapper. For this reason, if\n * html snippet starts with a tag, this tag must enclose the whole piece. If\n * the tag already has a dir specified, this new one will override existing\n * one in behavior (tested on FF and IE).\n * @param {string} html The string that need to be processed.\n * @return {string} The processed string, with directionality enforced to RTL.\n */\ngoog.i18n.bidi.enforceLtrInHtml = function(html) {\n  'use strict';\n  if (html.charAt(0) == '<') {\n    return html.replace(/<\\w+/, '$& dir=ltr');\n  }\n  // '\\n' is important for FF so that it won't incorrectly merge span groups\n  return '\\n<span dir=ltr>' + html + '</span>';\n};\n\n\n/**\n * Enforce LTR on both end of the given text piece using unicode BiDi formatting\n * characters LRE and PDF.\n * @param {string} text The piece of text that need to be wrapped.\n * @return {string} The wrapped string after process.\n */\ngoog.i18n.bidi.enforceLtrInText = function(text) {\n  'use strict';\n  return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;\n};\n\n\n/**\n * Regular expression to find dimensions such as \"padding: .3 0.4ex 5px 6;\"\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.dimensionsRe_ =\n    /:\\s*([.\\d][.\\w]*)\\s+([.\\d][.\\w]*)\\s+([.\\d][.\\w]*)\\s+([.\\d][.\\w]*)/g;\n\n\n/**\n * Regular expression for left.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.leftRe_ = /left/gi;\n\n\n/**\n * Regular expression for right.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.rightRe_ = /right/gi;\n\n\n/**\n * Placeholder regular expression for swapping.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.tempRe_ = /%%%%/g;\n\n\n/**\n * Swap location parameters and 'left'/'right' in CSS specification. The\n * processed string will be suited for RTL layout. Though this function can\n * cover most cases, there are always exceptions. It is suggested to put\n * those exceptions in separate group of CSS string.\n * @param {string} cssStr CSS spefication string.\n * @return {string} Processed CSS specification string.\n */\ngoog.i18n.bidi.mirrorCSS = function(cssStr) {\n  'use strict';\n  return cssStr\n      .\n      // reverse dimensions\n      replace(goog.i18n.bidi.dimensionsRe_, ':$1 $4 $3 $2')\n      .replace(goog.i18n.bidi.leftRe_, '%%%%')\n      .  // swap left and right\n      replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT)\n      .replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);\n};\n\n\n/**\n * Regular expression for hebrew double quote substitution, finding quote\n * directly after hebrew characters.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\\u0591-\\u05f2])\"/g;\n\n\n/**\n * Regular expression for hebrew single quote substitution, finding quote\n * directly after hebrew characters.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.singleQuoteSubstituteRe_ = /([\\u0591-\\u05f2])'/g;\n\n\n/**\n * Replace the double and single quote directly after a Hebrew character with\n * GERESH and GERSHAYIM. In such case, most likely that's user intention.\n * @param {string} str String that need to be processed.\n * @return {string} Processed string with double/single quote replaced.\n */\ngoog.i18n.bidi.normalizeHebrewQuote = function(str) {\n  'use strict';\n  return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, '$1\\u05f4')\n      .replace(goog.i18n.bidi.singleQuoteSubstituteRe_, '$1\\u05f3');\n};\n\n\n/**\n * Regular expression to split a string into \"words\" for directionality\n * estimation based on relative word counts.\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.wordSeparatorRe_ = /\\s+/;\n\n\n/**\n * Regular expression to check if a string contains any numerals. Used to\n * differentiate between completely neutral strings and those containing\n * numbers, which are weakly LTR.\n *\n * Native Arabic digits (\\u0660 - \\u0669) are not included because although they\n * do flow left-to-right inside a number, this is the case even if the  overall\n * directionality is RTL, and a mathematical expression using these digits is\n * supposed to flow right-to-left overall, including unary plus and minus\n * appearing to the right of a number, and this does depend on the overall\n * directionality being RTL. The digits used in Farsi (\\u06F0 - \\u06F9), on the\n * other hand, are included, since Farsi math (including unary plus and minus)\n * does flow left-to-right.\n * TODO: Consider other systems of digits, e.g., Adlam.\n *\n * @type {RegExp}\n * @private\n */\ngoog.i18n.bidi.hasNumeralsRe_ = /[\\d\\u06f0-\\u06f9]/;\n\n\n/**\n * This constant controls threshold of RTL directionality.\n * @type {number}\n * @private\n */\ngoog.i18n.bidi.rtlDetectionThreshold_ = 0.40;\n\n\n/**\n * Estimates the directionality of a string based on relative word counts.\n * If the number of RTL words is above a certain percentage of the total number\n * of strongly directional words, returns RTL.\n * Otherwise, if any words are strongly or weakly LTR, returns LTR.\n * Otherwise, returns UNKNOWN, which is used to mean \"neutral\".\n * Numbers are counted as weakly LTR.\n * @param {string} str The string to be checked.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {goog.i18n.bidi.Dir} Estimated overall directionality of `str`.\n */\ngoog.i18n.bidi.estimateDirection = function(str, opt_isHtml) {\n  'use strict';\n  let rtlCount = 0;\n  let totalCount = 0;\n  let hasWeaklyLtr = false;\n  const tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml)\n                     .split(goog.i18n.bidi.wordSeparatorRe_);\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (goog.i18n.bidi.startsWithRtl(token)) {\n      rtlCount++;\n      totalCount++;\n    } else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {\n      hasWeaklyLtr = true;\n    } else if (goog.i18n.bidi.hasAnyLtr(token)) {\n      totalCount++;\n    } else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {\n      hasWeaklyLtr = true;\n    }\n  }\n\n  return totalCount == 0 ?\n      (hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL) :\n      (rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ?\n           goog.i18n.bidi.Dir.RTL :\n           goog.i18n.bidi.Dir.LTR);\n};\n\n\n/**\n * Check the directionality of a piece of text, return true if the piece of\n * text should be laid out in RTL direction.\n * @param {string} str The piece of text that need to be detected.\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\n *     Default: false.\n * @return {boolean} Whether this piece of text should be laid out in RTL.\n */\ngoog.i18n.bidi.detectRtlDirectionality = function(str, opt_isHtml) {\n  'use strict';\n  return goog.i18n.bidi.estimateDirection(str, opt_isHtml) ==\n      goog.i18n.bidi.Dir.RTL;\n};\n\n\n/**\n * Sets text input element's directionality and text alignment based on a\n * given directionality. Does nothing if the given directionality is unknown or\n * neutral.\n * @param {Element} element Input field element to set directionality to.\n * @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,\n *     given in one of the following formats:\n *     1. A goog.i18n.bidi.Dir constant.\n *     2. A number (positive = LRT, negative = RTL, 0 = neutral).\n *     3. A boolean (true = RTL, false = LTR).\n *     4. A null for unknown directionality.\n */\ngoog.i18n.bidi.setElementDirAndAlign = function(element, dir) {\n  'use strict';\n  if (element) {\n    const htmlElement = /** @type {!HTMLElement} */ (element);\n    dir = goog.i18n.bidi.toDir(dir);\n    if (dir) {\n      htmlElement.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ?\n          goog.i18n.bidi.RIGHT :\n          goog.i18n.bidi.LEFT;\n      htmlElement.dir = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';\n    }\n  }\n};\n\n\n/**\n * Sets element dir based on estimated directionality of the given text.\n * @param {!Element} element\n * @param {string} text\n */\ngoog.i18n.bidi.setElementDirByTextDirectionality = function(element, text) {\n  'use strict';\n  const htmlElement = /** @type {!HTMLElement} */ (element);\n  switch (goog.i18n.bidi.estimateDirection(text)) {\n    case (goog.i18n.bidi.Dir.LTR):\n      if (htmlElement.dir !== 'ltr') {\n        htmlElement.dir = 'ltr';\n      }\n      break;\n    case (goog.i18n.bidi.Dir.RTL):\n      if (htmlElement.dir !== 'rtl') {\n        htmlElement.dir = 'rtl';\n      }\n      break;\n    default:\n      // Default for no direction, inherit from document.\n      htmlElement.removeAttribute('dir');\n  }\n};\n\n\n\n/**\n * Strings that have an (optional) known direction.\n *\n * Implementations of this interface are string-like objects that carry an\n * attached direction, if known.\n * @interface\n */\ngoog.i18n.bidi.DirectionalString = function() {};\n\n\n/**\n * Interface marker of the DirectionalString interface.\n *\n * This property can be used to determine at runtime whether or not an object\n * implements this interface.  All implementations of this interface set this\n * property to `true`.\n * @type {boolean}\n */\ngoog.i18n.bidi.DirectionalString.prototype\n    .implementsGoogI18nBidiDirectionalString;\n\n\n/**\n * Retrieves this object's known direction (if any).\n * @return {?goog.i18n.bidi.Dir} The known direction. Null if unknown.\n */\ngoog.i18n.bidi.DirectionalString.prototype.getDirection;\n","~:compiled-at",1623605884865,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.i18n.bidi.js\",\n\"lineCount\":181,\n\"mappings\":\"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\",\n\"sources\":[\"goog/i18n/bidi.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n/**\\n * @fileoverview Utility functions for supporting Bidi issues.\\n */\\n\\n\\n/**\\n * Namespace for bidi supporting functions.\\n */\\ngoog.provide('goog.i18n.bidi');\\ngoog.provide('goog.i18n.bidi.Dir');\\ngoog.provide('goog.i18n.bidi.DirectionalString');\\ngoog.provide('goog.i18n.bidi.Format');\\n\\n\\n/**\\n * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant\\n * to say that the current locale is a RTL locale.  This should only be used\\n * if you want to override the default behavior for deciding whether the\\n * current locale is RTL or not.\\n *\\n * {@see goog.i18n.bidi.IS_RTL}\\n */\\ngoog.i18n.bidi.FORCE_RTL = goog.define('goog.i18n.bidi.FORCE_RTL', false);\\n\\n\\n/**\\n * Constant that defines whether or not the current locale is a RTL locale.\\n * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default\\n * to check that {@link goog.LOCALE} is one of a few major RTL locales.\\n *\\n * <p>This is designed to be a maximally efficient compile-time constant. For\\n * example, for the default goog.LOCALE, compiling\\n * \\\"if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}\\\" should produce no code. It\\n * is this design consideration that limits the implementation to only\\n * supporting a few major RTL locales, as opposed to the broader repertoire of\\n * something like goog.i18n.bidi.isRtlLanguage.\\n *\\n * <p>Since this constant refers to the directionality of the locale, it is up\\n * to the caller to determine if this constant should also be used for the\\n * direction of the UI.\\n *\\n * {@see goog.LOCALE}\\n *\\n * @type {boolean}\\n *\\n * TODO(user): write a test that checks that this is a compile-time constant.\\n */\\n// LINT.IfChange\\ngoog.i18n.bidi.IS_RTL =\\n    goog.i18n.bidi.FORCE_RTL ||\\n    ((goog.LOCALE.substring(0, 2).toLowerCase() == 'ar' ||\\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'fa' ||\\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'he' ||\\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'iw' ||\\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'ps' ||\\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'sd' ||\\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'ug' ||\\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'ur' ||\\n      goog.LOCALE.substring(0, 2).toLowerCase() == 'yi') &&\\n     (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == '-' ||\\n      goog.LOCALE.substring(2, 3) == '_')) ||\\n    (  // Specific to CKB (Central Kurdish)\\n        goog.LOCALE.length >= 3 &&\\n        goog.LOCALE.substring(0, 3).toLowerCase() == 'ckb' &&\\n        (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == '-' ||\\n         goog.LOCALE.substring(3, 4) == '_')) ||\\n    (  // 2 letter language codes with RTL scripts\\n        goog.LOCALE.length >= 7 &&\\n        ((goog.LOCALE.substring(2, 3) == '-' ||\\n          goog.LOCALE.substring(2, 3) == '_') &&\\n         (goog.LOCALE.substring(3, 7).toLowerCase() == 'adlm' ||\\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'arab' ||\\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'hebr' ||\\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'nkoo' ||\\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'rohg' ||\\n          goog.LOCALE.substring(3, 7).toLowerCase() == 'thaa'))) ||\\n    (  // 3 letter languages codes with RTL scripts\\n        goog.LOCALE.length >= 8 &&\\n        ((goog.LOCALE.substring(3, 4) == '-' ||\\n          goog.LOCALE.substring(3, 4) == '_') &&\\n         (goog.LOCALE.substring(4, 8).toLowerCase() == 'adlm' ||\\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'arab' ||\\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'hebr' ||\\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'nkoo' ||\\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'rohg' ||\\n          goog.LOCALE.substring(4, 8).toLowerCase() == 'thaa')));\\n//    closure/RtlLocalesTest.java)\\n\\n// TODO(user): Add additional scripts and languages that are RTL,\\n// e.g., mende, samaritan, etc.\\n\\n\\n/**\\n * Unicode formatting characters and directionality string constants.\\n * @enum {string}\\n */\\ngoog.i18n.bidi.Format = {\\n  /** Unicode \\\"Left-To-Right Embedding\\\" (LRE) character. */\\n  LRE: '\\\\u202A',\\n  /** Unicode \\\"Right-To-Left Embedding\\\" (RLE) character. */\\n  RLE: '\\\\u202B',\\n  /** Unicode \\\"Pop Directional Formatting\\\" (PDF) character. */\\n  PDF: '\\\\u202C',\\n  /** Unicode \\\"Left-To-Right Mark\\\" (LRM) character. */\\n  LRM: '\\\\u200E',\\n  /** Unicode \\\"Right-To-Left Mark\\\" (RLM) character. */\\n  RLM: '\\\\u200F'\\n};\\n\\n\\n/**\\n * Directionality enum.\\n * @enum {number}\\n */\\ngoog.i18n.bidi.Dir = {\\n  /**\\n   * Left-to-right.\\n   */\\n  LTR: 1,\\n\\n  /**\\n   * Right-to-left.\\n   */\\n  RTL: -1,\\n\\n  /**\\n   * Neither left-to-right nor right-to-left.\\n   */\\n  NEUTRAL: 0\\n};\\n\\n\\n/**\\n * 'right' string constant.\\n * @type {string}\\n */\\ngoog.i18n.bidi.RIGHT = 'right';\\n\\n\\n/**\\n * 'left' string constant.\\n * @type {string}\\n */\\ngoog.i18n.bidi.LEFT = 'left';\\n\\n\\n/**\\n * 'left' if locale is RTL, 'right' if not.\\n * @type {string}\\n */\\ngoog.i18n.bidi.I18N_RIGHT =\\n    goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;\\n\\n\\n/**\\n * 'right' if locale is RTL, 'left' if not.\\n * @type {string}\\n */\\ngoog.i18n.bidi.I18N_LEFT =\\n    goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;\\n\\n\\n/**\\n * Convert a directionality given in various formats to a goog.i18n.bidi.Dir\\n * constant. Useful for interaction with different standards of directionality\\n * representation.\\n *\\n * @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given\\n *     in one of the following formats:\\n *     1. A goog.i18n.bidi.Dir constant.\\n *     2. A number (positive = LTR, negative = RTL, 0 = neutral).\\n *     3. A boolean (true = RTL, false = LTR).\\n *     4. A null for unknown directionality.\\n * @param {boolean=} opt_noNeutral Whether a givenDir of zero or\\n *     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in\\n *     order to preserve legacy behavior.\\n * @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the\\n *     given directionality. If given null, returns null (i.e. unknown).\\n */\\ngoog.i18n.bidi.toDir = function(givenDir, opt_noNeutral) {\\n  'use strict';\\n  if (typeof givenDir == 'number') {\\n    // This includes the non-null goog.i18n.bidi.Dir case.\\n    return givenDir > 0 ?\\n        goog.i18n.bidi.Dir.LTR :\\n        givenDir < 0 ? goog.i18n.bidi.Dir.RTL :\\n                       opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;\\n  } else if (givenDir == null) {\\n    return null;\\n  } else {\\n    // Must be typeof givenDir == 'boolean'.\\n    return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;\\n  }\\n};\\n\\n\\n/**\\n * A practical pattern to identify strong LTR character in the BMP.\\n * This pattern is not theoretically correct according to the Unicode\\n * standard. It is simplified for performance and small code size.\\n * It also partially supports LTR scripts beyond U+FFFF by including\\n * UTF-16 high surrogate values corresponding to mostly L-class code\\n * point ranges.\\n * However, low surrogate values and private-use regions are not included\\n * in this RegEx.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.bidi.ltrChars_ =\\n    'A-Za-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02B8\\\\u0300-\\\\u0590\\\\u0900-\\\\u1FFF' +\\n    '\\\\u200E\\\\u2C00-\\\\uD801\\\\uD804-\\\\uD839\\\\uD83C-\\\\uDBFF' +\\n    '\\\\uF900-\\\\uFB1C\\\\uFE00-\\\\uFE6F\\\\uFEFD-\\\\uFFFF';\\n\\n/**\\n * A practical pattern to identify strong RTL character. This pattern is not\\n * theoretically correct according to the Unicode standard. It is simplified\\n * for performance and small code size.\\n * It also partially supports RTL scripts beyond U+FFFF by including\\n * UTF-16 high surrogate values corresponding to mostly R- or AL-class\\n * code point ranges.\\n * However, low surrogate values and private-use regions are not included\\n * in this RegEx.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.bidi.rtlChars_ =\\n    '\\\\u0591-\\\\u06EF\\\\u06FA-\\\\u08FF\\\\u200F\\\\uD802-\\\\uD803\\\\uD83A-\\\\uD83B' +\\n    '\\\\uFB1D-\\\\uFDFF\\\\uFE70-\\\\uFEFC';\\n\\n/**\\n * Simplified regular expression for an HTML tag (opening or closing) or an HTML\\n * escape. We might want to skip over such expressions when estimating the text\\n * directionality.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;\\n\\n\\n/**\\n * Returns the input text with spaces instead of HTML tags or HTML escapes, if\\n * opt_isStripNeeded is true. Else returns the input as is.\\n * Useful for text directionality estimation.\\n * Note: the function should not be used in other contexts; it is not 100%\\n * correct, but rather a good-enough implementation for directionality\\n * estimation purposes.\\n * @param {string} str The given string.\\n * @param {boolean=} opt_isStripNeeded Whether to perform the stripping.\\n *     Default: false (to retain consistency with calling functions).\\n * @return {string} The given string cleaned of HTML tags / escapes.\\n * @private\\n */\\ngoog.i18n.bidi.stripHtmlIfNeeded_ = function(str, opt_isStripNeeded) {\\n  'use strict';\\n  return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, '') : str;\\n};\\n\\n\\n/**\\n * Regular expression to check for RTL characters, BMP and high surrogate.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.rtlCharReg_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + ']');\\n\\n\\n/**\\n * Regular expression to check for LTR characters.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.ltrCharReg_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + ']');\\n\\n\\n/**\\n * Test whether the given string has any RTL characters in it.\\n * @param {string} str The given string that need to be tested.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether the string contains RTL characters.\\n */\\ngoog.i18n.bidi.hasAnyRtl = function(str, opt_isHtml) {\\n  'use strict';\\n  return goog.i18n.bidi.rtlCharReg_.test(\\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\\n};\\n\\n\\n/**\\n * Test whether the given string has any RTL characters in it.\\n * @param {string} str The given string that need to be tested.\\n * @return {boolean} Whether the string contains RTL characters.\\n * @deprecated Use hasAnyRtl.\\n */\\ngoog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;\\n\\n\\n/**\\n * Test whether the given string has any LTR characters in it.\\n * @param {string} str The given string that need to be tested.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether the string contains LTR characters.\\n */\\ngoog.i18n.bidi.hasAnyLtr = function(str, opt_isHtml) {\\n  'use strict';\\n  return goog.i18n.bidi.ltrCharReg_.test(\\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\\n};\\n\\n\\n/**\\n * Regular expression pattern to check if the first character in the string\\n * is LTR.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.ltrRe_ = new RegExp('^[' + goog.i18n.bidi.ltrChars_ + ']');\\n\\n\\n/**\\n * Regular expression pattern to check if the first character in the string\\n * is RTL.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.rtlRe_ = new RegExp('^[' + goog.i18n.bidi.rtlChars_ + ']');\\n\\n\\n/**\\n * Check if the first character in the string is RTL or not.\\n * @param {string} str The given string that need to be tested.\\n * @return {boolean} Whether the first character in str is an RTL char.\\n */\\ngoog.i18n.bidi.isRtlChar = function(str) {\\n  'use strict';\\n  return goog.i18n.bidi.rtlRe_.test(str);\\n};\\n\\n\\n/**\\n * Check if the first character in the string is LTR or not.\\n * @param {string} str The given string that need to be tested.\\n * @return {boolean} Whether the first character in str is an LTR char.\\n */\\ngoog.i18n.bidi.isLtrChar = function(str) {\\n  'use strict';\\n  return goog.i18n.bidi.ltrRe_.test(str);\\n};\\n\\n\\n/**\\n * Check if the first character in the string is neutral or not.\\n * @param {string} str The given string that need to be tested.\\n * @return {boolean} Whether the first character in str is a neutral char.\\n */\\ngoog.i18n.bidi.isNeutralChar = function(str) {\\n  'use strict';\\n  return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);\\n};\\n\\n\\n/**\\n * Regular expressions to check if a piece of text is of LTR directionality\\n * on first character with strong directionality.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.ltrDirCheckRe_ = new RegExp(\\n    '^[^' + goog.i18n.bidi.rtlChars_ + ']*[' + goog.i18n.bidi.ltrChars_ + ']');\\n\\n\\n/**\\n * Regular expressions to check if a piece of text is of RTL directionality\\n * on first character with strong directionality.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.rtlDirCheckRe_ = new RegExp(\\n    '^[^' + goog.i18n.bidi.ltrChars_ + ']*[' + goog.i18n.bidi.rtlChars_ + ']');\\n\\n\\n/**\\n * Check whether the first strongly directional character (if any) is RTL.\\n * @param {string} str String being checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether RTL directionality is detected using the first\\n *     strongly-directional character method.\\n */\\ngoog.i18n.bidi.startsWithRtl = function(str, opt_isHtml) {\\n  'use strict';\\n  return goog.i18n.bidi.rtlDirCheckRe_.test(\\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\\n};\\n\\n\\n/**\\n * Check whether the first strongly directional character (if any) is RTL.\\n * @param {string} str String being checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether RTL directionality is detected using the first\\n *     strongly-directional character method.\\n * @deprecated Use startsWithRtl.\\n */\\ngoog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;\\n\\n\\n/**\\n * Check whether the first strongly directional character (if any) is LTR.\\n * @param {string} str String being checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether LTR directionality is detected using the first\\n *     strongly-directional character method.\\n */\\ngoog.i18n.bidi.startsWithLtr = function(str, opt_isHtml) {\\n  'use strict';\\n  return goog.i18n.bidi.ltrDirCheckRe_.test(\\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\\n};\\n\\n\\n/**\\n * Check whether the first strongly directional character (if any) is LTR.\\n * @param {string} str String being checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether LTR directionality is detected using the first\\n *     strongly-directional character method.\\n * @deprecated Use startsWithLtr.\\n */\\ngoog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;\\n\\n\\n/**\\n * Regular expression to check if a string looks like something that must\\n * always be LTR even in RTL text, e.g. a URL. When estimating the\\n * directionality of text containing these, we treat these as weakly LTR,\\n * like numbers.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.isRequiredLtrRe_ = /^http:\\\\/\\\\/.*/;\\n\\n\\n/**\\n * Check whether the input string either contains no strongly directional\\n * characters or looks like a url.\\n * @param {string} str String being checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether neutral directionality is detected.\\n */\\ngoog.i18n.bidi.isNeutralText = function(str, opt_isHtml) {\\n  'use strict';\\n  str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);\\n  return goog.i18n.bidi.isRequiredLtrRe_.test(str) ||\\n      !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);\\n};\\n\\n\\n/**\\n * Regular expressions to check if the last strongly-directional character in a\\n * piece of text is LTR.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp(\\n    '[' + goog.i18n.bidi.ltrChars_ + ']' +\\n    '[^' + goog.i18n.bidi.rtlChars_ + ']*$');\\n\\n\\n/**\\n * Regular expressions to check if the last strongly-directional character in a\\n * piece of text is RTL.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp(\\n    '[' + goog.i18n.bidi.rtlChars_ + ']' +\\n    '[^' + goog.i18n.bidi.ltrChars_ + ']*$');\\n\\n\\n/**\\n * Check if the exit directionality a piece of text is LTR, i.e. if the last\\n * strongly-directional character in the string is LTR.\\n * @param {string} str String being checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether LTR exit directionality was detected.\\n */\\ngoog.i18n.bidi.endsWithLtr = function(str, opt_isHtml) {\\n  'use strict';\\n  return goog.i18n.bidi.ltrExitDirCheckRe_.test(\\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\\n};\\n\\n\\n/**\\n * Check if the exit directionality a piece of text is LTR, i.e. if the last\\n * strongly-directional character in the string is LTR.\\n * @param {string} str String being checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether LTR exit directionality was detected.\\n * @deprecated Use endsWithLtr.\\n */\\ngoog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;\\n\\n\\n/**\\n * Check if the exit directionality a piece of text is RTL, i.e. if the last\\n * strongly-directional character in the string is RTL.\\n * @param {string} str String being checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether RTL exit directionality was detected.\\n */\\ngoog.i18n.bidi.endsWithRtl = function(str, opt_isHtml) {\\n  'use strict';\\n  return goog.i18n.bidi.rtlExitDirCheckRe_.test(\\n      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));\\n};\\n\\n\\n/**\\n * Check if the exit directionality a piece of text is RTL, i.e. if the last\\n * strongly-directional character in the string is RTL.\\n * @param {string} str String being checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether RTL exit directionality was detected.\\n * @deprecated Use endsWithRtl.\\n */\\ngoog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;\\n\\n\\n/**\\n * A regular expression for matching right-to-left language codes.\\n * See {@link #isRtlLanguage} for the design.\\n * Note that not all RTL scripts are included.\\n * @type {!RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.rtlLocalesRe_ = new RegExp(\\n    '^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|' +\\n        '.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))' +\\n        '(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)',\\n    'i');\\n\\n\\n/**\\n * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:\\n * - a language code explicitly specifying one of the right-to-left scripts,\\n *   e.g. \\\"az-Arab\\\", or<p>\\n * - a language code specifying one of the languages normally written in a\\n *   right-to-left script, e.g. \\\"fa\\\" (Farsi), except ones explicitly specifying\\n *   Latin or Cyrillic script (which are the usual LTR alternatives).<p>\\n * The list of right-to-left scripts appears in the 100-199 range in\\n * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and\\n * Hebrew are by far the most widely used. We also recognize Thaana, and N'Ko,\\n * which also have significant modern usage. Adlam and Rohingya\\n * scripts are now included since they can be expected to be used in the\\n * future. The rest (Syriac, Samaritan, Mandaic, etc.) seem to have extremely\\n * limited or no modern usage and are not recognized to save on code size. The\\n * languages usually written in a right-to-left script are taken as those with\\n * Suppress-Script: Hebr|Arab|Thaa|Nkoo|Adlm|Rohg in\\n * http://www.iana.org/assignments/language-subtag-registry,\\n * as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).\\n * Other subtags of the language code, e.g. regions like EG (Egypt), are\\n * ignored.\\n * @param {string} lang BCP 47 (a.k.a III) language code.\\n * @return {boolean} Whether the language code is an RTL language.\\n */\\ngoog.i18n.bidi.isRtlLanguage = function(lang) {\\n  'use strict';\\n  return goog.i18n.bidi.rtlLocalesRe_.test(lang);\\n};\\n\\n\\n/**\\n * Regular expression for bracket guard replacement in text.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.bracketGuardTextRe_ =\\n    /(\\\\(.*?\\\\)+)|(\\\\[.*?\\\\]+)|(\\\\{.*?\\\\}+)|(<.*?>+)/g;\\n\\n\\n/**\\n * Apply bracket guard using LRM and RLM. This is to address the problem of\\n * messy bracket display frequently happens in RTL layout.\\n * This function works for plain text, not for HTML. In HTML, the opening\\n * bracket might be in a different context than the closing bracket (such as\\n * an attribute value).\\n * @param {string} s The string that need to be processed.\\n * @param {boolean=} opt_isRtlContext specifies default direction (usually\\n *     direction of the UI).\\n * @return {string} The processed string, with all bracket guarded.\\n */\\ngoog.i18n.bidi.guardBracketInText = function(s, opt_isRtlContext) {\\n  'use strict';\\n  const useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) :\\n                                                  opt_isRtlContext;\\n  const mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;\\n  return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + '$&' + mark);\\n};\\n\\n\\n/**\\n * Enforce the html snippet in RTL directionality regardless of overall context.\\n * If the html piece was enclosed by tag, dir will be applied to existing\\n * tag, otherwise a span tag will be added as wrapper. For this reason, if\\n * html snippet starts with a tag, this tag must enclose the whole piece. If\\n * the tag already has a dir specified, this new one will override existing\\n * one in behavior (tested on FF and IE).\\n * @param {string} html The string that need to be processed.\\n * @return {string} The processed string, with directionality enforced to RTL.\\n */\\ngoog.i18n.bidi.enforceRtlInHtml = function(html) {\\n  'use strict';\\n  if (html.charAt(0) == '<') {\\n    return html.replace(/<\\\\w+/, '$& dir=rtl');\\n  }\\n  // '\\\\n' is important for FF so that it won't incorrectly merge span groups\\n  return '\\\\n<span dir=rtl>' + html + '</span>';\\n};\\n\\n\\n/**\\n * Enforce RTL on both end of the given text piece using unicode BiDi formatting\\n * characters RLE and PDF.\\n * @param {string} text The piece of text that need to be wrapped.\\n * @return {string} The wrapped string after process.\\n */\\ngoog.i18n.bidi.enforceRtlInText = function(text) {\\n  'use strict';\\n  return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;\\n};\\n\\n\\n/**\\n * Enforce the html snippet in RTL directionality regardless or overall context.\\n * If the html piece was enclosed by tag, dir will be applied to existing\\n * tag, otherwise a span tag will be added as wrapper. For this reason, if\\n * html snippet starts with a tag, this tag must enclose the whole piece. If\\n * the tag already has a dir specified, this new one will override existing\\n * one in behavior (tested on FF and IE).\\n * @param {string} html The string that need to be processed.\\n * @return {string} The processed string, with directionality enforced to RTL.\\n */\\ngoog.i18n.bidi.enforceLtrInHtml = function(html) {\\n  'use strict';\\n  if (html.charAt(0) == '<') {\\n    return html.replace(/<\\\\w+/, '$& dir=ltr');\\n  }\\n  // '\\\\n' is important for FF so that it won't incorrectly merge span groups\\n  return '\\\\n<span dir=ltr>' + html + '</span>';\\n};\\n\\n\\n/**\\n * Enforce LTR on both end of the given text piece using unicode BiDi formatting\\n * characters LRE and PDF.\\n * @param {string} text The piece of text that need to be wrapped.\\n * @return {string} The wrapped string after process.\\n */\\ngoog.i18n.bidi.enforceLtrInText = function(text) {\\n  'use strict';\\n  return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;\\n};\\n\\n\\n/**\\n * Regular expression to find dimensions such as \\\"padding: .3 0.4ex 5px 6;\\\"\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.dimensionsRe_ =\\n    /:\\\\s*([.\\\\d][.\\\\w]*)\\\\s+([.\\\\d][.\\\\w]*)\\\\s+([.\\\\d][.\\\\w]*)\\\\s+([.\\\\d][.\\\\w]*)/g;\\n\\n\\n/**\\n * Regular expression for left.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.leftRe_ = /left/gi;\\n\\n\\n/**\\n * Regular expression for right.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.rightRe_ = /right/gi;\\n\\n\\n/**\\n * Placeholder regular expression for swapping.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.tempRe_ = /%%%%/g;\\n\\n\\n/**\\n * Swap location parameters and 'left'/'right' in CSS specification. The\\n * processed string will be suited for RTL layout. Though this function can\\n * cover most cases, there are always exceptions. It is suggested to put\\n * those exceptions in separate group of CSS string.\\n * @param {string} cssStr CSS spefication string.\\n * @return {string} Processed CSS specification string.\\n */\\ngoog.i18n.bidi.mirrorCSS = function(cssStr) {\\n  'use strict';\\n  return cssStr\\n      .\\n      // reverse dimensions\\n      replace(goog.i18n.bidi.dimensionsRe_, ':$1 $4 $3 $2')\\n      .replace(goog.i18n.bidi.leftRe_, '%%%%')\\n      .  // swap left and right\\n      replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT)\\n      .replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);\\n};\\n\\n\\n/**\\n * Regular expression for hebrew double quote substitution, finding quote\\n * directly after hebrew characters.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\\\\u0591-\\\\u05f2])\\\"/g;\\n\\n\\n/**\\n * Regular expression for hebrew single quote substitution, finding quote\\n * directly after hebrew characters.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.singleQuoteSubstituteRe_ = /([\\\\u0591-\\\\u05f2])'/g;\\n\\n\\n/**\\n * Replace the double and single quote directly after a Hebrew character with\\n * GERESH and GERSHAYIM. In such case, most likely that's user intention.\\n * @param {string} str String that need to be processed.\\n * @return {string} Processed string with double/single quote replaced.\\n */\\ngoog.i18n.bidi.normalizeHebrewQuote = function(str) {\\n  'use strict';\\n  return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, '$1\\\\u05f4')\\n      .replace(goog.i18n.bidi.singleQuoteSubstituteRe_, '$1\\\\u05f3');\\n};\\n\\n\\n/**\\n * Regular expression to split a string into \\\"words\\\" for directionality\\n * estimation based on relative word counts.\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.wordSeparatorRe_ = /\\\\s+/;\\n\\n\\n/**\\n * Regular expression to check if a string contains any numerals. Used to\\n * differentiate between completely neutral strings and those containing\\n * numbers, which are weakly LTR.\\n *\\n * Native Arabic digits (\\\\u0660 - \\\\u0669) are not included because although they\\n * do flow left-to-right inside a number, this is the case even if the  overall\\n * directionality is RTL, and a mathematical expression using these digits is\\n * supposed to flow right-to-left overall, including unary plus and minus\\n * appearing to the right of a number, and this does depend on the overall\\n * directionality being RTL. The digits used in Farsi (\\\\u06F0 - \\\\u06F9), on the\\n * other hand, are included, since Farsi math (including unary plus and minus)\\n * does flow left-to-right.\\n * TODO: Consider other systems of digits, e.g., Adlam.\\n *\\n * @type {RegExp}\\n * @private\\n */\\ngoog.i18n.bidi.hasNumeralsRe_ = /[\\\\d\\\\u06f0-\\\\u06f9]/;\\n\\n\\n/**\\n * This constant controls threshold of RTL directionality.\\n * @type {number}\\n * @private\\n */\\ngoog.i18n.bidi.rtlDetectionThreshold_ = 0.40;\\n\\n\\n/**\\n * Estimates the directionality of a string based on relative word counts.\\n * If the number of RTL words is above a certain percentage of the total number\\n * of strongly directional words, returns RTL.\\n * Otherwise, if any words are strongly or weakly LTR, returns LTR.\\n * Otherwise, returns UNKNOWN, which is used to mean \\\"neutral\\\".\\n * Numbers are counted as weakly LTR.\\n * @param {string} str The string to be checked.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {goog.i18n.bidi.Dir} Estimated overall directionality of `str`.\\n */\\ngoog.i18n.bidi.estimateDirection = function(str, opt_isHtml) {\\n  'use strict';\\n  let rtlCount = 0;\\n  let totalCount = 0;\\n  let hasWeaklyLtr = false;\\n  const tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml)\\n                     .split(goog.i18n.bidi.wordSeparatorRe_);\\n  for (let i = 0; i < tokens.length; i++) {\\n    const token = tokens[i];\\n    if (goog.i18n.bidi.startsWithRtl(token)) {\\n      rtlCount++;\\n      totalCount++;\\n    } else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {\\n      hasWeaklyLtr = true;\\n    } else if (goog.i18n.bidi.hasAnyLtr(token)) {\\n      totalCount++;\\n    } else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {\\n      hasWeaklyLtr = true;\\n    }\\n  }\\n\\n  return totalCount == 0 ?\\n      (hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL) :\\n      (rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ?\\n           goog.i18n.bidi.Dir.RTL :\\n           goog.i18n.bidi.Dir.LTR);\\n};\\n\\n\\n/**\\n * Check the directionality of a piece of text, return true if the piece of\\n * text should be laid out in RTL direction.\\n * @param {string} str The piece of text that need to be detected.\\n * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.\\n *     Default: false.\\n * @return {boolean} Whether this piece of text should be laid out in RTL.\\n */\\ngoog.i18n.bidi.detectRtlDirectionality = function(str, opt_isHtml) {\\n  'use strict';\\n  return goog.i18n.bidi.estimateDirection(str, opt_isHtml) ==\\n      goog.i18n.bidi.Dir.RTL;\\n};\\n\\n\\n/**\\n * Sets text input element's directionality and text alignment based on a\\n * given directionality. Does nothing if the given directionality is unknown or\\n * neutral.\\n * @param {Element} element Input field element to set directionality to.\\n * @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,\\n *     given in one of the following formats:\\n *     1. A goog.i18n.bidi.Dir constant.\\n *     2. A number (positive = LRT, negative = RTL, 0 = neutral).\\n *     3. A boolean (true = RTL, false = LTR).\\n *     4. A null for unknown directionality.\\n */\\ngoog.i18n.bidi.setElementDirAndAlign = function(element, dir) {\\n  'use strict';\\n  if (element) {\\n    const htmlElement = /** @type {!HTMLElement} */ (element);\\n    dir = goog.i18n.bidi.toDir(dir);\\n    if (dir) {\\n      htmlElement.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ?\\n          goog.i18n.bidi.RIGHT :\\n          goog.i18n.bidi.LEFT;\\n      htmlElement.dir = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Sets element dir based on estimated directionality of the given text.\\n * @param {!Element} element\\n * @param {string} text\\n */\\ngoog.i18n.bidi.setElementDirByTextDirectionality = function(element, text) {\\n  'use strict';\\n  const htmlElement = /** @type {!HTMLElement} */ (element);\\n  switch (goog.i18n.bidi.estimateDirection(text)) {\\n    case (goog.i18n.bidi.Dir.LTR):\\n      if (htmlElement.dir !== 'ltr') {\\n        htmlElement.dir = 'ltr';\\n      }\\n      break;\\n    case (goog.i18n.bidi.Dir.RTL):\\n      if (htmlElement.dir !== 'rtl') {\\n        htmlElement.dir = 'rtl';\\n      }\\n      break;\\n    default:\\n      // Default for no direction, inherit from document.\\n      htmlElement.removeAttribute('dir');\\n  }\\n};\\n\\n\\n\\n/**\\n * Strings that have an (optional) known direction.\\n *\\n * Implementations of this interface are string-like objects that carry an\\n * attached direction, if known.\\n * @interface\\n */\\ngoog.i18n.bidi.DirectionalString = function() {};\\n\\n\\n/**\\n * Interface marker of the DirectionalString interface.\\n *\\n * This property can be used to determine at runtime whether or not an object\\n * implements this interface.  All implementations of this interface set this\\n * property to `true`.\\n * @type {boolean}\\n */\\ngoog.i18n.bidi.DirectionalString.prototype\\n    .implementsGoogI18nBidiDirectionalString;\\n\\n\\n/**\\n * Retrieves this object's known direction (if any).\\n * @return {?goog.i18n.bidi.Dir} The known direction. Null if unknown.\\n */\\ngoog.i18n.bidi.DirectionalString.prototype.getDirection;\\n\"],\n\"names\":[\"goog\",\"provide\",\"i18n\",\"bidi\",\"FORCE_RTL\",\"define\",\"IS_RTL\",\"LOCALE\",\"substring\",\"toLowerCase\",\"length\",\"Format\",\"LRE\",\"RLE\",\"PDF\",\"LRM\",\"RLM\",\"Dir\",\"LTR\",\"RTL\",\"NEUTRAL\",\"RIGHT\",\"LEFT\",\"I18N_RIGHT\",\"I18N_LEFT\",\"toDir\",\"goog.i18n.bidi.toDir\",\"givenDir\",\"opt_noNeutral\",\"ltrChars_\",\"rtlChars_\",\"htmlSkipReg_\",\"stripHtmlIfNeeded_\",\"goog.i18n.bidi.stripHtmlIfNeeded_\",\"str\",\"opt_isStripNeeded\",\"replace\",\"rtlCharReg_\",\"RegExp\",\"ltrCharReg_\",\"hasAnyRtl\",\"goog.i18n.bidi.hasAnyRtl\",\"opt_isHtml\",\"test\",\"hasRtlChar\",\"hasAnyLtr\",\"goog.i18n.bidi.hasAnyLtr\",\"ltrRe_\",\"rtlRe_\",\"isRtlChar\",\"goog.i18n.bidi.isRtlChar\",\"isLtrChar\",\"goog.i18n.bidi.isLtrChar\",\"isNeutralChar\",\"goog.i18n.bidi.isNeutralChar\",\"ltrDirCheckRe_\",\"rtlDirCheckRe_\",\"startsWithRtl\",\"goog.i18n.bidi.startsWithRtl\",\"isRtlText\",\"startsWithLtr\",\"goog.i18n.bidi.startsWithLtr\",\"isLtrText\",\"isRequiredLtrRe_\",\"isNeutralText\",\"goog.i18n.bidi.isNeutralText\",\"ltrExitDirCheckRe_\",\"rtlExitDirCheckRe_\",\"endsWithLtr\",\"goog.i18n.bidi.endsWithLtr\",\"isLtrExitText\",\"endsWithRtl\",\"goog.i18n.bidi.endsWithRtl\",\"isRtlExitText\",\"rtlLocalesRe_\",\"isRtlLanguage\",\"goog.i18n.bidi.isRtlLanguage\",\"lang\",\"bracketGuardTextRe_\",\"guardBracketInText\",\"goog.i18n.bidi.guardBracketInText\",\"s\",\"opt_isRtlContext\",\"useRtl\",\"undefined\",\"mark\",\"enforceRtlInHtml\",\"goog.i18n.bidi.enforceRtlInHtml\",\"html\",\"charAt\",\"enforceRtlInText\",\"goog.i18n.bidi.enforceRtlInText\",\"text\",\"enforceLtrInHtml\",\"goog.i18n.bidi.enforceLtrInHtml\",\"enforceLtrInText\",\"goog.i18n.bidi.enforceLtrInText\",\"dimensionsRe_\",\"leftRe_\",\"rightRe_\",\"tempRe_\",\"mirrorCSS\",\"goog.i18n.bidi.mirrorCSS\",\"cssStr\",\"doubleQuoteSubstituteRe_\",\"singleQuoteSubstituteRe_\",\"normalizeHebrewQuote\",\"goog.i18n.bidi.normalizeHebrewQuote\",\"wordSeparatorRe_\",\"hasNumeralsRe_\",\"rtlDetectionThreshold_\",\"estimateDirection\",\"goog.i18n.bidi.estimateDirection\",\"rtlCount\",\"totalCount\",\"hasWeaklyLtr\",\"tokens\",\"split\",\"i\",\"token\",\"detectRtlDirectionality\",\"goog.i18n.bidi.detectRtlDirectionality\",\"setElementDirAndAlign\",\"goog.i18n.bidi.setElementDirAndAlign\",\"element\",\"dir\",\"htmlElement\",\"style\",\"textAlign\",\"setElementDirByTextDirectionality\",\"goog.i18n.bidi.setElementDirByTextDirectionality\",\"removeAttribute\",\"DirectionalString\",\"goog.i18n.bidi.DirectionalString\",\"prototype\",\"implementsGoogI18nBidiDirectionalString\",\"getDirection\"]\n}\n"]