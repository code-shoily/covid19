["^ ","~:resource-id",["~:shadow.build.classpath/resource","com/cognitect/transit/impl/decoder.js"],"~:js","goog.provide(\"com.cognitect.transit.impl.decoder\");\ngoog.require(\"com.cognitect.transit.util\");\ngoog.require(\"com.cognitect.transit.delimiters\");\ngoog.require(\"com.cognitect.transit.caching\");\ngoog.require(\"com.cognitect.transit.types\");\ngoog.scope(function() {\n  var decoder = com.cognitect.transit.impl.decoder, util = com.cognitect.transit.util, d = com.cognitect.transit.delimiters, caching = com.cognitect.transit.caching, types = com.cognitect.transit.types;\n  decoder.Tag = function Transit$Tag(s) {\n    this.str = s;\n  };\n  decoder.tag = function(s) {\n    return new decoder.Tag(s);\n  };\n  decoder.isTag = function(x) {\n    return x && x instanceof decoder.Tag;\n  };\n  decoder.isGroundHandler = function(handler) {\n    switch(handler) {\n      case \"_\":\n      case \"s\":\n      case \"?\":\n      case \"i\":\n      case \"d\":\n      case \"b\":\n      case \"'\":\n      case \"array\":\n      case \"map\":\n        return true;\n    }\n    return false;\n  };\n  decoder.Decoder = function Transit$Decoder(options) {\n    this.options = options || {};\n    this.handlers = {};\n    for (var h in this.defaults.handlers) {\n      this.handlers[h] = this.defaults.handlers[h];\n    }\n    for (var h in this.options[\"handlers\"]) {\n      if (decoder.isGroundHandler(h)) {\n        throw new Error('Cannot override handler for ground type \"' + h + '\"');\n      }\n      this.handlers[h] = this.options[\"handlers\"][h];\n    }\n    this.preferStrings = this.options[\"preferStrings\"] != null ? this.options[\"preferStrings\"] : this.defaults.preferStrings;\n    this.preferBuffers = this.options[\"preferBuffers\"] != null ? this.options[\"preferBuffers\"] : this.defaults.preferBuffers;\n    this.defaultHandler = this.options[\"defaultHandler\"] || this.defaults.defaultHandler;\n    this.mapBuilder = this.options[\"mapBuilder\"];\n    this.arrayBuilder = this.options[\"arrayBuilder\"];\n  };\n  decoder.Decoder.prototype.defaults = {handlers:{\"_\":function(v, d) {\n    return types.nullValue();\n  }, \"?\":function(v, d) {\n    return types.boolValue(v);\n  }, \"b\":function(v, d) {\n    return types.binary(v, d);\n  }, \"i\":function(v, d) {\n    return types.intValue(v);\n  }, \"n\":function(v, d) {\n    return types.bigInteger(v);\n  }, \"d\":function(v, d) {\n    return types.floatValue(v);\n  }, \"f\":function(v, d) {\n    return types.bigDecimalValue(v);\n  }, \"c\":function(v, d) {\n    return types.charValue(v);\n  }, \":\":function(v, d) {\n    return types.keyword(v);\n  }, \"$\":function(v, d) {\n    return types.symbol(v);\n  }, \"r\":function(v, d) {\n    return types.uri(v);\n  }, \"z\":function(v, d) {\n    return types.specialDouble(v);\n  }, \"'\":function(v, d) {\n    return v;\n  }, \"m\":function(v, d) {\n    return types.date(v);\n  }, \"t\":function(v, d) {\n    return types.verboseDate(v);\n  }, \"u\":function(v, d) {\n    return types.uuid(v);\n  }, \"set\":function(v, d) {\n    return types.set(v);\n  }, \"list\":function(v, d) {\n    return types.list(v);\n  }, \"link\":function(v, d) {\n    return types.link(v);\n  }, \"cmap\":function(v, d) {\n    return types.map(v, false);\n  }}, defaultHandler:function(c, val) {\n    return types.taggedValue(c, val);\n  }, preferStrings:true, preferBuffers:true};\n  decoder.Decoder.prototype.decode = function(node, cache, asMapKey, tagValue) {\n    if (node == null) {\n      return null;\n    }\n    var t = typeof node;\n    switch(t) {\n      case \"string\":\n        return this.decodeString(node, cache, asMapKey, tagValue);\n        break;\n      case \"object\":\n        if (util.isArray(node)) {\n          if (node[0] === \"^ \") {\n            return this.decodeArrayHash(node, cache, asMapKey, tagValue);\n          } else {\n            return this.decodeArray(node, cache, asMapKey, tagValue);\n          }\n        } else {\n          return this.decodeHash(node, cache, asMapKey, tagValue);\n        }\n        break;\n    }\n    return node;\n  };\n  decoder.Decoder.prototype[\"decode\"] = decoder.Decoder.prototype.decode;\n  decoder.Decoder.prototype.decodeString = function(string, cache, asMapKey, tagValue) {\n    if (caching.isCacheable(string, asMapKey)) {\n      var val = this.parseString(string, cache, false);\n      if (cache) {\n        cache.write(val, asMapKey);\n      }\n      return val;\n    } else {\n      if (caching.isCacheCode(string)) {\n        return cache.read(string, asMapKey);\n      } else {\n        return this.parseString(string, cache, asMapKey);\n      }\n    }\n  };\n  decoder.Decoder.prototype.decodeHash = function(hash, cache, asMapKey, tagValue) {\n    var ks = util.objectKeys(hash), key = ks[0], tag = ks.length == 1 ? this.decode(key, cache, false, false) : null;\n    if (decoder.isTag(tag)) {\n      var val = hash[key], handler = this.handlers[tag.str];\n      if (handler != null) {\n        return handler(this.decode(val, cache, false, true), this);\n      } else {\n        return types.taggedValue(tag.str, this.decode(val, cache, false, false));\n      }\n    } else {\n      if (this.mapBuilder) {\n        if (ks.length < types.SMALL_ARRAY_MAP_THRESHOLD * 2 && this.mapBuilder.fromArray) {\n          var nodep = [];\n          for (var i = 0; i < ks.length; i++) {\n            var strKey = ks[i];\n            nodep.push(this.decode(strKey, cache, true, false));\n            nodep.push(this.decode(hash[strKey], cache, false, false));\n          }\n          return this.mapBuilder.fromArray(nodep, hash);\n        } else {\n          var ret = this.mapBuilder.init(hash);\n          for (var i = 0; i < ks.length; i++) {\n            var strKey = ks[i];\n            ret = this.mapBuilder.add(ret, this.decode(strKey, cache, true, false), this.decode(hash[strKey], cache, false, false), hash);\n          }\n          return this.mapBuilder.finalize(ret, hash);\n        }\n      } else {\n        var nodep = [];\n        for (var i = 0; i < ks.length; i++) {\n          var strKey = ks[i];\n          nodep.push(this.decode(strKey, cache, true, false));\n          nodep.push(this.decode(hash[strKey], cache, false, false));\n        }\n        return types.map(nodep, false);\n      }\n    }\n  };\n  decoder.Decoder.prototype.decodeArrayHash = function(node, cache, asMapKey, tagValue) {\n    if (this.mapBuilder) {\n      if (node.length < types.SMALL_ARRAY_MAP_THRESHOLD * 2 + 1 && this.mapBuilder.fromArray) {\n        var nodep = [];\n        for (var i = 1; i < node.length; i += 2) {\n          nodep.push(this.decode(node[i], cache, true, false));\n          nodep.push(this.decode(node[i + 1], cache, false, false));\n        }\n        return this.mapBuilder.fromArray(nodep, node);\n      } else {\n        var ret = this.mapBuilder.init(node);\n        for (var i = 1; i < node.length; i += 2) {\n          ret = this.mapBuilder.add(ret, this.decode(node[i], cache, true, false), this.decode(node[i + 1], cache, false, false), node);\n        }\n        return this.mapBuilder.finalize(ret, node);\n      }\n    } else {\n      var nodep = [];\n      for (var i = 1; i < node.length; i += 2) {\n        nodep.push(this.decode(node[i], cache, true, false));\n        nodep.push(this.decode(node[i + 1], cache, false, false));\n      }\n      return types.map(nodep, false);\n    }\n  };\n  decoder.Decoder.prototype.decodeArray = function(node, cache, asMapKey, tagValue) {\n    if (tagValue) {\n      var ret = [];\n      for (var i = 0; i < node.length; i++) {\n        ret.push(this.decode(node[i], cache, asMapKey, false));\n      }\n      return ret;\n    } else {\n      var cacheIdx = cache && cache.idx;\n      if (node.length === 2 && typeof node[0] === \"string\") {\n        var tag = this.decode(node[0], cache, false, false);\n        if (decoder.isTag(tag)) {\n          var val = node[1], handler = this.handlers[tag.str];\n          if (handler != null) {\n            var ret = handler(this.decode(val, cache, asMapKey, true), this);\n            return ret;\n          } else {\n            return types.taggedValue(tag.str, this.decode(val, cache, asMapKey, false));\n          }\n        }\n      }\n      if (cache && cacheIdx != cache.idx) {\n        cache.idx = cacheIdx;\n      }\n      if (this.arrayBuilder) {\n        if (node.length <= 32 && this.arrayBuilder.fromArray) {\n          var arr = [];\n          for (var i = 0; i < node.length; i++) {\n            arr.push(this.decode(node[i], cache, asMapKey, false));\n          }\n          return this.arrayBuilder.fromArray(arr, node);\n        } else {\n          var ret = this.arrayBuilder.init(node);\n          for (var i = 0; i < node.length; i++) {\n            ret = this.arrayBuilder.add(ret, this.decode(node[i], cache, asMapKey, false), node);\n          }\n          return this.arrayBuilder.finalize(ret, node);\n        }\n      } else {\n        var ret = [];\n        for (var i = 0; i < node.length; i++) {\n          ret.push(this.decode(node[i], cache, asMapKey, false));\n        }\n        return ret;\n      }\n    }\n  };\n  decoder.Decoder.prototype.parseString = function(string, cache, asMapKey) {\n    if (string.charAt(0) === d.ESC) {\n      var c = string.charAt(1);\n      if (c === d.ESC || c === d.SUB || c === d.RES) {\n        return string.substring(1);\n      } else {\n        if (c === d.TAG) {\n          return decoder.tag(string.substring(2));\n        } else {\n          var handler = this.handlers[c];\n          if (handler == null) {\n            return this.defaultHandler(c, string.substring(2));\n          } else {\n            return handler(string.substring(2), this);\n          }\n        }\n      }\n    } else {\n      return string;\n    }\n  };\n  decoder.decoder = function(options) {\n    return new decoder.Decoder(options);\n  };\n});\n","~:source","// Copyright 2014 Cognitect. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide(\"com.cognitect.transit.impl.decoder\");\ngoog.require(\"com.cognitect.transit.util\");\ngoog.require(\"com.cognitect.transit.delimiters\");\ngoog.require(\"com.cognitect.transit.caching\");\ngoog.require(\"com.cognitect.transit.types\");\n\ngoog.scope(function () {\n\n    var decoder = com.cognitect.transit.impl.decoder,\n        util    = com.cognitect.transit.util,\n        d       = com.cognitect.transit.delimiters,\n        caching = com.cognitect.transit.caching,\n        types   = com.cognitect.transit.types;\n\n    // =========================================================================\n    // Decoder\n\n    /**\n     * @constructor\n     */\n    decoder.Tag = function Transit$Tag(s) {\n        this.str = s;\n    };\n\n    decoder.tag = function (s) {\n        return new decoder.Tag(s);\n    };\n\n    decoder.isTag = function (x) {\n        return x && (x instanceof decoder.Tag);\n    };\n\n    decoder.isGroundHandler = function (handler) {\n        switch (handler) {\n            case \"_\":\n            case \"s\":\n            case \"?\":\n            case \"i\":\n            case \"d\":\n            case \"b\":\n            case \"'\":\n            case \"array\":\n            case \"map\":\n                return true;\n        }\n        return false;\n    };\n\n    /**\n     * A transit decoder\n     * @constructor\n     */\n    decoder.Decoder = function Transit$Decoder(options) {\n        this.options = options || {};\n        this.handlers = {};\n        for (var h in this.defaults.handlers) {\n            this.handlers[h] = this.defaults.handlers[h];\n        }\n        for (var h in this.options[\"handlers\"]) {\n            if (decoder.isGroundHandler(h)) {\n                throw new Error(\"Cannot override handler for ground type \\\"\" + h + \"\\\"\");\n            }\n            this.handlers[h] = this.options[\"handlers\"][h];\n        }\n        this.preferStrings = this.options[\"preferStrings\"] != null ? this.options[\"preferStrings\"] : this.defaults.preferStrings;\n        this.preferBuffers = this.options[\"preferBuffers\"] != null ? this.options[\"preferBuffers\"] : this.defaults.preferBuffers;\n        this.defaultHandler = this.options[\"defaultHandler\"] || this.defaults.defaultHandler;\n        /* NOT PUBLIC */\n        this.mapBuilder = this.options[\"mapBuilder\"];\n        this.arrayBuilder = this.options[\"arrayBuilder\"];\n    };\n\n\n    decoder.Decoder.prototype.defaults = {\n        handlers: {\n            \"_\": function (v, d) {\n                return types.nullValue();\n            },\n            \"?\": function (v, d) {\n                return types.boolValue(v);\n            },\n            \"b\": function (v, d) {\n                return types.binary(v, d);\n            },\n            \"i\": function (v, d) {\n                return types.intValue(v);\n            },\n            \"n\": function (v, d) {\n                return types.bigInteger(v);\n            },\n            \"d\": function (v, d) {\n                return types.floatValue(v);\n            },\n            \"f\": function (v, d) {\n                return types.bigDecimalValue(v);\n            },\n            \"c\": function (v, d) {\n                return types.charValue(v);\n            },\n            \":\": function (v, d) {\n                return types.keyword(v);\n            },\n            \"$\": function (v, d) {\n                return types.symbol(v);\n            },\n            \"r\": function (v, d) {\n                return types.uri(v);\n            },\n            \"z\": function (v, d) {\n                return types.specialDouble(v);\n            },\n\n            // tagged\n            \"'\": function (v, d) {\n                return v;\n            },\n            \"m\": function (v, d) {\n                return types.date(v);\n            },\n            \"t\": function (v, d) {\n                return types.verboseDate(v);\n            },\n            \"u\": function (v, d) {\n                return types.uuid(v);\n            },\n            \"set\": function (v, d) {\n                return types.set(v);\n            },\n            \"list\": function (v, d) {\n                return types.list(v);\n            },\n            \"link\": function (v, d) {\n                return types.link(v);\n            },\n            \"cmap\": function (v, d) {\n                return types.map(v, false);\n            }\n        },\n        defaultHandler: function (c, val) {\n            return types.taggedValue(c, val);\n        },\n        preferStrings: true,\n        preferBuffers: true\n    };\n\n    /**\n     * @param {*} node\n     * @param {*} cache\n     * @param {boolean=} asMapKey\n     * @param {boolean=} tagValue\n     * @returns {*}\n     */\n    decoder.Decoder.prototype.decode = function (node, cache, asMapKey, tagValue) {\n        if (node == null) return null;\n\n        var t = typeof node;\n\n        switch (t) {\n            case \"string\":\n                return this.decodeString(node, cache, asMapKey, tagValue);\n                break;\n            case \"object\":\n                if (util.isArray(node)) {\n                    if (node[0] === \"^ \") {\n                        return this.decodeArrayHash(node, cache, asMapKey, tagValue);\n                    } else {\n                        return this.decodeArray(node, cache, asMapKey, tagValue);\n                    }\n                } else {\n                    return this.decodeHash(node, cache, asMapKey, tagValue);\n                }\n                break;\n        }\n\n        return node;\n    };\n    decoder.Decoder.prototype[\"decode\"] = decoder.Decoder.prototype.decode;\n\n    decoder.Decoder.prototype.decodeString = function (string, cache, asMapKey, tagValue) {\n        if (caching.isCacheable(string, asMapKey)) {\n            var val = this.parseString(string, cache, false);\n            if (cache) {\n                cache.write(val, asMapKey);\n            }\n            return val;\n        } else if (caching.isCacheCode(string)) {\n            return cache.read(string, asMapKey);\n        } else {\n            return this.parseString(string, cache, asMapKey);\n        }\n    };\n\n    decoder.Decoder.prototype.decodeHash = function (hash, cache, asMapKey, tagValue) {\n        var ks = util.objectKeys(hash),\n            key = ks[0],\n            tag = ks.length == 1 ? this.decode(key, cache, false, false) : null;\n\n        if (decoder.isTag(tag)) {\n            var val = hash[key],\n                handler = this.handlers[tag.str];\n            if (handler != null) {\n                return handler(this.decode(val, cache, false, true), this);\n            } else {\n                return types.taggedValue(tag.str, this.decode(val, cache, false, false));\n            }\n        } else if (this.mapBuilder) {\n            if ((ks.length < (types.SMALL_ARRAY_MAP_THRESHOLD * 2)) && this.mapBuilder.fromArray) {\n                var nodep = [];\n                for (var i = 0; i < ks.length; i++) {\n                    var strKey = ks[i];\n                    nodep.push(this.decode(strKey, cache, true, false));\n                    nodep.push(this.decode(hash[strKey], cache, false, false));\n                }\n                return this.mapBuilder.fromArray(nodep, hash);\n            } else {\n                var ret = this.mapBuilder.init(hash);\n                for (var i = 0; i < ks.length; i++) {\n                    var strKey = ks[i];\n                    ret = this.mapBuilder.add(ret,\n                        this.decode(strKey, cache, true, false),\n                        this.decode(hash[strKey], cache, false, false),\n                        hash);\n                }\n                return this.mapBuilder.finalize(ret, hash);\n            }\n        } else {\n            var nodep = [];\n\n            for (var i = 0; i < ks.length; i++) {\n                var strKey = ks[i];\n                nodep.push(this.decode(strKey, cache, true, false));\n                nodep.push(this.decode(hash[strKey], cache, false, false));\n            }\n\n            return types.map(nodep, false);\n        }\n    };\n\n    decoder.Decoder.prototype.decodeArrayHash = function (node, cache, asMapKey, tagValue) {\n        if (this.mapBuilder) {\n            if ((node.length < ((types.SMALL_ARRAY_MAP_THRESHOLD * 2) + 1)) && this.mapBuilder.fromArray) {\n                var nodep = [];\n                for (var i = 1; i < node.length; i += 2) {\n                    nodep.push(this.decode(node[i], cache, true, false));\n                    nodep.push(this.decode(node[i + 1], cache, false, false));\n                }\n                return this.mapBuilder.fromArray(nodep, node);\n            } else {\n                var ret = this.mapBuilder.init(node);\n                for (var i = 1; i < node.length; i += 2) {\n                    ret = this.mapBuilder.add(ret,\n                        this.decode(node[i], cache, true, false),\n                        this.decode(node[i + 1], cache, false, false),\n                        node)\n                }\n                return this.mapBuilder.finalize(ret, node);\n            }\n        } else {\n            var nodep = [];\n\n            // collect keys\n            for (var i = 1; i < node.length; i += 2) {\n                nodep.push(this.decode(node[i], cache, true, false));\n                nodep.push(this.decode(node[i + 1], cache, false, false));\n            }\n\n            return types.map(nodep, false);\n        }\n    };\n\n    decoder.Decoder.prototype.decodeArray = function (node, cache, asMapKey, tagValue) {\n        if (tagValue) {\n            var ret = [];\n            for (var i = 0; i < node.length; i++) {\n                ret.push(this.decode(node[i], cache, asMapKey, false));\n            }\n            return ret;\n        } else {\n            var cacheIdx = cache && cache.idx;\n            // tagged value as 2-array case\n            if ((node.length === 2) &&\n                (typeof node[0] === \"string\")) {\n                var tag = this.decode(node[0], cache, false, false);\n                if (decoder.isTag(tag)) {\n                    var val = node[1],\n                        handler = this.handlers[tag.str];\n                    if (handler != null) {\n                        var ret = handler(this.decode(val, cache, asMapKey, true), this);\n                        return ret;\n                    } else {\n                        return types.taggedValue(tag.str, this.decode(val, cache, asMapKey, false))\n                    }\n                }\n            }\n\n            // rewind cache\n            if (cache && (cacheIdx != cache.idx)) {\n                cache.idx = cacheIdx;\n            }\n\n            if (this.arrayBuilder) {\n                // NOTE: hard coded for ClojureScript for now - David\n                if (node.length <= 32 && this.arrayBuilder.fromArray) {\n                    var arr = [];\n                    for (var i = 0; i < node.length; i++) {\n                        arr.push(this.decode(node[i], cache, asMapKey, false));\n                    }\n                    return this.arrayBuilder.fromArray(arr, node);\n                } else {\n                    var ret = this.arrayBuilder.init(node);\n                    for (var i = 0; i < node.length; i++) {\n                        ret = this.arrayBuilder.add(ret, this.decode(node[i], cache, asMapKey, false), node);\n                    }\n                    return this.arrayBuilder.finalize(ret, node);\n                }\n            } else {\n                var ret = [];\n                for (var i = 0; i < node.length; i++) {\n                    ret.push(this.decode(node[i], cache, asMapKey, false));\n                }\n                return ret;\n            }\n        }\n    };\n\n    decoder.Decoder.prototype.parseString = function (string, cache, asMapKey) {\n        if (string.charAt(0) === d.ESC) {\n            var c = string.charAt(1);\n            if (c === d.ESC || c === d.SUB || c === d.RES) {\n                return string.substring(1);\n            } else if (c === d.TAG) {\n                return decoder.tag(string.substring(2));\n            } else {\n                var handler = this.handlers[c];\n                if (handler == null) {\n                    return this.defaultHandler(c, string.substring(2));\n                } else {\n                    return handler(string.substring(2), this);\n                }\n            }\n        } else {\n            return string;\n        }\n    };\n\n    decoder.decoder = function (options) {\n        return new decoder.Decoder(options);\n    };\n\n});\n","~:compiled-at",1623605884967,"~:source-map-json","{\n\"version\":3,\n\"file\":\"com.cognitect.transit.impl.decoder.js\",\n\"lineCount\":267,\n\"mappings\":\"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\",\n\"sources\":[\"com/cognitect/transit/impl/decoder.js\"],\n\"sourcesContent\":[\"// Copyright 2014 Cognitect. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\ngoog.provide(\\\"com.cognitect.transit.impl.decoder\\\");\\ngoog.require(\\\"com.cognitect.transit.util\\\");\\ngoog.require(\\\"com.cognitect.transit.delimiters\\\");\\ngoog.require(\\\"com.cognitect.transit.caching\\\");\\ngoog.require(\\\"com.cognitect.transit.types\\\");\\n\\ngoog.scope(function () {\\n\\n    var decoder = com.cognitect.transit.impl.decoder,\\n        util    = com.cognitect.transit.util,\\n        d       = com.cognitect.transit.delimiters,\\n        caching = com.cognitect.transit.caching,\\n        types   = com.cognitect.transit.types;\\n\\n    // =========================================================================\\n    // Decoder\\n\\n    /**\\n     * @constructor\\n     */\\n    decoder.Tag = function Transit$Tag(s) {\\n        this.str = s;\\n    };\\n\\n    decoder.tag = function (s) {\\n        return new decoder.Tag(s);\\n    };\\n\\n    decoder.isTag = function (x) {\\n        return x && (x instanceof decoder.Tag);\\n    };\\n\\n    decoder.isGroundHandler = function (handler) {\\n        switch (handler) {\\n            case \\\"_\\\":\\n            case \\\"s\\\":\\n            case \\\"?\\\":\\n            case \\\"i\\\":\\n            case \\\"d\\\":\\n            case \\\"b\\\":\\n            case \\\"'\\\":\\n            case \\\"array\\\":\\n            case \\\"map\\\":\\n                return true;\\n        }\\n        return false;\\n    };\\n\\n    /**\\n     * A transit decoder\\n     * @constructor\\n     */\\n    decoder.Decoder = function Transit$Decoder(options) {\\n        this.options = options || {};\\n        this.handlers = {};\\n        for (var h in this.defaults.handlers) {\\n            this.handlers[h] = this.defaults.handlers[h];\\n        }\\n        for (var h in this.options[\\\"handlers\\\"]) {\\n            if (decoder.isGroundHandler(h)) {\\n                throw new Error(\\\"Cannot override handler for ground type \\\\\\\"\\\" + h + \\\"\\\\\\\"\\\");\\n            }\\n            this.handlers[h] = this.options[\\\"handlers\\\"][h];\\n        }\\n        this.preferStrings = this.options[\\\"preferStrings\\\"] != null ? this.options[\\\"preferStrings\\\"] : this.defaults.preferStrings;\\n        this.preferBuffers = this.options[\\\"preferBuffers\\\"] != null ? this.options[\\\"preferBuffers\\\"] : this.defaults.preferBuffers;\\n        this.defaultHandler = this.options[\\\"defaultHandler\\\"] || this.defaults.defaultHandler;\\n        /* NOT PUBLIC */\\n        this.mapBuilder = this.options[\\\"mapBuilder\\\"];\\n        this.arrayBuilder = this.options[\\\"arrayBuilder\\\"];\\n    };\\n\\n\\n    decoder.Decoder.prototype.defaults = {\\n        handlers: {\\n            \\\"_\\\": function (v, d) {\\n                return types.nullValue();\\n            },\\n            \\\"?\\\": function (v, d) {\\n                return types.boolValue(v);\\n            },\\n            \\\"b\\\": function (v, d) {\\n                return types.binary(v, d);\\n            },\\n            \\\"i\\\": function (v, d) {\\n                return types.intValue(v);\\n            },\\n            \\\"n\\\": function (v, d) {\\n                return types.bigInteger(v);\\n            },\\n            \\\"d\\\": function (v, d) {\\n                return types.floatValue(v);\\n            },\\n            \\\"f\\\": function (v, d) {\\n                return types.bigDecimalValue(v);\\n            },\\n            \\\"c\\\": function (v, d) {\\n                return types.charValue(v);\\n            },\\n            \\\":\\\": function (v, d) {\\n                return types.keyword(v);\\n            },\\n            \\\"$\\\": function (v, d) {\\n                return types.symbol(v);\\n            },\\n            \\\"r\\\": function (v, d) {\\n                return types.uri(v);\\n            },\\n            \\\"z\\\": function (v, d) {\\n                return types.specialDouble(v);\\n            },\\n\\n            // tagged\\n            \\\"'\\\": function (v, d) {\\n                return v;\\n            },\\n            \\\"m\\\": function (v, d) {\\n                return types.date(v);\\n            },\\n            \\\"t\\\": function (v, d) {\\n                return types.verboseDate(v);\\n            },\\n            \\\"u\\\": function (v, d) {\\n                return types.uuid(v);\\n            },\\n            \\\"set\\\": function (v, d) {\\n                return types.set(v);\\n            },\\n            \\\"list\\\": function (v, d) {\\n                return types.list(v);\\n            },\\n            \\\"link\\\": function (v, d) {\\n                return types.link(v);\\n            },\\n            \\\"cmap\\\": function (v, d) {\\n                return types.map(v, false);\\n            }\\n        },\\n        defaultHandler: function (c, val) {\\n            return types.taggedValue(c, val);\\n        },\\n        preferStrings: true,\\n        preferBuffers: true\\n    };\\n\\n    /**\\n     * @param {*} node\\n     * @param {*} cache\\n     * @param {boolean=} asMapKey\\n     * @param {boolean=} tagValue\\n     * @returns {*}\\n     */\\n    decoder.Decoder.prototype.decode = function (node, cache, asMapKey, tagValue) {\\n        if (node == null) return null;\\n\\n        var t = typeof node;\\n\\n        switch (t) {\\n            case \\\"string\\\":\\n                return this.decodeString(node, cache, asMapKey, tagValue);\\n                break;\\n            case \\\"object\\\":\\n                if (util.isArray(node)) {\\n                    if (node[0] === \\\"^ \\\") {\\n                        return this.decodeArrayHash(node, cache, asMapKey, tagValue);\\n                    } else {\\n                        return this.decodeArray(node, cache, asMapKey, tagValue);\\n                    }\\n                } else {\\n                    return this.decodeHash(node, cache, asMapKey, tagValue);\\n                }\\n                break;\\n        }\\n\\n        return node;\\n    };\\n    decoder.Decoder.prototype[\\\"decode\\\"] = decoder.Decoder.prototype.decode;\\n\\n    decoder.Decoder.prototype.decodeString = function (string, cache, asMapKey, tagValue) {\\n        if (caching.isCacheable(string, asMapKey)) {\\n            var val = this.parseString(string, cache, false);\\n            if (cache) {\\n                cache.write(val, asMapKey);\\n            }\\n            return val;\\n        } else if (caching.isCacheCode(string)) {\\n            return cache.read(string, asMapKey);\\n        } else {\\n            return this.parseString(string, cache, asMapKey);\\n        }\\n    };\\n\\n    decoder.Decoder.prototype.decodeHash = function (hash, cache, asMapKey, tagValue) {\\n        var ks = util.objectKeys(hash),\\n            key = ks[0],\\n            tag = ks.length == 1 ? this.decode(key, cache, false, false) : null;\\n\\n        if (decoder.isTag(tag)) {\\n            var val = hash[key],\\n                handler = this.handlers[tag.str];\\n            if (handler != null) {\\n                return handler(this.decode(val, cache, false, true), this);\\n            } else {\\n                return types.taggedValue(tag.str, this.decode(val, cache, false, false));\\n            }\\n        } else if (this.mapBuilder) {\\n            if ((ks.length < (types.SMALL_ARRAY_MAP_THRESHOLD * 2)) && this.mapBuilder.fromArray) {\\n                var nodep = [];\\n                for (var i = 0; i < ks.length; i++) {\\n                    var strKey = ks[i];\\n                    nodep.push(this.decode(strKey, cache, true, false));\\n                    nodep.push(this.decode(hash[strKey], cache, false, false));\\n                }\\n                return this.mapBuilder.fromArray(nodep, hash);\\n            } else {\\n                var ret = this.mapBuilder.init(hash);\\n                for (var i = 0; i < ks.length; i++) {\\n                    var strKey = ks[i];\\n                    ret = this.mapBuilder.add(ret,\\n                        this.decode(strKey, cache, true, false),\\n                        this.decode(hash[strKey], cache, false, false),\\n                        hash);\\n                }\\n                return this.mapBuilder.finalize(ret, hash);\\n            }\\n        } else {\\n            var nodep = [];\\n\\n            for (var i = 0; i < ks.length; i++) {\\n                var strKey = ks[i];\\n                nodep.push(this.decode(strKey, cache, true, false));\\n                nodep.push(this.decode(hash[strKey], cache, false, false));\\n            }\\n\\n            return types.map(nodep, false);\\n        }\\n    };\\n\\n    decoder.Decoder.prototype.decodeArrayHash = function (node, cache, asMapKey, tagValue) {\\n        if (this.mapBuilder) {\\n            if ((node.length < ((types.SMALL_ARRAY_MAP_THRESHOLD * 2) + 1)) && this.mapBuilder.fromArray) {\\n                var nodep = [];\\n                for (var i = 1; i < node.length; i += 2) {\\n                    nodep.push(this.decode(node[i], cache, true, false));\\n                    nodep.push(this.decode(node[i + 1], cache, false, false));\\n                }\\n                return this.mapBuilder.fromArray(nodep, node);\\n            } else {\\n                var ret = this.mapBuilder.init(node);\\n                for (var i = 1; i < node.length; i += 2) {\\n                    ret = this.mapBuilder.add(ret,\\n                        this.decode(node[i], cache, true, false),\\n                        this.decode(node[i + 1], cache, false, false),\\n                        node)\\n                }\\n                return this.mapBuilder.finalize(ret, node);\\n            }\\n        } else {\\n            var nodep = [];\\n\\n            // collect keys\\n            for (var i = 1; i < node.length; i += 2) {\\n                nodep.push(this.decode(node[i], cache, true, false));\\n                nodep.push(this.decode(node[i + 1], cache, false, false));\\n            }\\n\\n            return types.map(nodep, false);\\n        }\\n    };\\n\\n    decoder.Decoder.prototype.decodeArray = function (node, cache, asMapKey, tagValue) {\\n        if (tagValue) {\\n            var ret = [];\\n            for (var i = 0; i < node.length; i++) {\\n                ret.push(this.decode(node[i], cache, asMapKey, false));\\n            }\\n            return ret;\\n        } else {\\n            var cacheIdx = cache && cache.idx;\\n            // tagged value as 2-array case\\n            if ((node.length === 2) &&\\n                (typeof node[0] === \\\"string\\\")) {\\n                var tag = this.decode(node[0], cache, false, false);\\n                if (decoder.isTag(tag)) {\\n                    var val = node[1],\\n                        handler = this.handlers[tag.str];\\n                    if (handler != null) {\\n                        var ret = handler(this.decode(val, cache, asMapKey, true), this);\\n                        return ret;\\n                    } else {\\n                        return types.taggedValue(tag.str, this.decode(val, cache, asMapKey, false))\\n                    }\\n                }\\n            }\\n\\n            // rewind cache\\n            if (cache && (cacheIdx != cache.idx)) {\\n                cache.idx = cacheIdx;\\n            }\\n\\n            if (this.arrayBuilder) {\\n                // NOTE: hard coded for ClojureScript for now - David\\n                if (node.length <= 32 && this.arrayBuilder.fromArray) {\\n                    var arr = [];\\n                    for (var i = 0; i < node.length; i++) {\\n                        arr.push(this.decode(node[i], cache, asMapKey, false));\\n                    }\\n                    return this.arrayBuilder.fromArray(arr, node);\\n                } else {\\n                    var ret = this.arrayBuilder.init(node);\\n                    for (var i = 0; i < node.length; i++) {\\n                        ret = this.arrayBuilder.add(ret, this.decode(node[i], cache, asMapKey, false), node);\\n                    }\\n                    return this.arrayBuilder.finalize(ret, node);\\n                }\\n            } else {\\n                var ret = [];\\n                for (var i = 0; i < node.length; i++) {\\n                    ret.push(this.decode(node[i], cache, asMapKey, false));\\n                }\\n                return ret;\\n            }\\n        }\\n    };\\n\\n    decoder.Decoder.prototype.parseString = function (string, cache, asMapKey) {\\n        if (string.charAt(0) === d.ESC) {\\n            var c = string.charAt(1);\\n            if (c === d.ESC || c === d.SUB || c === d.RES) {\\n                return string.substring(1);\\n            } else if (c === d.TAG) {\\n                return decoder.tag(string.substring(2));\\n            } else {\\n                var handler = this.handlers[c];\\n                if (handler == null) {\\n                    return this.defaultHandler(c, string.substring(2));\\n                } else {\\n                    return handler(string.substring(2), this);\\n                }\\n            }\\n        } else {\\n            return string;\\n        }\\n    };\\n\\n    decoder.decoder = function (options) {\\n        return new decoder.Decoder(options);\\n    };\\n\\n});\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"scope\",\"decoder\",\"com\",\"cognitect\",\"transit\",\"impl\",\"util\",\"d\",\"delimiters\",\"caching\",\"types\",\"Tag\",\"decoder.Tag\",\"Transit$Tag\",\"s\",\"str\",\"tag\",\"decoder.tag\",\"isTag\",\"decoder.isTag\",\"x\",\"isGroundHandler\",\"decoder.isGroundHandler\",\"handler\",\"Decoder\",\"decoder.Decoder\",\"Transit$Decoder\",\"options\",\"handlers\",\"h\",\"defaults\",\"Error\",\"preferStrings\",\"preferBuffers\",\"defaultHandler\",\"mapBuilder\",\"arrayBuilder\",\"prototype\",\"_\",\"v\",\"nullValue\",\"?\",\"boolValue\",\"b\",\"binary\",\"i\",\"intValue\",\"n\",\"bigInteger\",\"floatValue\",\"f\",\"bigDecimalValue\",\"c\",\"charValue\",\":\",\"keyword\",\"$\",\"symbol\",\"r\",\"uri\",\"z\",\"specialDouble\",\"'\",\"m\",\"date\",\"t\",\"verboseDate\",\"u\",\"uuid\",\"set\",\"list\",\"link\",\"cmap\",\"map\",\"val\",\"taggedValue\",\"decode\",\"decoder.Decoder.prototype.decode\",\"node\",\"cache\",\"asMapKey\",\"tagValue\",\"decodeString\",\"isArray\",\"decodeArrayHash\",\"decodeArray\",\"decodeHash\",\"decoder.Decoder.prototype.decodeString\",\"string\",\"isCacheable\",\"parseString\",\"write\",\"isCacheCode\",\"read\",\"decoder.Decoder.prototype.decodeHash\",\"hash\",\"ks\",\"objectKeys\",\"key\",\"length\",\"SMALL_ARRAY_MAP_THRESHOLD\",\"fromArray\",\"nodep\",\"strKey\",\"push\",\"ret\",\"init\",\"add\",\"finalize\",\"decoder.Decoder.prototype.decodeArrayHash\",\"decoder.Decoder.prototype.decodeArray\",\"cacheIdx\",\"idx\",\"arr\",\"decoder.Decoder.prototype.parseString\",\"charAt\",\"ESC\",\"SUB\",\"RES\",\"substring\",\"TAG\",\"decoder.decoder\"]\n}\n"]